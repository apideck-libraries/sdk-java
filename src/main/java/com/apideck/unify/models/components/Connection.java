/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */


package com.apideck.unify.models.components;
import com.apideck.unify.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

public class Connection {

    /**
     * The unique identifier of the connection.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * The ID of the service this connection belongs to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("service_id")
    private Optional<String> serviceId;

    /**
     * The name of the connection
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("name")
    private Optional<String> name;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tag_line")
    private Optional<String> tagLine;

    /**
     * The unified API category where the connection belongs to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("unified_api")
    private Optional<String> unifiedApi;

    /**
     * [Connection state flow](#section/Connection-state)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("state")
    private Optional<? extends ConnectionState> state;

    /**
     * The current state of the Integration.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("integration_state")
    private Optional<? extends IntegrationState> integrationState;

    /**
     * Type of authorization used by the connector
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("auth_type")
    private Optional<? extends AuthType> authType;

    /**
     * OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("oauth_grant_type")
    private Optional<? extends OAuthGrantType> oauthGrantType;

    /**
     * Status of the connection.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<? extends ConnectionStatus> status;

    /**
     * Whether the connection is enabled or not. You can enable or disable a connection using the Update Connection API.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("enabled")
    private Optional<Boolean> enabled;

    /**
     * The website URL of the connection
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("website")
    private Optional<String> website;

    /**
     * A visual icon of the connection, that will be shown in the Vault
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("icon")
    private Optional<String> icon;

    /**
     * The logo of the connection, that will be shown in the Vault
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("logo")
    private Optional<String> logo;

    /**
     * The OAuth redirect URI. Redirect your users to this URI to let them authorize your app in the connector's UI. Before you can use this URI, you must add `redirect_uri` as a query parameter to the `authorize_url`. Be sure to URL encode the `redirect_uri` part. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authorize_url")
    private JsonNullable<String> authorizeUrl;

    /**
     * The OAuth revoke URI. Redirect your users to this URI to revoke this connection. Before you can use this URI, you must add `redirect_uri` as a query parameter. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("revoke_url")
    private JsonNullable<String> revokeUrl;

    /**
     * Connection settings. Values will persist to `form_fields` with corresponding id
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("settings")
    private JsonNullable<? extends Map<String, Object>> settings;

    /**
     * Attach your own consumer specific metadata
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("metadata")
    private JsonNullable<? extends Map<String, Object>> metadata;

    /**
     * The settings that are wanted to create a connection.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("form_fields")
    private Optional<? extends List<FormField>> formFields;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("configuration")
    private Optional<? extends List<Configuration>> configuration;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("configurable_resources")
    private Optional<? extends List<String>> configurableResources;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("resource_schema_support")
    private Optional<? extends List<String>> resourceSchemaSupport;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("resource_settings_support")
    private Optional<? extends List<String>> resourceSettingsSupport;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("validation_support")
    private Optional<Boolean> validationSupport;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("schema_support")
    private Optional<Boolean> schemaSupport;

    /**
     * List of settings that are required to be configured on integration before authorization can occur
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("settings_required_for_authorization")
    private Optional<? extends List<String>> settingsRequiredForAuthorization;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subscriptions")
    private Optional<? extends List<WebhookSubscription>> subscriptions;

    /**
     * Whether the connector has a guide available in the developer docs or not (https://docs.apideck.com/connectors/{service_id}/docs/consumer+connection).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("has_guide")
    private Optional<Boolean> hasGuide;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_at")
    private Optional<Double> createdAt;

    /**
     * List of custom mappings configured for this connection
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_mappings")
    private Optional<? extends List<CustomMapping>> customMappings;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_at")
    private JsonNullable<Double> updatedAt;

    @JsonCreator
    public Connection(
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("service_id") Optional<String> serviceId,
            @JsonProperty("name") Optional<String> name,
            @JsonProperty("tag_line") Optional<String> tagLine,
            @JsonProperty("unified_api") Optional<String> unifiedApi,
            @JsonProperty("state") Optional<? extends ConnectionState> state,
            @JsonProperty("integration_state") Optional<? extends IntegrationState> integrationState,
            @JsonProperty("auth_type") Optional<? extends AuthType> authType,
            @JsonProperty("oauth_grant_type") Optional<? extends OAuthGrantType> oauthGrantType,
            @JsonProperty("status") Optional<? extends ConnectionStatus> status,
            @JsonProperty("enabled") Optional<Boolean> enabled,
            @JsonProperty("website") Optional<String> website,
            @JsonProperty("icon") Optional<String> icon,
            @JsonProperty("logo") Optional<String> logo,
            @JsonProperty("authorize_url") JsonNullable<String> authorizeUrl,
            @JsonProperty("revoke_url") JsonNullable<String> revokeUrl,
            @JsonProperty("settings") JsonNullable<? extends Map<String, Object>> settings,
            @JsonProperty("metadata") JsonNullable<? extends Map<String, Object>> metadata,
            @JsonProperty("form_fields") Optional<? extends List<FormField>> formFields,
            @JsonProperty("configuration") Optional<? extends List<Configuration>> configuration,
            @JsonProperty("configurable_resources") Optional<? extends List<String>> configurableResources,
            @JsonProperty("resource_schema_support") Optional<? extends List<String>> resourceSchemaSupport,
            @JsonProperty("resource_settings_support") Optional<? extends List<String>> resourceSettingsSupport,
            @JsonProperty("validation_support") Optional<Boolean> validationSupport,
            @JsonProperty("schema_support") Optional<Boolean> schemaSupport,
            @JsonProperty("settings_required_for_authorization") Optional<? extends List<String>> settingsRequiredForAuthorization,
            @JsonProperty("subscriptions") Optional<? extends List<WebhookSubscription>> subscriptions,
            @JsonProperty("has_guide") Optional<Boolean> hasGuide,
            @JsonProperty("created_at") Optional<Double> createdAt,
            @JsonProperty("custom_mappings") Optional<? extends List<CustomMapping>> customMappings,
            @JsonProperty("updated_at") JsonNullable<Double> updatedAt) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(serviceId, "serviceId");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(tagLine, "tagLine");
        Utils.checkNotNull(unifiedApi, "unifiedApi");
        Utils.checkNotNull(state, "state");
        Utils.checkNotNull(integrationState, "integrationState");
        Utils.checkNotNull(authType, "authType");
        Utils.checkNotNull(oauthGrantType, "oauthGrantType");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(enabled, "enabled");
        Utils.checkNotNull(website, "website");
        Utils.checkNotNull(icon, "icon");
        Utils.checkNotNull(logo, "logo");
        Utils.checkNotNull(authorizeUrl, "authorizeUrl");
        Utils.checkNotNull(revokeUrl, "revokeUrl");
        Utils.checkNotNull(settings, "settings");
        Utils.checkNotNull(metadata, "metadata");
        Utils.checkNotNull(formFields, "formFields");
        Utils.checkNotNull(configuration, "configuration");
        Utils.checkNotNull(configurableResources, "configurableResources");
        Utils.checkNotNull(resourceSchemaSupport, "resourceSchemaSupport");
        Utils.checkNotNull(resourceSettingsSupport, "resourceSettingsSupport");
        Utils.checkNotNull(validationSupport, "validationSupport");
        Utils.checkNotNull(schemaSupport, "schemaSupport");
        Utils.checkNotNull(settingsRequiredForAuthorization, "settingsRequiredForAuthorization");
        Utils.checkNotNull(subscriptions, "subscriptions");
        Utils.checkNotNull(hasGuide, "hasGuide");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(customMappings, "customMappings");
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.id = id;
        this.serviceId = serviceId;
        this.name = name;
        this.tagLine = tagLine;
        this.unifiedApi = unifiedApi;
        this.state = state;
        this.integrationState = integrationState;
        this.authType = authType;
        this.oauthGrantType = oauthGrantType;
        this.status = status;
        this.enabled = enabled;
        this.website = website;
        this.icon = icon;
        this.logo = logo;
        this.authorizeUrl = authorizeUrl;
        this.revokeUrl = revokeUrl;
        this.settings = settings;
        this.metadata = metadata;
        this.formFields = formFields;
        this.configuration = configuration;
        this.configurableResources = configurableResources;
        this.resourceSchemaSupport = resourceSchemaSupport;
        this.resourceSettingsSupport = resourceSettingsSupport;
        this.validationSupport = validationSupport;
        this.schemaSupport = schemaSupport;
        this.settingsRequiredForAuthorization = settingsRequiredForAuthorization;
        this.subscriptions = subscriptions;
        this.hasGuide = hasGuide;
        this.createdAt = createdAt;
        this.customMappings = customMappings;
        this.updatedAt = updatedAt;
    }
    
    public Connection() {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined());
    }

    /**
     * The unique identifier of the connection.
     */
    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * The ID of the service this connection belongs to.
     */
    @JsonIgnore
    public Optional<String> serviceId() {
        return serviceId;
    }

    /**
     * The name of the connection
     */
    @JsonIgnore
    public Optional<String> name() {
        return name;
    }

    @JsonIgnore
    public Optional<String> tagLine() {
        return tagLine;
    }

    /**
     * The unified API category where the connection belongs to.
     */
    @JsonIgnore
    public Optional<String> unifiedApi() {
        return unifiedApi;
    }

    /**
     * [Connection state flow](#section/Connection-state)
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ConnectionState> state() {
        return (Optional<ConnectionState>) state;
    }

    /**
     * The current state of the Integration.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<IntegrationState> integrationState() {
        return (Optional<IntegrationState>) integrationState;
    }

    /**
     * Type of authorization used by the connector
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<AuthType> authType() {
        return (Optional<AuthType>) authType;
    }

    /**
     * OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<OAuthGrantType> oauthGrantType() {
        return (Optional<OAuthGrantType>) oauthGrantType;
    }

    /**
     * Status of the connection.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ConnectionStatus> status() {
        return (Optional<ConnectionStatus>) status;
    }

    /**
     * Whether the connection is enabled or not. You can enable or disable a connection using the Update Connection API.
     */
    @JsonIgnore
    public Optional<Boolean> enabled() {
        return enabled;
    }

    /**
     * The website URL of the connection
     */
    @JsonIgnore
    public Optional<String> website() {
        return website;
    }

    /**
     * A visual icon of the connection, that will be shown in the Vault
     */
    @JsonIgnore
    public Optional<String> icon() {
        return icon;
    }

    /**
     * The logo of the connection, that will be shown in the Vault
     */
    @JsonIgnore
    public Optional<String> logo() {
        return logo;
    }

    /**
     * The OAuth redirect URI. Redirect your users to this URI to let them authorize your app in the connector's UI. Before you can use this URI, you must add `redirect_uri` as a query parameter to the `authorize_url`. Be sure to URL encode the `redirect_uri` part. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
     */
    @JsonIgnore
    public JsonNullable<String> authorizeUrl() {
        return authorizeUrl;
    }

    /**
     * The OAuth revoke URI. Redirect your users to this URI to revoke this connection. Before you can use this URI, you must add `redirect_uri` as a query parameter. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
     */
    @JsonIgnore
    public JsonNullable<String> revokeUrl() {
        return revokeUrl;
    }

    /**
     * Connection settings. Values will persist to `form_fields` with corresponding id
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Map<String, Object>> settings() {
        return (JsonNullable<Map<String, Object>>) settings;
    }

    /**
     * Attach your own consumer specific metadata
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Map<String, Object>> metadata() {
        return (JsonNullable<Map<String, Object>>) metadata;
    }

    /**
     * The settings that are wanted to create a connection.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<FormField>> formFields() {
        return (Optional<List<FormField>>) formFields;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Configuration>> configuration() {
        return (Optional<List<Configuration>>) configuration;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> configurableResources() {
        return (Optional<List<String>>) configurableResources;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> resourceSchemaSupport() {
        return (Optional<List<String>>) resourceSchemaSupport;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> resourceSettingsSupport() {
        return (Optional<List<String>>) resourceSettingsSupport;
    }

    @JsonIgnore
    public Optional<Boolean> validationSupport() {
        return validationSupport;
    }

    @JsonIgnore
    public Optional<Boolean> schemaSupport() {
        return schemaSupport;
    }

    /**
     * List of settings that are required to be configured on integration before authorization can occur
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<String>> settingsRequiredForAuthorization() {
        return (Optional<List<String>>) settingsRequiredForAuthorization;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<WebhookSubscription>> subscriptions() {
        return (Optional<List<WebhookSubscription>>) subscriptions;
    }

    /**
     * Whether the connector has a guide available in the developer docs or not (https://docs.apideck.com/connectors/{service_id}/docs/consumer+connection).
     */
    @JsonIgnore
    public Optional<Boolean> hasGuide() {
        return hasGuide;
    }

    @JsonIgnore
    public Optional<Double> createdAt() {
        return createdAt;
    }

    /**
     * List of custom mappings configured for this connection
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<CustomMapping>> customMappings() {
        return (Optional<List<CustomMapping>>) customMappings;
    }

    @JsonIgnore
    public JsonNullable<Double> updatedAt() {
        return updatedAt;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * The unique identifier of the connection.
     */
    public Connection withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }

    /**
     * The unique identifier of the connection.
     */
    public Connection withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * The ID of the service this connection belongs to.
     */
    public Connection withServiceId(String serviceId) {
        Utils.checkNotNull(serviceId, "serviceId");
        this.serviceId = Optional.ofNullable(serviceId);
        return this;
    }

    /**
     * The ID of the service this connection belongs to.
     */
    public Connection withServiceId(Optional<String> serviceId) {
        Utils.checkNotNull(serviceId, "serviceId");
        this.serviceId = serviceId;
        return this;
    }

    /**
     * The name of the connection
     */
    public Connection withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = Optional.ofNullable(name);
        return this;
    }

    /**
     * The name of the connection
     */
    public Connection withName(Optional<String> name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    public Connection withTagLine(String tagLine) {
        Utils.checkNotNull(tagLine, "tagLine");
        this.tagLine = Optional.ofNullable(tagLine);
        return this;
    }

    public Connection withTagLine(Optional<String> tagLine) {
        Utils.checkNotNull(tagLine, "tagLine");
        this.tagLine = tagLine;
        return this;
    }

    /**
     * The unified API category where the connection belongs to.
     */
    public Connection withUnifiedApi(String unifiedApi) {
        Utils.checkNotNull(unifiedApi, "unifiedApi");
        this.unifiedApi = Optional.ofNullable(unifiedApi);
        return this;
    }

    /**
     * The unified API category where the connection belongs to.
     */
    public Connection withUnifiedApi(Optional<String> unifiedApi) {
        Utils.checkNotNull(unifiedApi, "unifiedApi");
        this.unifiedApi = unifiedApi;
        return this;
    }

    /**
     * [Connection state flow](#section/Connection-state)
     */
    public Connection withState(ConnectionState state) {
        Utils.checkNotNull(state, "state");
        this.state = Optional.ofNullable(state);
        return this;
    }

    /**
     * [Connection state flow](#section/Connection-state)
     */
    public Connection withState(Optional<? extends ConnectionState> state) {
        Utils.checkNotNull(state, "state");
        this.state = state;
        return this;
    }

    /**
     * The current state of the Integration.
     */
    public Connection withIntegrationState(IntegrationState integrationState) {
        Utils.checkNotNull(integrationState, "integrationState");
        this.integrationState = Optional.ofNullable(integrationState);
        return this;
    }

    /**
     * The current state of the Integration.
     */
    public Connection withIntegrationState(Optional<? extends IntegrationState> integrationState) {
        Utils.checkNotNull(integrationState, "integrationState");
        this.integrationState = integrationState;
        return this;
    }

    /**
     * Type of authorization used by the connector
     */
    public Connection withAuthType(AuthType authType) {
        Utils.checkNotNull(authType, "authType");
        this.authType = Optional.ofNullable(authType);
        return this;
    }

    /**
     * Type of authorization used by the connector
     */
    public Connection withAuthType(Optional<? extends AuthType> authType) {
        Utils.checkNotNull(authType, "authType");
        this.authType = authType;
        return this;
    }

    /**
     * OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types
     */
    public Connection withOauthGrantType(OAuthGrantType oauthGrantType) {
        Utils.checkNotNull(oauthGrantType, "oauthGrantType");
        this.oauthGrantType = Optional.ofNullable(oauthGrantType);
        return this;
    }

    /**
     * OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types
     */
    public Connection withOauthGrantType(Optional<? extends OAuthGrantType> oauthGrantType) {
        Utils.checkNotNull(oauthGrantType, "oauthGrantType");
        this.oauthGrantType = oauthGrantType;
        return this;
    }

    /**
     * Status of the connection.
     */
    public Connection withStatus(ConnectionStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }

    /**
     * Status of the connection.
     */
    public Connection withStatus(Optional<? extends ConnectionStatus> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * Whether the connection is enabled or not. You can enable or disable a connection using the Update Connection API.
     */
    public Connection withEnabled(boolean enabled) {
        Utils.checkNotNull(enabled, "enabled");
        this.enabled = Optional.ofNullable(enabled);
        return this;
    }

    /**
     * Whether the connection is enabled or not. You can enable or disable a connection using the Update Connection API.
     */
    public Connection withEnabled(Optional<Boolean> enabled) {
        Utils.checkNotNull(enabled, "enabled");
        this.enabled = enabled;
        return this;
    }

    /**
     * The website URL of the connection
     */
    public Connection withWebsite(String website) {
        Utils.checkNotNull(website, "website");
        this.website = Optional.ofNullable(website);
        return this;
    }

    /**
     * The website URL of the connection
     */
    public Connection withWebsite(Optional<String> website) {
        Utils.checkNotNull(website, "website");
        this.website = website;
        return this;
    }

    /**
     * A visual icon of the connection, that will be shown in the Vault
     */
    public Connection withIcon(String icon) {
        Utils.checkNotNull(icon, "icon");
        this.icon = Optional.ofNullable(icon);
        return this;
    }

    /**
     * A visual icon of the connection, that will be shown in the Vault
     */
    public Connection withIcon(Optional<String> icon) {
        Utils.checkNotNull(icon, "icon");
        this.icon = icon;
        return this;
    }

    /**
     * The logo of the connection, that will be shown in the Vault
     */
    public Connection withLogo(String logo) {
        Utils.checkNotNull(logo, "logo");
        this.logo = Optional.ofNullable(logo);
        return this;
    }

    /**
     * The logo of the connection, that will be shown in the Vault
     */
    public Connection withLogo(Optional<String> logo) {
        Utils.checkNotNull(logo, "logo");
        this.logo = logo;
        return this;
    }

    /**
     * The OAuth redirect URI. Redirect your users to this URI to let them authorize your app in the connector's UI. Before you can use this URI, you must add `redirect_uri` as a query parameter to the `authorize_url`. Be sure to URL encode the `redirect_uri` part. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
     */
    public Connection withAuthorizeUrl(String authorizeUrl) {
        Utils.checkNotNull(authorizeUrl, "authorizeUrl");
        this.authorizeUrl = JsonNullable.of(authorizeUrl);
        return this;
    }

    /**
     * The OAuth redirect URI. Redirect your users to this URI to let them authorize your app in the connector's UI. Before you can use this URI, you must add `redirect_uri` as a query parameter to the `authorize_url`. Be sure to URL encode the `redirect_uri` part. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
     */
    public Connection withAuthorizeUrl(JsonNullable<String> authorizeUrl) {
        Utils.checkNotNull(authorizeUrl, "authorizeUrl");
        this.authorizeUrl = authorizeUrl;
        return this;
    }

    /**
     * The OAuth revoke URI. Redirect your users to this URI to revoke this connection. Before you can use this URI, you must add `redirect_uri` as a query parameter. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
     */
    public Connection withRevokeUrl(String revokeUrl) {
        Utils.checkNotNull(revokeUrl, "revokeUrl");
        this.revokeUrl = JsonNullable.of(revokeUrl);
        return this;
    }

    /**
     * The OAuth revoke URI. Redirect your users to this URI to revoke this connection. Before you can use this URI, you must add `redirect_uri` as a query parameter. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
     */
    public Connection withRevokeUrl(JsonNullable<String> revokeUrl) {
        Utils.checkNotNull(revokeUrl, "revokeUrl");
        this.revokeUrl = revokeUrl;
        return this;
    }

    /**
     * Connection settings. Values will persist to `form_fields` with corresponding id
     */
    public Connection withSettings(Map<String, Object> settings) {
        Utils.checkNotNull(settings, "settings");
        this.settings = JsonNullable.of(settings);
        return this;
    }

    /**
     * Connection settings. Values will persist to `form_fields` with corresponding id
     */
    public Connection withSettings(JsonNullable<? extends Map<String, Object>> settings) {
        Utils.checkNotNull(settings, "settings");
        this.settings = settings;
        return this;
    }

    /**
     * Attach your own consumer specific metadata
     */
    public Connection withMetadata(Map<String, Object> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = JsonNullable.of(metadata);
        return this;
    }

    /**
     * Attach your own consumer specific metadata
     */
    public Connection withMetadata(JsonNullable<? extends Map<String, Object>> metadata) {
        Utils.checkNotNull(metadata, "metadata");
        this.metadata = metadata;
        return this;
    }

    /**
     * The settings that are wanted to create a connection.
     */
    public Connection withFormFields(List<FormField> formFields) {
        Utils.checkNotNull(formFields, "formFields");
        this.formFields = Optional.ofNullable(formFields);
        return this;
    }

    /**
     * The settings that are wanted to create a connection.
     */
    public Connection withFormFields(Optional<? extends List<FormField>> formFields) {
        Utils.checkNotNull(formFields, "formFields");
        this.formFields = formFields;
        return this;
    }

    public Connection withConfiguration(List<Configuration> configuration) {
        Utils.checkNotNull(configuration, "configuration");
        this.configuration = Optional.ofNullable(configuration);
        return this;
    }

    public Connection withConfiguration(Optional<? extends List<Configuration>> configuration) {
        Utils.checkNotNull(configuration, "configuration");
        this.configuration = configuration;
        return this;
    }

    public Connection withConfigurableResources(List<String> configurableResources) {
        Utils.checkNotNull(configurableResources, "configurableResources");
        this.configurableResources = Optional.ofNullable(configurableResources);
        return this;
    }

    public Connection withConfigurableResources(Optional<? extends List<String>> configurableResources) {
        Utils.checkNotNull(configurableResources, "configurableResources");
        this.configurableResources = configurableResources;
        return this;
    }

    public Connection withResourceSchemaSupport(List<String> resourceSchemaSupport) {
        Utils.checkNotNull(resourceSchemaSupport, "resourceSchemaSupport");
        this.resourceSchemaSupport = Optional.ofNullable(resourceSchemaSupport);
        return this;
    }

    public Connection withResourceSchemaSupport(Optional<? extends List<String>> resourceSchemaSupport) {
        Utils.checkNotNull(resourceSchemaSupport, "resourceSchemaSupport");
        this.resourceSchemaSupport = resourceSchemaSupport;
        return this;
    }

    public Connection withResourceSettingsSupport(List<String> resourceSettingsSupport) {
        Utils.checkNotNull(resourceSettingsSupport, "resourceSettingsSupport");
        this.resourceSettingsSupport = Optional.ofNullable(resourceSettingsSupport);
        return this;
    }

    public Connection withResourceSettingsSupport(Optional<? extends List<String>> resourceSettingsSupport) {
        Utils.checkNotNull(resourceSettingsSupport, "resourceSettingsSupport");
        this.resourceSettingsSupport = resourceSettingsSupport;
        return this;
    }

    public Connection withValidationSupport(boolean validationSupport) {
        Utils.checkNotNull(validationSupport, "validationSupport");
        this.validationSupport = Optional.ofNullable(validationSupport);
        return this;
    }

    public Connection withValidationSupport(Optional<Boolean> validationSupport) {
        Utils.checkNotNull(validationSupport, "validationSupport");
        this.validationSupport = validationSupport;
        return this;
    }

    public Connection withSchemaSupport(boolean schemaSupport) {
        Utils.checkNotNull(schemaSupport, "schemaSupport");
        this.schemaSupport = Optional.ofNullable(schemaSupport);
        return this;
    }

    public Connection withSchemaSupport(Optional<Boolean> schemaSupport) {
        Utils.checkNotNull(schemaSupport, "schemaSupport");
        this.schemaSupport = schemaSupport;
        return this;
    }

    /**
     * List of settings that are required to be configured on integration before authorization can occur
     */
    public Connection withSettingsRequiredForAuthorization(List<String> settingsRequiredForAuthorization) {
        Utils.checkNotNull(settingsRequiredForAuthorization, "settingsRequiredForAuthorization");
        this.settingsRequiredForAuthorization = Optional.ofNullable(settingsRequiredForAuthorization);
        return this;
    }

    /**
     * List of settings that are required to be configured on integration before authorization can occur
     */
    public Connection withSettingsRequiredForAuthorization(Optional<? extends List<String>> settingsRequiredForAuthorization) {
        Utils.checkNotNull(settingsRequiredForAuthorization, "settingsRequiredForAuthorization");
        this.settingsRequiredForAuthorization = settingsRequiredForAuthorization;
        return this;
    }

    public Connection withSubscriptions(List<WebhookSubscription> subscriptions) {
        Utils.checkNotNull(subscriptions, "subscriptions");
        this.subscriptions = Optional.ofNullable(subscriptions);
        return this;
    }

    public Connection withSubscriptions(Optional<? extends List<WebhookSubscription>> subscriptions) {
        Utils.checkNotNull(subscriptions, "subscriptions");
        this.subscriptions = subscriptions;
        return this;
    }

    /**
     * Whether the connector has a guide available in the developer docs or not (https://docs.apideck.com/connectors/{service_id}/docs/consumer+connection).
     */
    public Connection withHasGuide(boolean hasGuide) {
        Utils.checkNotNull(hasGuide, "hasGuide");
        this.hasGuide = Optional.ofNullable(hasGuide);
        return this;
    }

    /**
     * Whether the connector has a guide available in the developer docs or not (https://docs.apideck.com/connectors/{service_id}/docs/consumer+connection).
     */
    public Connection withHasGuide(Optional<Boolean> hasGuide) {
        Utils.checkNotNull(hasGuide, "hasGuide");
        this.hasGuide = hasGuide;
        return this;
    }

    public Connection withCreatedAt(double createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = Optional.ofNullable(createdAt);
        return this;
    }

    public Connection withCreatedAt(Optional<Double> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * List of custom mappings configured for this connection
     */
    public Connection withCustomMappings(List<CustomMapping> customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = Optional.ofNullable(customMappings);
        return this;
    }

    /**
     * List of custom mappings configured for this connection
     */
    public Connection withCustomMappings(Optional<? extends List<CustomMapping>> customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = customMappings;
        return this;
    }

    public Connection withUpdatedAt(double updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = JsonNullable.of(updatedAt);
        return this;
    }

    public Connection withUpdatedAt(JsonNullable<Double> updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = updatedAt;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Connection other = (Connection) o;
        return 
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.serviceId, other.serviceId) &&
            Objects.deepEquals(this.name, other.name) &&
            Objects.deepEquals(this.tagLine, other.tagLine) &&
            Objects.deepEquals(this.unifiedApi, other.unifiedApi) &&
            Objects.deepEquals(this.state, other.state) &&
            Objects.deepEquals(this.integrationState, other.integrationState) &&
            Objects.deepEquals(this.authType, other.authType) &&
            Objects.deepEquals(this.oauthGrantType, other.oauthGrantType) &&
            Objects.deepEquals(this.status, other.status) &&
            Objects.deepEquals(this.enabled, other.enabled) &&
            Objects.deepEquals(this.website, other.website) &&
            Objects.deepEquals(this.icon, other.icon) &&
            Objects.deepEquals(this.logo, other.logo) &&
            Objects.deepEquals(this.authorizeUrl, other.authorizeUrl) &&
            Objects.deepEquals(this.revokeUrl, other.revokeUrl) &&
            Objects.deepEquals(this.settings, other.settings) &&
            Objects.deepEquals(this.metadata, other.metadata) &&
            Objects.deepEquals(this.formFields, other.formFields) &&
            Objects.deepEquals(this.configuration, other.configuration) &&
            Objects.deepEquals(this.configurableResources, other.configurableResources) &&
            Objects.deepEquals(this.resourceSchemaSupport, other.resourceSchemaSupport) &&
            Objects.deepEquals(this.resourceSettingsSupport, other.resourceSettingsSupport) &&
            Objects.deepEquals(this.validationSupport, other.validationSupport) &&
            Objects.deepEquals(this.schemaSupport, other.schemaSupport) &&
            Objects.deepEquals(this.settingsRequiredForAuthorization, other.settingsRequiredForAuthorization) &&
            Objects.deepEquals(this.subscriptions, other.subscriptions) &&
            Objects.deepEquals(this.hasGuide, other.hasGuide) &&
            Objects.deepEquals(this.createdAt, other.createdAt) &&
            Objects.deepEquals(this.customMappings, other.customMappings) &&
            Objects.deepEquals(this.updatedAt, other.updatedAt);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            id,
            serviceId,
            name,
            tagLine,
            unifiedApi,
            state,
            integrationState,
            authType,
            oauthGrantType,
            status,
            enabled,
            website,
            icon,
            logo,
            authorizeUrl,
            revokeUrl,
            settings,
            metadata,
            formFields,
            configuration,
            configurableResources,
            resourceSchemaSupport,
            resourceSettingsSupport,
            validationSupport,
            schemaSupport,
            settingsRequiredForAuthorization,
            subscriptions,
            hasGuide,
            createdAt,
            customMappings,
            updatedAt);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Connection.class,
                "id", id,
                "serviceId", serviceId,
                "name", name,
                "tagLine", tagLine,
                "unifiedApi", unifiedApi,
                "state", state,
                "integrationState", integrationState,
                "authType", authType,
                "oauthGrantType", oauthGrantType,
                "status", status,
                "enabled", enabled,
                "website", website,
                "icon", icon,
                "logo", logo,
                "authorizeUrl", authorizeUrl,
                "revokeUrl", revokeUrl,
                "settings", settings,
                "metadata", metadata,
                "formFields", formFields,
                "configuration", configuration,
                "configurableResources", configurableResources,
                "resourceSchemaSupport", resourceSchemaSupport,
                "resourceSettingsSupport", resourceSettingsSupport,
                "validationSupport", validationSupport,
                "schemaSupport", schemaSupport,
                "settingsRequiredForAuthorization", settingsRequiredForAuthorization,
                "subscriptions", subscriptions,
                "hasGuide", hasGuide,
                "createdAt", createdAt,
                "customMappings", customMappings,
                "updatedAt", updatedAt);
    }
    
    public final static class Builder {
 
        private Optional<String> id = Optional.empty();
 
        private Optional<String> serviceId = Optional.empty();
 
        private Optional<String> name = Optional.empty();
 
        private Optional<String> tagLine = Optional.empty();
 
        private Optional<String> unifiedApi = Optional.empty();
 
        private Optional<? extends ConnectionState> state = Optional.empty();
 
        private Optional<? extends IntegrationState> integrationState = Optional.empty();
 
        private Optional<? extends AuthType> authType = Optional.empty();
 
        private Optional<? extends OAuthGrantType> oauthGrantType = Optional.empty();
 
        private Optional<? extends ConnectionStatus> status = Optional.empty();
 
        private Optional<Boolean> enabled = Optional.empty();
 
        private Optional<String> website = Optional.empty();
 
        private Optional<String> icon = Optional.empty();
 
        private Optional<String> logo = Optional.empty();
 
        private JsonNullable<String> authorizeUrl = JsonNullable.undefined();
 
        private JsonNullable<String> revokeUrl = JsonNullable.undefined();
 
        private JsonNullable<? extends Map<String, Object>> settings = JsonNullable.undefined();
 
        private JsonNullable<? extends Map<String, Object>> metadata = JsonNullable.undefined();
 
        private Optional<? extends List<FormField>> formFields = Optional.empty();
 
        private Optional<? extends List<Configuration>> configuration = Optional.empty();
 
        private Optional<? extends List<String>> configurableResources = Optional.empty();
 
        private Optional<? extends List<String>> resourceSchemaSupport = Optional.empty();
 
        private Optional<? extends List<String>> resourceSettingsSupport = Optional.empty();
 
        private Optional<Boolean> validationSupport = Optional.empty();
 
        private Optional<Boolean> schemaSupport = Optional.empty();
 
        private Optional<? extends List<String>> settingsRequiredForAuthorization = Optional.empty();
 
        private Optional<? extends List<WebhookSubscription>> subscriptions = Optional.empty();
 
        private Optional<Boolean> hasGuide = Optional.empty();
 
        private Optional<Double> createdAt = Optional.empty();
 
        private Optional<? extends List<CustomMapping>> customMappings = Optional.empty();
 
        private JsonNullable<Double> updatedAt = JsonNullable.undefined();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * The unique identifier of the connection.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * The unique identifier of the connection.
         */
        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * The ID of the service this connection belongs to.
         */
        public Builder serviceId(String serviceId) {
            Utils.checkNotNull(serviceId, "serviceId");
            this.serviceId = Optional.ofNullable(serviceId);
            return this;
        }

        /**
         * The ID of the service this connection belongs to.
         */
        public Builder serviceId(Optional<String> serviceId) {
            Utils.checkNotNull(serviceId, "serviceId");
            this.serviceId = serviceId;
            return this;
        }

        /**
         * The name of the connection
         */
        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = Optional.ofNullable(name);
            return this;
        }

        /**
         * The name of the connection
         */
        public Builder name(Optional<String> name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        public Builder tagLine(String tagLine) {
            Utils.checkNotNull(tagLine, "tagLine");
            this.tagLine = Optional.ofNullable(tagLine);
            return this;
        }

        public Builder tagLine(Optional<String> tagLine) {
            Utils.checkNotNull(tagLine, "tagLine");
            this.tagLine = tagLine;
            return this;
        }

        /**
         * The unified API category where the connection belongs to.
         */
        public Builder unifiedApi(String unifiedApi) {
            Utils.checkNotNull(unifiedApi, "unifiedApi");
            this.unifiedApi = Optional.ofNullable(unifiedApi);
            return this;
        }

        /**
         * The unified API category where the connection belongs to.
         */
        public Builder unifiedApi(Optional<String> unifiedApi) {
            Utils.checkNotNull(unifiedApi, "unifiedApi");
            this.unifiedApi = unifiedApi;
            return this;
        }

        /**
         * [Connection state flow](#section/Connection-state)
         */
        public Builder state(ConnectionState state) {
            Utils.checkNotNull(state, "state");
            this.state = Optional.ofNullable(state);
            return this;
        }

        /**
         * [Connection state flow](#section/Connection-state)
         */
        public Builder state(Optional<? extends ConnectionState> state) {
            Utils.checkNotNull(state, "state");
            this.state = state;
            return this;
        }

        /**
         * The current state of the Integration.
         */
        public Builder integrationState(IntegrationState integrationState) {
            Utils.checkNotNull(integrationState, "integrationState");
            this.integrationState = Optional.ofNullable(integrationState);
            return this;
        }

        /**
         * The current state of the Integration.
         */
        public Builder integrationState(Optional<? extends IntegrationState> integrationState) {
            Utils.checkNotNull(integrationState, "integrationState");
            this.integrationState = integrationState;
            return this;
        }

        /**
         * Type of authorization used by the connector
         */
        public Builder authType(AuthType authType) {
            Utils.checkNotNull(authType, "authType");
            this.authType = Optional.ofNullable(authType);
            return this;
        }

        /**
         * Type of authorization used by the connector
         */
        public Builder authType(Optional<? extends AuthType> authType) {
            Utils.checkNotNull(authType, "authType");
            this.authType = authType;
            return this;
        }

        /**
         * OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types
         */
        public Builder oauthGrantType(OAuthGrantType oauthGrantType) {
            Utils.checkNotNull(oauthGrantType, "oauthGrantType");
            this.oauthGrantType = Optional.ofNullable(oauthGrantType);
            return this;
        }

        /**
         * OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types
         */
        public Builder oauthGrantType(Optional<? extends OAuthGrantType> oauthGrantType) {
            Utils.checkNotNull(oauthGrantType, "oauthGrantType");
            this.oauthGrantType = oauthGrantType;
            return this;
        }

        /**
         * Status of the connection.
         */
        public Builder status(ConnectionStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * Status of the connection.
         */
        public Builder status(Optional<? extends ConnectionStatus> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * Whether the connection is enabled or not. You can enable or disable a connection using the Update Connection API.
         */
        public Builder enabled(boolean enabled) {
            Utils.checkNotNull(enabled, "enabled");
            this.enabled = Optional.ofNullable(enabled);
            return this;
        }

        /**
         * Whether the connection is enabled or not. You can enable or disable a connection using the Update Connection API.
         */
        public Builder enabled(Optional<Boolean> enabled) {
            Utils.checkNotNull(enabled, "enabled");
            this.enabled = enabled;
            return this;
        }

        /**
         * The website URL of the connection
         */
        public Builder website(String website) {
            Utils.checkNotNull(website, "website");
            this.website = Optional.ofNullable(website);
            return this;
        }

        /**
         * The website URL of the connection
         */
        public Builder website(Optional<String> website) {
            Utils.checkNotNull(website, "website");
            this.website = website;
            return this;
        }

        /**
         * A visual icon of the connection, that will be shown in the Vault
         */
        public Builder icon(String icon) {
            Utils.checkNotNull(icon, "icon");
            this.icon = Optional.ofNullable(icon);
            return this;
        }

        /**
         * A visual icon of the connection, that will be shown in the Vault
         */
        public Builder icon(Optional<String> icon) {
            Utils.checkNotNull(icon, "icon");
            this.icon = icon;
            return this;
        }

        /**
         * The logo of the connection, that will be shown in the Vault
         */
        public Builder logo(String logo) {
            Utils.checkNotNull(logo, "logo");
            this.logo = Optional.ofNullable(logo);
            return this;
        }

        /**
         * The logo of the connection, that will be shown in the Vault
         */
        public Builder logo(Optional<String> logo) {
            Utils.checkNotNull(logo, "logo");
            this.logo = logo;
            return this;
        }

        /**
         * The OAuth redirect URI. Redirect your users to this URI to let them authorize your app in the connector's UI. Before you can use this URI, you must add `redirect_uri` as a query parameter to the `authorize_url`. Be sure to URL encode the `redirect_uri` part. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
         */
        public Builder authorizeUrl(String authorizeUrl) {
            Utils.checkNotNull(authorizeUrl, "authorizeUrl");
            this.authorizeUrl = JsonNullable.of(authorizeUrl);
            return this;
        }

        /**
         * The OAuth redirect URI. Redirect your users to this URI to let them authorize your app in the connector's UI. Before you can use this URI, you must add `redirect_uri` as a query parameter to the `authorize_url`. Be sure to URL encode the `redirect_uri` part. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
         */
        public Builder authorizeUrl(JsonNullable<String> authorizeUrl) {
            Utils.checkNotNull(authorizeUrl, "authorizeUrl");
            this.authorizeUrl = authorizeUrl;
            return this;
        }

        /**
         * The OAuth revoke URI. Redirect your users to this URI to revoke this connection. Before you can use this URI, you must add `redirect_uri` as a query parameter. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
         */
        public Builder revokeUrl(String revokeUrl) {
            Utils.checkNotNull(revokeUrl, "revokeUrl");
            this.revokeUrl = JsonNullable.of(revokeUrl);
            return this;
        }

        /**
         * The OAuth revoke URI. Redirect your users to this URI to revoke this connection. Before you can use this URI, you must add `redirect_uri` as a query parameter. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
         */
        public Builder revokeUrl(JsonNullable<String> revokeUrl) {
            Utils.checkNotNull(revokeUrl, "revokeUrl");
            this.revokeUrl = revokeUrl;
            return this;
        }

        /**
         * Connection settings. Values will persist to `form_fields` with corresponding id
         */
        public Builder settings(Map<String, Object> settings) {
            Utils.checkNotNull(settings, "settings");
            this.settings = JsonNullable.of(settings);
            return this;
        }

        /**
         * Connection settings. Values will persist to `form_fields` with corresponding id
         */
        public Builder settings(JsonNullable<? extends Map<String, Object>> settings) {
            Utils.checkNotNull(settings, "settings");
            this.settings = settings;
            return this;
        }

        /**
         * Attach your own consumer specific metadata
         */
        public Builder metadata(Map<String, Object> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = JsonNullable.of(metadata);
            return this;
        }

        /**
         * Attach your own consumer specific metadata
         */
        public Builder metadata(JsonNullable<? extends Map<String, Object>> metadata) {
            Utils.checkNotNull(metadata, "metadata");
            this.metadata = metadata;
            return this;
        }

        /**
         * The settings that are wanted to create a connection.
         */
        public Builder formFields(List<FormField> formFields) {
            Utils.checkNotNull(formFields, "formFields");
            this.formFields = Optional.ofNullable(formFields);
            return this;
        }

        /**
         * The settings that are wanted to create a connection.
         */
        public Builder formFields(Optional<? extends List<FormField>> formFields) {
            Utils.checkNotNull(formFields, "formFields");
            this.formFields = formFields;
            return this;
        }

        public Builder configuration(List<Configuration> configuration) {
            Utils.checkNotNull(configuration, "configuration");
            this.configuration = Optional.ofNullable(configuration);
            return this;
        }

        public Builder configuration(Optional<? extends List<Configuration>> configuration) {
            Utils.checkNotNull(configuration, "configuration");
            this.configuration = configuration;
            return this;
        }

        public Builder configurableResources(List<String> configurableResources) {
            Utils.checkNotNull(configurableResources, "configurableResources");
            this.configurableResources = Optional.ofNullable(configurableResources);
            return this;
        }

        public Builder configurableResources(Optional<? extends List<String>> configurableResources) {
            Utils.checkNotNull(configurableResources, "configurableResources");
            this.configurableResources = configurableResources;
            return this;
        }

        public Builder resourceSchemaSupport(List<String> resourceSchemaSupport) {
            Utils.checkNotNull(resourceSchemaSupport, "resourceSchemaSupport");
            this.resourceSchemaSupport = Optional.ofNullable(resourceSchemaSupport);
            return this;
        }

        public Builder resourceSchemaSupport(Optional<? extends List<String>> resourceSchemaSupport) {
            Utils.checkNotNull(resourceSchemaSupport, "resourceSchemaSupport");
            this.resourceSchemaSupport = resourceSchemaSupport;
            return this;
        }

        public Builder resourceSettingsSupport(List<String> resourceSettingsSupport) {
            Utils.checkNotNull(resourceSettingsSupport, "resourceSettingsSupport");
            this.resourceSettingsSupport = Optional.ofNullable(resourceSettingsSupport);
            return this;
        }

        public Builder resourceSettingsSupport(Optional<? extends List<String>> resourceSettingsSupport) {
            Utils.checkNotNull(resourceSettingsSupport, "resourceSettingsSupport");
            this.resourceSettingsSupport = resourceSettingsSupport;
            return this;
        }

        public Builder validationSupport(boolean validationSupport) {
            Utils.checkNotNull(validationSupport, "validationSupport");
            this.validationSupport = Optional.ofNullable(validationSupport);
            return this;
        }

        public Builder validationSupport(Optional<Boolean> validationSupport) {
            Utils.checkNotNull(validationSupport, "validationSupport");
            this.validationSupport = validationSupport;
            return this;
        }

        public Builder schemaSupport(boolean schemaSupport) {
            Utils.checkNotNull(schemaSupport, "schemaSupport");
            this.schemaSupport = Optional.ofNullable(schemaSupport);
            return this;
        }

        public Builder schemaSupport(Optional<Boolean> schemaSupport) {
            Utils.checkNotNull(schemaSupport, "schemaSupport");
            this.schemaSupport = schemaSupport;
            return this;
        }

        /**
         * List of settings that are required to be configured on integration before authorization can occur
         */
        public Builder settingsRequiredForAuthorization(List<String> settingsRequiredForAuthorization) {
            Utils.checkNotNull(settingsRequiredForAuthorization, "settingsRequiredForAuthorization");
            this.settingsRequiredForAuthorization = Optional.ofNullable(settingsRequiredForAuthorization);
            return this;
        }

        /**
         * List of settings that are required to be configured on integration before authorization can occur
         */
        public Builder settingsRequiredForAuthorization(Optional<? extends List<String>> settingsRequiredForAuthorization) {
            Utils.checkNotNull(settingsRequiredForAuthorization, "settingsRequiredForAuthorization");
            this.settingsRequiredForAuthorization = settingsRequiredForAuthorization;
            return this;
        }

        public Builder subscriptions(List<WebhookSubscription> subscriptions) {
            Utils.checkNotNull(subscriptions, "subscriptions");
            this.subscriptions = Optional.ofNullable(subscriptions);
            return this;
        }

        public Builder subscriptions(Optional<? extends List<WebhookSubscription>> subscriptions) {
            Utils.checkNotNull(subscriptions, "subscriptions");
            this.subscriptions = subscriptions;
            return this;
        }

        /**
         * Whether the connector has a guide available in the developer docs or not (https://docs.apideck.com/connectors/{service_id}/docs/consumer+connection).
         */
        public Builder hasGuide(boolean hasGuide) {
            Utils.checkNotNull(hasGuide, "hasGuide");
            this.hasGuide = Optional.ofNullable(hasGuide);
            return this;
        }

        /**
         * Whether the connector has a guide available in the developer docs or not (https://docs.apideck.com/connectors/{service_id}/docs/consumer+connection).
         */
        public Builder hasGuide(Optional<Boolean> hasGuide) {
            Utils.checkNotNull(hasGuide, "hasGuide");
            this.hasGuide = hasGuide;
            return this;
        }

        public Builder createdAt(double createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        public Builder createdAt(Optional<Double> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * List of custom mappings configured for this connection
         */
        public Builder customMappings(List<CustomMapping> customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = Optional.ofNullable(customMappings);
            return this;
        }

        /**
         * List of custom mappings configured for this connection
         */
        public Builder customMappings(Optional<? extends List<CustomMapping>> customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = customMappings;
            return this;
        }

        public Builder updatedAt(double updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = JsonNullable.of(updatedAt);
            return this;
        }

        public Builder updatedAt(JsonNullable<Double> updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = updatedAt;
            return this;
        }
        
        public Connection build() {
            return new Connection(
                id,
                serviceId,
                name,
                tagLine,
                unifiedApi,
                state,
                integrationState,
                authType,
                oauthGrantType,
                status,
                enabled,
                website,
                icon,
                logo,
                authorizeUrl,
                revokeUrl,
                settings,
                metadata,
                formFields,
                configuration,
                configurableResources,
                resourceSchemaSupport,
                resourceSettingsSupport,
                validationSupport,
                schemaSupport,
                settingsRequiredForAuthorization,
                subscriptions,
                hasGuide,
                createdAt,
                customMappings,
                updatedAt);
        }
    }
}

