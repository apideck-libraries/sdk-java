/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.apideck.unify.models.components;

import com.apideck.unify.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.annotation.Nullable;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class Connector {
    /**
     * ID of the connector.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private String id;

    /**
     * Name of the connector.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("name")
    private String name;

    /**
     * Status of the connector. Connectors with status live or beta are callable.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private ConnectorStatus status;

    /**
     * A description of the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private JsonNullable<String> description;

    /**
     * Link to a small square icon for the connector.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("icon_url")
    private String iconUrl;

    /**
     * Link to the full logo for the connector.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("logo_url")
    private String logoUrl;

    /**
     * Link to the connector's website.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("website_url")
    private String websiteUrl;

    /**
     * Link to the connector's signup page.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("signup_url")
    private String signupUrl;

    /**
     * Link to the connector's partner program signup page.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("partner_signup_url")
    private String partnerSignupUrl;

    /**
     * Set to `true` when the connector offers a free trial. Use `signup_url` to sign up for a free trial
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("free_trial_available")
    private Boolean freeTrialAvailable;

    /**
     * Type of authorization used by the connector
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("auth_type")
    private ConnectorAuthType authType;

    /**
     * Indicates whether a connector only supports authentication. In this case the connector is not mapped to a Unified API, but can be used with the Proxy API
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("auth_only")
    private Boolean authOnly;

    /**
     * Set to `true` when connector was implemented from downstream docs only and without API access. This state indicates that integration will require Apideck support, and access to downstream API to validate mapping quality.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("blind_mapped")
    private Boolean blindMapped;

    /**
     * OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("oauth_grant_type")
    private ConnectorOauthGrantType oauthGrantType;

    /**
     * Location of the OAuth client credentials. For most connectors the OAuth client credentials are stored on integration and managed by the application owner. For others they are stored on connection and managed by the consumer in Vault.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("oauth_credentials_source")
    private OauthCredentialsSource oauthCredentialsSource;

    /**
     * List of OAuth Scopes available for this connector.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("oauth_scopes")
    private List<OauthScopes> oauthScopes;

    /**
     * Set to `true` when connector allows the definition of custom scopes.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_scopes")
    private Boolean customScopes;

    /**
     * Indicates whether Apideck Sandbox OAuth credentials are available.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("has_sandbox_credentials")
    private Boolean hasSandboxCredentials;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("settings")
    private List<ConnectorSetting> settings;

    /**
     * Service provider identifier
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("service_id")
    private String serviceId;

    /**
     * List of Unified APIs that feature this connector.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("unified_apis")
    private List<UnifiedApis> unifiedApis;

    /**
     * List of resources that are supported on the connector.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supported_resources")
    private List<LinkedConnectorResource> supportedResources;

    /**
     * List of resources that have settings that can be configured.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("configurable_resources")
    private List<String> configurableResources;

    /**
     * List of events that are supported on the connector across all Unified APIs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supported_events")
    private List<ConnectorEvent> supportedEvents;

    /**
     * How webhooks are supported for the connector. Sometimes the connector natively supports webhooks, other times Apideck virtualizes them based on polling.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhook_support")
    private WebhookSupport webhookSupport;

    /**
     * When a connector has schema_support, a call can be made to retrieve a json schema that describes a downstream resource.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("schema_support")
    private SchemaSupport schemaSupport;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("docs")
    private List<ConnectorDoc> docs;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tls_support")
    private TlsSupport tlsSupport;

    @JsonCreator
    public Connector(
            @JsonProperty("id") @Nullable String id,
            @JsonProperty("name") @Nullable String name,
            @JsonProperty("status") @Nullable ConnectorStatus status,
            @JsonProperty("description") @Nullable JsonNullable<String> description,
            @JsonProperty("icon_url") @Nullable String iconUrl,
            @JsonProperty("logo_url") @Nullable String logoUrl,
            @JsonProperty("website_url") @Nullable String websiteUrl,
            @JsonProperty("signup_url") @Nullable String signupUrl,
            @JsonProperty("partner_signup_url") @Nullable String partnerSignupUrl,
            @JsonProperty("free_trial_available") @Nullable Boolean freeTrialAvailable,
            @JsonProperty("auth_type") @Nullable ConnectorAuthType authType,
            @JsonProperty("auth_only") @Nullable Boolean authOnly,
            @JsonProperty("blind_mapped") @Nullable Boolean blindMapped,
            @JsonProperty("oauth_grant_type") @Nullable ConnectorOauthGrantType oauthGrantType,
            @JsonProperty("oauth_credentials_source") @Nullable OauthCredentialsSource oauthCredentialsSource,
            @JsonProperty("oauth_scopes") @Nullable List<OauthScopes> oauthScopes,
            @JsonProperty("custom_scopes") @Nullable Boolean customScopes,
            @JsonProperty("has_sandbox_credentials") @Nullable Boolean hasSandboxCredentials,
            @JsonProperty("settings") @Nullable List<ConnectorSetting> settings,
            @JsonProperty("service_id") @Nullable String serviceId,
            @JsonProperty("unified_apis") @Nullable List<UnifiedApis> unifiedApis,
            @JsonProperty("supported_resources") @Nullable List<LinkedConnectorResource> supportedResources,
            @JsonProperty("configurable_resources") @Nullable List<String> configurableResources,
            @JsonProperty("supported_events") @Nullable List<ConnectorEvent> supportedEvents,
            @JsonProperty("webhook_support") @Nullable WebhookSupport webhookSupport,
            @JsonProperty("schema_support") @Nullable SchemaSupport schemaSupport,
            @JsonProperty("docs") @Nullable List<ConnectorDoc> docs,
            @JsonProperty("tls_support") @Nullable TlsSupport tlsSupport) {
        this.id = id;
        this.name = name;
        this.status = status;
        this.description = Optional.ofNullable(description)
            .orElse(JsonNullable.undefined());
        this.iconUrl = iconUrl;
        this.logoUrl = logoUrl;
        this.websiteUrl = websiteUrl;
        this.signupUrl = signupUrl;
        this.partnerSignupUrl = partnerSignupUrl;
        this.freeTrialAvailable = freeTrialAvailable;
        this.authType = authType;
        this.authOnly = authOnly;
        this.blindMapped = blindMapped;
        this.oauthGrantType = oauthGrantType;
        this.oauthCredentialsSource = oauthCredentialsSource;
        this.oauthScopes = oauthScopes;
        this.customScopes = customScopes;
        this.hasSandboxCredentials = hasSandboxCredentials;
        this.settings = settings;
        this.serviceId = serviceId;
        this.unifiedApis = unifiedApis;
        this.supportedResources = supportedResources;
        this.configurableResources = configurableResources;
        this.supportedEvents = supportedEvents;
        this.webhookSupport = webhookSupport;
        this.schemaSupport = schemaSupport;
        this.docs = docs;
        this.tlsSupport = tlsSupport;
    }
    
    public Connector() {
        this(null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null);
    }

    /**
     * ID of the connector.
     */
    public Optional<String> id() {
        return Optional.ofNullable(this.id);
    }

    /**
     * Name of the connector.
     */
    public Optional<String> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Status of the connector. Connectors with status live or beta are callable.
     */
    public Optional<ConnectorStatus> status() {
        return Optional.ofNullable(this.status);
    }

    /**
     * A description of the object.
     */
    public JsonNullable<String> description() {
        return this.description;
    }

    /**
     * Link to a small square icon for the connector.
     */
    public Optional<String> iconUrl() {
        return Optional.ofNullable(this.iconUrl);
    }

    /**
     * Link to the full logo for the connector.
     */
    public Optional<String> logoUrl() {
        return Optional.ofNullable(this.logoUrl);
    }

    /**
     * Link to the connector's website.
     */
    public Optional<String> websiteUrl() {
        return Optional.ofNullable(this.websiteUrl);
    }

    /**
     * Link to the connector's signup page.
     */
    public Optional<String> signupUrl() {
        return Optional.ofNullable(this.signupUrl);
    }

    /**
     * Link to the connector's partner program signup page.
     */
    public Optional<String> partnerSignupUrl() {
        return Optional.ofNullable(this.partnerSignupUrl);
    }

    /**
     * Set to `true` when the connector offers a free trial. Use `signup_url` to sign up for a free trial
     */
    public Optional<Boolean> freeTrialAvailable() {
        return Optional.ofNullable(this.freeTrialAvailable);
    }

    /**
     * Type of authorization used by the connector
     */
    public Optional<ConnectorAuthType> authType() {
        return Optional.ofNullable(this.authType);
    }

    /**
     * Indicates whether a connector only supports authentication. In this case the connector is not mapped to a Unified API, but can be used with the Proxy API
     */
    public Optional<Boolean> authOnly() {
        return Optional.ofNullable(this.authOnly);
    }

    /**
     * Set to `true` when connector was implemented from downstream docs only and without API access. This state indicates that integration will require Apideck support, and access to downstream API to validate mapping quality.
     */
    public Optional<Boolean> blindMapped() {
        return Optional.ofNullable(this.blindMapped);
    }

    /**
     * OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types
     */
    public Optional<ConnectorOauthGrantType> oauthGrantType() {
        return Optional.ofNullable(this.oauthGrantType);
    }

    /**
     * Location of the OAuth client credentials. For most connectors the OAuth client credentials are stored on integration and managed by the application owner. For others they are stored on connection and managed by the consumer in Vault.
     */
    public Optional<OauthCredentialsSource> oauthCredentialsSource() {
        return Optional.ofNullable(this.oauthCredentialsSource);
    }

    /**
     * List of OAuth Scopes available for this connector.
     */
    public Optional<List<OauthScopes>> oauthScopes() {
        return Optional.ofNullable(this.oauthScopes);
    }

    /**
     * Set to `true` when connector allows the definition of custom scopes.
     */
    public Optional<Boolean> customScopes() {
        return Optional.ofNullable(this.customScopes);
    }

    /**
     * Indicates whether Apideck Sandbox OAuth credentials are available.
     */
    public Optional<Boolean> hasSandboxCredentials() {
        return Optional.ofNullable(this.hasSandboxCredentials);
    }

    public Optional<List<ConnectorSetting>> settings() {
        return Optional.ofNullable(this.settings);
    }

    /**
     * Service provider identifier
     */
    public Optional<String> serviceId() {
        return Optional.ofNullable(this.serviceId);
    }

    /**
     * List of Unified APIs that feature this connector.
     */
    public Optional<List<UnifiedApis>> unifiedApis() {
        return Optional.ofNullable(this.unifiedApis);
    }

    /**
     * List of resources that are supported on the connector.
     */
    public Optional<List<LinkedConnectorResource>> supportedResources() {
        return Optional.ofNullable(this.supportedResources);
    }

    /**
     * List of resources that have settings that can be configured.
     */
    public Optional<List<String>> configurableResources() {
        return Optional.ofNullable(this.configurableResources);
    }

    /**
     * List of events that are supported on the connector across all Unified APIs.
     */
    public Optional<List<ConnectorEvent>> supportedEvents() {
        return Optional.ofNullable(this.supportedEvents);
    }

    /**
     * How webhooks are supported for the connector. Sometimes the connector natively supports webhooks, other times Apideck virtualizes them based on polling.
     */
    public Optional<WebhookSupport> webhookSupport() {
        return Optional.ofNullable(this.webhookSupport);
    }

    /**
     * When a connector has schema_support, a call can be made to retrieve a json schema that describes a downstream resource.
     */
    public Optional<SchemaSupport> schemaSupport() {
        return Optional.ofNullable(this.schemaSupport);
    }

    public Optional<List<ConnectorDoc>> docs() {
        return Optional.ofNullable(this.docs);
    }

    public Optional<TlsSupport> tlsSupport() {
        return Optional.ofNullable(this.tlsSupport);
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * ID of the connector.
     */
    public Connector withId(@Nullable String id) {
        this.id = id;
        return this;
    }


    /**
     * Name of the connector.
     */
    public Connector withName(@Nullable String name) {
        this.name = name;
        return this;
    }


    /**
     * Status of the connector. Connectors with status live or beta are callable.
     */
    public Connector withStatus(@Nullable ConnectorStatus status) {
        this.status = status;
        return this;
    }


    /**
     * A description of the object.
     */
    public Connector withDescription(@Nullable String description) {
        this.description = JsonNullable.of(description);
        return this;
    }


    /**
     * Link to a small square icon for the connector.
     */
    public Connector withIconUrl(@Nullable String iconUrl) {
        this.iconUrl = iconUrl;
        return this;
    }


    /**
     * Link to the full logo for the connector.
     */
    public Connector withLogoUrl(@Nullable String logoUrl) {
        this.logoUrl = logoUrl;
        return this;
    }


    /**
     * Link to the connector's website.
     */
    public Connector withWebsiteUrl(@Nullable String websiteUrl) {
        this.websiteUrl = websiteUrl;
        return this;
    }


    /**
     * Link to the connector's signup page.
     */
    public Connector withSignupUrl(@Nullable String signupUrl) {
        this.signupUrl = signupUrl;
        return this;
    }


    /**
     * Link to the connector's partner program signup page.
     */
    public Connector withPartnerSignupUrl(@Nullable String partnerSignupUrl) {
        this.partnerSignupUrl = partnerSignupUrl;
        return this;
    }


    /**
     * Set to `true` when the connector offers a free trial. Use `signup_url` to sign up for a free trial
     */
    public Connector withFreeTrialAvailable(@Nullable Boolean freeTrialAvailable) {
        this.freeTrialAvailable = freeTrialAvailable;
        return this;
    }


    /**
     * Type of authorization used by the connector
     */
    public Connector withAuthType(@Nullable ConnectorAuthType authType) {
        this.authType = authType;
        return this;
    }


    /**
     * Indicates whether a connector only supports authentication. In this case the connector is not mapped to a Unified API, but can be used with the Proxy API
     */
    public Connector withAuthOnly(@Nullable Boolean authOnly) {
        this.authOnly = authOnly;
        return this;
    }


    /**
     * Set to `true` when connector was implemented from downstream docs only and without API access. This state indicates that integration will require Apideck support, and access to downstream API to validate mapping quality.
     */
    public Connector withBlindMapped(@Nullable Boolean blindMapped) {
        this.blindMapped = blindMapped;
        return this;
    }


    /**
     * OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types
     */
    public Connector withOauthGrantType(@Nullable ConnectorOauthGrantType oauthGrantType) {
        this.oauthGrantType = oauthGrantType;
        return this;
    }


    /**
     * Location of the OAuth client credentials. For most connectors the OAuth client credentials are stored on integration and managed by the application owner. For others they are stored on connection and managed by the consumer in Vault.
     */
    public Connector withOauthCredentialsSource(@Nullable OauthCredentialsSource oauthCredentialsSource) {
        this.oauthCredentialsSource = oauthCredentialsSource;
        return this;
    }


    /**
     * List of OAuth Scopes available for this connector.
     */
    public Connector withOauthScopes(@Nullable List<OauthScopes> oauthScopes) {
        this.oauthScopes = oauthScopes;
        return this;
    }


    /**
     * Set to `true` when connector allows the definition of custom scopes.
     */
    public Connector withCustomScopes(@Nullable Boolean customScopes) {
        this.customScopes = customScopes;
        return this;
    }


    /**
     * Indicates whether Apideck Sandbox OAuth credentials are available.
     */
    public Connector withHasSandboxCredentials(@Nullable Boolean hasSandboxCredentials) {
        this.hasSandboxCredentials = hasSandboxCredentials;
        return this;
    }


    public Connector withSettings(@Nullable List<ConnectorSetting> settings) {
        this.settings = settings;
        return this;
    }


    /**
     * Service provider identifier
     */
    public Connector withServiceId(@Nullable String serviceId) {
        this.serviceId = serviceId;
        return this;
    }


    /**
     * List of Unified APIs that feature this connector.
     */
    public Connector withUnifiedApis(@Nullable List<UnifiedApis> unifiedApis) {
        this.unifiedApis = unifiedApis;
        return this;
    }


    /**
     * List of resources that are supported on the connector.
     */
    public Connector withSupportedResources(@Nullable List<LinkedConnectorResource> supportedResources) {
        this.supportedResources = supportedResources;
        return this;
    }


    /**
     * List of resources that have settings that can be configured.
     */
    public Connector withConfigurableResources(@Nullable List<String> configurableResources) {
        this.configurableResources = configurableResources;
        return this;
    }


    /**
     * List of events that are supported on the connector across all Unified APIs.
     */
    public Connector withSupportedEvents(@Nullable List<ConnectorEvent> supportedEvents) {
        this.supportedEvents = supportedEvents;
        return this;
    }


    /**
     * How webhooks are supported for the connector. Sometimes the connector natively supports webhooks, other times Apideck virtualizes them based on polling.
     */
    public Connector withWebhookSupport(@Nullable WebhookSupport webhookSupport) {
        this.webhookSupport = webhookSupport;
        return this;
    }


    /**
     * When a connector has schema_support, a call can be made to retrieve a json schema that describes a downstream resource.
     */
    public Connector withSchemaSupport(@Nullable SchemaSupport schemaSupport) {
        this.schemaSupport = schemaSupport;
        return this;
    }


    public Connector withDocs(@Nullable List<ConnectorDoc> docs) {
        this.docs = docs;
        return this;
    }


    public Connector withTlsSupport(@Nullable TlsSupport tlsSupport) {
        this.tlsSupport = tlsSupport;
        return this;
    }


    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Connector other = (Connector) o;
        return 
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.name, other.name) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.description, other.description) &&
            Utils.enhancedDeepEquals(this.iconUrl, other.iconUrl) &&
            Utils.enhancedDeepEquals(this.logoUrl, other.logoUrl) &&
            Utils.enhancedDeepEquals(this.websiteUrl, other.websiteUrl) &&
            Utils.enhancedDeepEquals(this.signupUrl, other.signupUrl) &&
            Utils.enhancedDeepEquals(this.partnerSignupUrl, other.partnerSignupUrl) &&
            Utils.enhancedDeepEquals(this.freeTrialAvailable, other.freeTrialAvailable) &&
            Utils.enhancedDeepEquals(this.authType, other.authType) &&
            Utils.enhancedDeepEquals(this.authOnly, other.authOnly) &&
            Utils.enhancedDeepEquals(this.blindMapped, other.blindMapped) &&
            Utils.enhancedDeepEquals(this.oauthGrantType, other.oauthGrantType) &&
            Utils.enhancedDeepEquals(this.oauthCredentialsSource, other.oauthCredentialsSource) &&
            Utils.enhancedDeepEquals(this.oauthScopes, other.oauthScopes) &&
            Utils.enhancedDeepEquals(this.customScopes, other.customScopes) &&
            Utils.enhancedDeepEquals(this.hasSandboxCredentials, other.hasSandboxCredentials) &&
            Utils.enhancedDeepEquals(this.settings, other.settings) &&
            Utils.enhancedDeepEquals(this.serviceId, other.serviceId) &&
            Utils.enhancedDeepEquals(this.unifiedApis, other.unifiedApis) &&
            Utils.enhancedDeepEquals(this.supportedResources, other.supportedResources) &&
            Utils.enhancedDeepEquals(this.configurableResources, other.configurableResources) &&
            Utils.enhancedDeepEquals(this.supportedEvents, other.supportedEvents) &&
            Utils.enhancedDeepEquals(this.webhookSupport, other.webhookSupport) &&
            Utils.enhancedDeepEquals(this.schemaSupport, other.schemaSupport) &&
            Utils.enhancedDeepEquals(this.docs, other.docs) &&
            Utils.enhancedDeepEquals(this.tlsSupport, other.tlsSupport);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            id, name, status,
            description, iconUrl, logoUrl,
            websiteUrl, signupUrl, partnerSignupUrl,
            freeTrialAvailable, authType, authOnly,
            blindMapped, oauthGrantType, oauthCredentialsSource,
            oauthScopes, customScopes, hasSandboxCredentials,
            settings, serviceId, unifiedApis,
            supportedResources, configurableResources, supportedEvents,
            webhookSupport, schemaSupport, docs,
            tlsSupport);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Connector.class,
                "id", id,
                "name", name,
                "status", status,
                "description", description,
                "iconUrl", iconUrl,
                "logoUrl", logoUrl,
                "websiteUrl", websiteUrl,
                "signupUrl", signupUrl,
                "partnerSignupUrl", partnerSignupUrl,
                "freeTrialAvailable", freeTrialAvailable,
                "authType", authType,
                "authOnly", authOnly,
                "blindMapped", blindMapped,
                "oauthGrantType", oauthGrantType,
                "oauthCredentialsSource", oauthCredentialsSource,
                "oauthScopes", oauthScopes,
                "customScopes", customScopes,
                "hasSandboxCredentials", hasSandboxCredentials,
                "settings", settings,
                "serviceId", serviceId,
                "unifiedApis", unifiedApis,
                "supportedResources", supportedResources,
                "configurableResources", configurableResources,
                "supportedEvents", supportedEvents,
                "webhookSupport", webhookSupport,
                "schemaSupport", schemaSupport,
                "docs", docs,
                "tlsSupport", tlsSupport);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private String id;

        private String name;

        private ConnectorStatus status;

        private JsonNullable<String> description;

        private String iconUrl;

        private String logoUrl;

        private String websiteUrl;

        private String signupUrl;

        private String partnerSignupUrl;

        private Boolean freeTrialAvailable;

        private ConnectorAuthType authType;

        private Boolean authOnly;

        private Boolean blindMapped;

        private ConnectorOauthGrantType oauthGrantType;

        private OauthCredentialsSource oauthCredentialsSource;

        private List<OauthScopes> oauthScopes;

        private Boolean customScopes;

        private Boolean hasSandboxCredentials;

        private List<ConnectorSetting> settings;

        private String serviceId;

        private List<UnifiedApis> unifiedApis;

        private List<LinkedConnectorResource> supportedResources;

        private List<String> configurableResources;

        private List<ConnectorEvent> supportedEvents;

        private WebhookSupport webhookSupport;

        private SchemaSupport schemaSupport;

        private List<ConnectorDoc> docs;

        private TlsSupport tlsSupport;

        private Builder() {
          // force use of static builder() method
        }

        /**
         * ID of the connector.
         */
        public Builder id(@Nullable String id) {
            this.id = id;
            return this;
        }

        /**
         * Name of the connector.
         */
        public Builder name(@Nullable String name) {
            this.name = name;
            return this;
        }

        /**
         * Status of the connector. Connectors with status live or beta are callable.
         */
        public Builder status(@Nullable ConnectorStatus status) {
            this.status = status;
            return this;
        }

        /**
         * A description of the object.
         */
        public Builder description(@Nullable String description) {
            this.description = JsonNullable.of(description);
            return this;
        }

        /**
         * Link to a small square icon for the connector.
         */
        public Builder iconUrl(@Nullable String iconUrl) {
            this.iconUrl = iconUrl;
            return this;
        }

        /**
         * Link to the full logo for the connector.
         */
        public Builder logoUrl(@Nullable String logoUrl) {
            this.logoUrl = logoUrl;
            return this;
        }

        /**
         * Link to the connector's website.
         */
        public Builder websiteUrl(@Nullable String websiteUrl) {
            this.websiteUrl = websiteUrl;
            return this;
        }

        /**
         * Link to the connector's signup page.
         */
        public Builder signupUrl(@Nullable String signupUrl) {
            this.signupUrl = signupUrl;
            return this;
        }

        /**
         * Link to the connector's partner program signup page.
         */
        public Builder partnerSignupUrl(@Nullable String partnerSignupUrl) {
            this.partnerSignupUrl = partnerSignupUrl;
            return this;
        }

        /**
         * Set to `true` when the connector offers a free trial. Use `signup_url` to sign up for a free trial
         */
        public Builder freeTrialAvailable(@Nullable Boolean freeTrialAvailable) {
            this.freeTrialAvailable = freeTrialAvailable;
            return this;
        }

        /**
         * Type of authorization used by the connector
         */
        public Builder authType(@Nullable ConnectorAuthType authType) {
            this.authType = authType;
            return this;
        }

        /**
         * Indicates whether a connector only supports authentication. In this case the connector is not mapped to a Unified API, but can be used with the Proxy API
         */
        public Builder authOnly(@Nullable Boolean authOnly) {
            this.authOnly = authOnly;
            return this;
        }

        /**
         * Set to `true` when connector was implemented from downstream docs only and without API access. This state indicates that integration will require Apideck support, and access to downstream API to validate mapping quality.
         */
        public Builder blindMapped(@Nullable Boolean blindMapped) {
            this.blindMapped = blindMapped;
            return this;
        }

        /**
         * OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types
         */
        public Builder oauthGrantType(@Nullable ConnectorOauthGrantType oauthGrantType) {
            this.oauthGrantType = oauthGrantType;
            return this;
        }

        /**
         * Location of the OAuth client credentials. For most connectors the OAuth client credentials are stored on integration and managed by the application owner. For others they are stored on connection and managed by the consumer in Vault.
         */
        public Builder oauthCredentialsSource(@Nullable OauthCredentialsSource oauthCredentialsSource) {
            this.oauthCredentialsSource = oauthCredentialsSource;
            return this;
        }

        /**
         * List of OAuth Scopes available for this connector.
         */
        public Builder oauthScopes(@Nullable List<OauthScopes> oauthScopes) {
            this.oauthScopes = oauthScopes;
            return this;
        }

        /**
         * Set to `true` when connector allows the definition of custom scopes.
         */
        public Builder customScopes(@Nullable Boolean customScopes) {
            this.customScopes = customScopes;
            return this;
        }

        /**
         * Indicates whether Apideck Sandbox OAuth credentials are available.
         */
        public Builder hasSandboxCredentials(@Nullable Boolean hasSandboxCredentials) {
            this.hasSandboxCredentials = hasSandboxCredentials;
            return this;
        }

        public Builder settings(@Nullable List<ConnectorSetting> settings) {
            this.settings = settings;
            return this;
        }

        /**
         * Service provider identifier
         */
        public Builder serviceId(@Nullable String serviceId) {
            this.serviceId = serviceId;
            return this;
        }

        /**
         * List of Unified APIs that feature this connector.
         */
        public Builder unifiedApis(@Nullable List<UnifiedApis> unifiedApis) {
            this.unifiedApis = unifiedApis;
            return this;
        }

        /**
         * List of resources that are supported on the connector.
         */
        public Builder supportedResources(@Nullable List<LinkedConnectorResource> supportedResources) {
            this.supportedResources = supportedResources;
            return this;
        }

        /**
         * List of resources that have settings that can be configured.
         */
        public Builder configurableResources(@Nullable List<String> configurableResources) {
            this.configurableResources = configurableResources;
            return this;
        }

        /**
         * List of events that are supported on the connector across all Unified APIs.
         */
        public Builder supportedEvents(@Nullable List<ConnectorEvent> supportedEvents) {
            this.supportedEvents = supportedEvents;
            return this;
        }

        /**
         * How webhooks are supported for the connector. Sometimes the connector natively supports webhooks, other times Apideck virtualizes them based on polling.
         */
        public Builder webhookSupport(@Nullable WebhookSupport webhookSupport) {
            this.webhookSupport = webhookSupport;
            return this;
        }

        /**
         * When a connector has schema_support, a call can be made to retrieve a json schema that describes a downstream resource.
         */
        public Builder schemaSupport(@Nullable SchemaSupport schemaSupport) {
            this.schemaSupport = schemaSupport;
            return this;
        }

        public Builder docs(@Nullable List<ConnectorDoc> docs) {
            this.docs = docs;
            return this;
        }

        public Builder tlsSupport(@Nullable TlsSupport tlsSupport) {
            this.tlsSupport = tlsSupport;
            return this;
        }

        public Connector build() {
            return new Connector(
                id, name, status,
                description, iconUrl, logoUrl,
                websiteUrl, signupUrl, partnerSignupUrl,
                freeTrialAvailable, authType, authOnly,
                blindMapped, oauthGrantType, oauthCredentialsSource,
                oauthScopes, customScopes, hasSandboxCredentials,
                settings, serviceId, unifiedApis,
                supportedResources, configurableResources, supportedEvents,
                webhookSupport, schemaSupport, docs,
                tlsSupport);
        }

    }
}
