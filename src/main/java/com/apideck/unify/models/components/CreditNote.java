/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */


package com.apideck.unify.models.components;
import com.apideck.unify.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

public class CreditNote {

    /**
     * Unique identifier representing the entity
     */
    @JsonProperty("id")
    private String id;

    /**
     * Credit note number.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("number")
    private JsonNullable<String> number;

    /**
     * The customer this entity is linked to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customer")
    private JsonNullable<? extends LinkedCustomer> customer;

    /**
     * The company or subsidiary id the transaction belongs to
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("company_id")
    private JsonNullable<String> companyId;

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency")
    private JsonNullable<? extends Currency> currency;

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency_rate")
    private JsonNullable<Double> currencyRate;

    /**
     * Amounts are including tax
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tax_inclusive")
    private JsonNullable<Boolean> taxInclusive;

    /**
     * Sub-total amount, normally before tax.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sub_total")
    private JsonNullable<Double> subTotal;

    /**
     * Amount of transaction
     */
    @JsonProperty("total_amount")
    private double totalAmount;

    /**
     * Total tax amount applied to this invoice.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("total_tax")
    private JsonNullable<Double> totalTax;

    /**
     * Applicable tax id/code override if tax is not supplied on a line item basis.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tax_code")
    private JsonNullable<String> taxCode;

    /**
     * The balance reflecting any payments made against the transaction.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("balance")
    private JsonNullable<Double> balance;

    /**
     * Indicates the total credit amount still available to apply towards the payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("remaining_credit")
    private JsonNullable<Double> remainingCredit;

    /**
     * Status of credit notes
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<? extends CreditNoteStatus> status;

    /**
     * Optional reference message ie: Debit remittance detail.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("reference")
    private JsonNullable<String> reference;

    /**
     * Date credit note issued - YYYY:MM::DDThh:mm:ss.sTZD
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("date_issued")
    private Optional<OffsetDateTime> dateIssued;

    /**
     * Date credit note paid - YYYY:MM::DDThh:mm:ss.sTZD
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("date_paid")
    private JsonNullable<OffsetDateTime> datePaid;

    /**
     * Type of payment
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("type")
    private Optional<? extends CreditNoteType> type;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("account")
    private JsonNullable<? extends LinkedLedgerAccount> account;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("line_items")
    private Optional<? extends List<InvoiceLineItem>> lineItems;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allocations")
    private Optional<? extends List<Allocation>> allocations;

    /**
     * Optional note to be associated with the credit note.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("note")
    private JsonNullable<String> note;

    /**
     * Optional terms to be associated with the credit note.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("terms")
    private JsonNullable<String> terms;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("billing_address")
    private Optional<? extends Address> billingAddress;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shipping_address")
    private Optional<? extends Address> shippingAddress;

    /**
     * A list of linked tracking categories.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tracking_categories")
    private JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories;

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_mappings")
    private JsonNullable<? extends CustomMappings> customMappings;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_fields")
    private Optional<? extends List<CustomField>> customFields;

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("row_version")
    private JsonNullable<String> rowVersion;

    /**
     * The user who last updated the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_by")
    private JsonNullable<String> updatedBy;

    /**
     * The user who created the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_by")
    private JsonNullable<String> createdBy;

    /**
     * The date and time when the object was last updated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_at")
    private JsonNullable<OffsetDateTime> updatedAt;

    /**
     * The date and time when the object was created.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_at")
    private JsonNullable<OffsetDateTime> createdAt;

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pass_through")
    private Optional<? extends List<PassThroughBody>> passThrough;

    @JsonCreator
    public CreditNote(
            @JsonProperty("id") String id,
            @JsonProperty("number") JsonNullable<String> number,
            @JsonProperty("customer") JsonNullable<? extends LinkedCustomer> customer,
            @JsonProperty("company_id") JsonNullable<String> companyId,
            @JsonProperty("currency") JsonNullable<? extends Currency> currency,
            @JsonProperty("currency_rate") JsonNullable<Double> currencyRate,
            @JsonProperty("tax_inclusive") JsonNullable<Boolean> taxInclusive,
            @JsonProperty("sub_total") JsonNullable<Double> subTotal,
            @JsonProperty("total_amount") double totalAmount,
            @JsonProperty("total_tax") JsonNullable<Double> totalTax,
            @JsonProperty("tax_code") JsonNullable<String> taxCode,
            @JsonProperty("balance") JsonNullable<Double> balance,
            @JsonProperty("remaining_credit") JsonNullable<Double> remainingCredit,
            @JsonProperty("status") Optional<? extends CreditNoteStatus> status,
            @JsonProperty("reference") JsonNullable<String> reference,
            @JsonProperty("date_issued") Optional<OffsetDateTime> dateIssued,
            @JsonProperty("date_paid") JsonNullable<OffsetDateTime> datePaid,
            @JsonProperty("type") Optional<? extends CreditNoteType> type,
            @JsonProperty("account") JsonNullable<? extends LinkedLedgerAccount> account,
            @JsonProperty("line_items") Optional<? extends List<InvoiceLineItem>> lineItems,
            @JsonProperty("allocations") Optional<? extends List<Allocation>> allocations,
            @JsonProperty("note") JsonNullable<String> note,
            @JsonProperty("terms") JsonNullable<String> terms,
            @JsonProperty("billing_address") Optional<? extends Address> billingAddress,
            @JsonProperty("shipping_address") Optional<? extends Address> shippingAddress,
            @JsonProperty("tracking_categories") JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories,
            @JsonProperty("custom_mappings") JsonNullable<? extends CustomMappings> customMappings,
            @JsonProperty("custom_fields") Optional<? extends List<CustomField>> customFields,
            @JsonProperty("row_version") JsonNullable<String> rowVersion,
            @JsonProperty("updated_by") JsonNullable<String> updatedBy,
            @JsonProperty("created_by") JsonNullable<String> createdBy,
            @JsonProperty("updated_at") JsonNullable<OffsetDateTime> updatedAt,
            @JsonProperty("created_at") JsonNullable<OffsetDateTime> createdAt,
            @JsonProperty("pass_through") Optional<? extends List<PassThroughBody>> passThrough) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(number, "number");
        Utils.checkNotNull(customer, "customer");
        Utils.checkNotNull(companyId, "companyId");
        Utils.checkNotNull(currency, "currency");
        Utils.checkNotNull(currencyRate, "currencyRate");
        Utils.checkNotNull(taxInclusive, "taxInclusive");
        Utils.checkNotNull(subTotal, "subTotal");
        Utils.checkNotNull(totalAmount, "totalAmount");
        Utils.checkNotNull(totalTax, "totalTax");
        Utils.checkNotNull(taxCode, "taxCode");
        Utils.checkNotNull(balance, "balance");
        Utils.checkNotNull(remainingCredit, "remainingCredit");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(reference, "reference");
        Utils.checkNotNull(dateIssued, "dateIssued");
        Utils.checkNotNull(datePaid, "datePaid");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(account, "account");
        Utils.checkNotNull(lineItems, "lineItems");
        Utils.checkNotNull(allocations, "allocations");
        Utils.checkNotNull(note, "note");
        Utils.checkNotNull(terms, "terms");
        Utils.checkNotNull(billingAddress, "billingAddress");
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        Utils.checkNotNull(trackingCategories, "trackingCategories");
        Utils.checkNotNull(customMappings, "customMappings");
        Utils.checkNotNull(customFields, "customFields");
        Utils.checkNotNull(rowVersion, "rowVersion");
        Utils.checkNotNull(updatedBy, "updatedBy");
        Utils.checkNotNull(createdBy, "createdBy");
        Utils.checkNotNull(updatedAt, "updatedAt");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(passThrough, "passThrough");
        this.id = id;
        this.number = number;
        this.customer = customer;
        this.companyId = companyId;
        this.currency = currency;
        this.currencyRate = currencyRate;
        this.taxInclusive = taxInclusive;
        this.subTotal = subTotal;
        this.totalAmount = totalAmount;
        this.totalTax = totalTax;
        this.taxCode = taxCode;
        this.balance = balance;
        this.remainingCredit = remainingCredit;
        this.status = status;
        this.reference = reference;
        this.dateIssued = dateIssued;
        this.datePaid = datePaid;
        this.type = type;
        this.account = account;
        this.lineItems = lineItems;
        this.allocations = allocations;
        this.note = note;
        this.terms = terms;
        this.billingAddress = billingAddress;
        this.shippingAddress = shippingAddress;
        this.trackingCategories = trackingCategories;
        this.customMappings = customMappings;
        this.customFields = customFields;
        this.rowVersion = rowVersion;
        this.updatedBy = updatedBy;
        this.createdBy = createdBy;
        this.updatedAt = updatedAt;
        this.createdAt = createdAt;
        this.passThrough = passThrough;
    }
    
    public CreditNote(
            String id,
            double totalAmount) {
        this(id, JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), totalAmount, JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty());
    }

    /**
     * Unique identifier representing the entity
     */
    @JsonIgnore
    public String id() {
        return id;
    }

    /**
     * Credit note number.
     */
    @JsonIgnore
    public JsonNullable<String> number() {
        return number;
    }

    /**
     * The customer this entity is linked to.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<LinkedCustomer> customer() {
        return (JsonNullable<LinkedCustomer>) customer;
    }

    /**
     * The company or subsidiary id the transaction belongs to
     */
    @JsonIgnore
    public JsonNullable<String> companyId() {
        return companyId;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Currency> currency() {
        return (JsonNullable<Currency>) currency;
    }

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    @JsonIgnore
    public JsonNullable<Double> currencyRate() {
        return currencyRate;
    }

    /**
     * Amounts are including tax
     */
    @JsonIgnore
    public JsonNullable<Boolean> taxInclusive() {
        return taxInclusive;
    }

    /**
     * Sub-total amount, normally before tax.
     */
    @JsonIgnore
    public JsonNullable<Double> subTotal() {
        return subTotal;
    }

    /**
     * Amount of transaction
     */
    @JsonIgnore
    public double totalAmount() {
        return totalAmount;
    }

    /**
     * Total tax amount applied to this invoice.
     */
    @JsonIgnore
    public JsonNullable<Double> totalTax() {
        return totalTax;
    }

    /**
     * Applicable tax id/code override if tax is not supplied on a line item basis.
     */
    @JsonIgnore
    public JsonNullable<String> taxCode() {
        return taxCode;
    }

    /**
     * The balance reflecting any payments made against the transaction.
     */
    @JsonIgnore
    public JsonNullable<Double> balance() {
        return balance;
    }

    /**
     * Indicates the total credit amount still available to apply towards the payment.
     */
    @JsonIgnore
    public JsonNullable<Double> remainingCredit() {
        return remainingCredit;
    }

    /**
     * Status of credit notes
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreditNoteStatus> status() {
        return (Optional<CreditNoteStatus>) status;
    }

    /**
     * Optional reference message ie: Debit remittance detail.
     */
    @JsonIgnore
    public JsonNullable<String> reference() {
        return reference;
    }

    /**
     * Date credit note issued - YYYY:MM::DDThh:mm:ss.sTZD
     */
    @JsonIgnore
    public Optional<OffsetDateTime> dateIssued() {
        return dateIssued;
    }

    /**
     * Date credit note paid - YYYY:MM::DDThh:mm:ss.sTZD
     */
    @JsonIgnore
    public JsonNullable<OffsetDateTime> datePaid() {
        return datePaid;
    }

    /**
     * Type of payment
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<CreditNoteType> type() {
        return (Optional<CreditNoteType>) type;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<LinkedLedgerAccount> account() {
        return (JsonNullable<LinkedLedgerAccount>) account;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<InvoiceLineItem>> lineItems() {
        return (Optional<List<InvoiceLineItem>>) lineItems;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Allocation>> allocations() {
        return (Optional<List<Allocation>>) allocations;
    }

    /**
     * Optional note to be associated with the credit note.
     */
    @JsonIgnore
    public JsonNullable<String> note() {
        return note;
    }

    /**
     * Optional terms to be associated with the credit note.
     */
    @JsonIgnore
    public JsonNullable<String> terms() {
        return terms;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Address> billingAddress() {
        return (Optional<Address>) billingAddress;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Address> shippingAddress() {
        return (Optional<Address>) shippingAddress;
    }

    /**
     * A list of linked tracking categories.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<LinkedTrackingCategory>> trackingCategories() {
        return (JsonNullable<List<LinkedTrackingCategory>>) trackingCategories;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CustomMappings> customMappings() {
        return (JsonNullable<CustomMappings>) customMappings;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<CustomField>> customFields() {
        return (Optional<List<CustomField>>) customFields;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    @JsonIgnore
    public JsonNullable<String> rowVersion() {
        return rowVersion;
    }

    /**
     * The user who last updated the object.
     */
    @JsonIgnore
    public JsonNullable<String> updatedBy() {
        return updatedBy;
    }

    /**
     * The user who created the object.
     */
    @JsonIgnore
    public JsonNullable<String> createdBy() {
        return createdBy;
    }

    /**
     * The date and time when the object was last updated.
     */
    @JsonIgnore
    public JsonNullable<OffsetDateTime> updatedAt() {
        return updatedAt;
    }

    /**
     * The date and time when the object was created.
     */
    @JsonIgnore
    public JsonNullable<OffsetDateTime> createdAt() {
        return createdAt;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PassThroughBody>> passThrough() {
        return (Optional<List<PassThroughBody>>) passThrough;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * Unique identifier representing the entity
     */
    public CreditNote withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Credit note number.
     */
    public CreditNote withNumber(String number) {
        Utils.checkNotNull(number, "number");
        this.number = JsonNullable.of(number);
        return this;
    }

    /**
     * Credit note number.
     */
    public CreditNote withNumber(JsonNullable<String> number) {
        Utils.checkNotNull(number, "number");
        this.number = number;
        return this;
    }

    /**
     * The customer this entity is linked to.
     */
    public CreditNote withCustomer(LinkedCustomer customer) {
        Utils.checkNotNull(customer, "customer");
        this.customer = JsonNullable.of(customer);
        return this;
    }

    /**
     * The customer this entity is linked to.
     */
    public CreditNote withCustomer(JsonNullable<? extends LinkedCustomer> customer) {
        Utils.checkNotNull(customer, "customer");
        this.customer = customer;
        return this;
    }

    /**
     * The company or subsidiary id the transaction belongs to
     */
    public CreditNote withCompanyId(String companyId) {
        Utils.checkNotNull(companyId, "companyId");
        this.companyId = JsonNullable.of(companyId);
        return this;
    }

    /**
     * The company or subsidiary id the transaction belongs to
     */
    public CreditNote withCompanyId(JsonNullable<String> companyId) {
        Utils.checkNotNull(companyId, "companyId");
        this.companyId = companyId;
        return this;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    public CreditNote withCurrency(Currency currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = JsonNullable.of(currency);
        return this;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    public CreditNote withCurrency(JsonNullable<? extends Currency> currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = currency;
        return this;
    }

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    public CreditNote withCurrencyRate(double currencyRate) {
        Utils.checkNotNull(currencyRate, "currencyRate");
        this.currencyRate = JsonNullable.of(currencyRate);
        return this;
    }

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    public CreditNote withCurrencyRate(JsonNullable<Double> currencyRate) {
        Utils.checkNotNull(currencyRate, "currencyRate");
        this.currencyRate = currencyRate;
        return this;
    }

    /**
     * Amounts are including tax
     */
    public CreditNote withTaxInclusive(boolean taxInclusive) {
        Utils.checkNotNull(taxInclusive, "taxInclusive");
        this.taxInclusive = JsonNullable.of(taxInclusive);
        return this;
    }

    /**
     * Amounts are including tax
     */
    public CreditNote withTaxInclusive(JsonNullable<Boolean> taxInclusive) {
        Utils.checkNotNull(taxInclusive, "taxInclusive");
        this.taxInclusive = taxInclusive;
        return this;
    }

    /**
     * Sub-total amount, normally before tax.
     */
    public CreditNote withSubTotal(double subTotal) {
        Utils.checkNotNull(subTotal, "subTotal");
        this.subTotal = JsonNullable.of(subTotal);
        return this;
    }

    /**
     * Sub-total amount, normally before tax.
     */
    public CreditNote withSubTotal(JsonNullable<Double> subTotal) {
        Utils.checkNotNull(subTotal, "subTotal");
        this.subTotal = subTotal;
        return this;
    }

    /**
     * Amount of transaction
     */
    public CreditNote withTotalAmount(double totalAmount) {
        Utils.checkNotNull(totalAmount, "totalAmount");
        this.totalAmount = totalAmount;
        return this;
    }

    /**
     * Total tax amount applied to this invoice.
     */
    public CreditNote withTotalTax(double totalTax) {
        Utils.checkNotNull(totalTax, "totalTax");
        this.totalTax = JsonNullable.of(totalTax);
        return this;
    }

    /**
     * Total tax amount applied to this invoice.
     */
    public CreditNote withTotalTax(JsonNullable<Double> totalTax) {
        Utils.checkNotNull(totalTax, "totalTax");
        this.totalTax = totalTax;
        return this;
    }

    /**
     * Applicable tax id/code override if tax is not supplied on a line item basis.
     */
    public CreditNote withTaxCode(String taxCode) {
        Utils.checkNotNull(taxCode, "taxCode");
        this.taxCode = JsonNullable.of(taxCode);
        return this;
    }

    /**
     * Applicable tax id/code override if tax is not supplied on a line item basis.
     */
    public CreditNote withTaxCode(JsonNullable<String> taxCode) {
        Utils.checkNotNull(taxCode, "taxCode");
        this.taxCode = taxCode;
        return this;
    }

    /**
     * The balance reflecting any payments made against the transaction.
     */
    public CreditNote withBalance(double balance) {
        Utils.checkNotNull(balance, "balance");
        this.balance = JsonNullable.of(balance);
        return this;
    }

    /**
     * The balance reflecting any payments made against the transaction.
     */
    public CreditNote withBalance(JsonNullable<Double> balance) {
        Utils.checkNotNull(balance, "balance");
        this.balance = balance;
        return this;
    }

    /**
     * Indicates the total credit amount still available to apply towards the payment.
     */
    public CreditNote withRemainingCredit(double remainingCredit) {
        Utils.checkNotNull(remainingCredit, "remainingCredit");
        this.remainingCredit = JsonNullable.of(remainingCredit);
        return this;
    }

    /**
     * Indicates the total credit amount still available to apply towards the payment.
     */
    public CreditNote withRemainingCredit(JsonNullable<Double> remainingCredit) {
        Utils.checkNotNull(remainingCredit, "remainingCredit");
        this.remainingCredit = remainingCredit;
        return this;
    }

    /**
     * Status of credit notes
     */
    public CreditNote withStatus(CreditNoteStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }

    /**
     * Status of credit notes
     */
    public CreditNote withStatus(Optional<? extends CreditNoteStatus> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * Optional reference message ie: Debit remittance detail.
     */
    public CreditNote withReference(String reference) {
        Utils.checkNotNull(reference, "reference");
        this.reference = JsonNullable.of(reference);
        return this;
    }

    /**
     * Optional reference message ie: Debit remittance detail.
     */
    public CreditNote withReference(JsonNullable<String> reference) {
        Utils.checkNotNull(reference, "reference");
        this.reference = reference;
        return this;
    }

    /**
     * Date credit note issued - YYYY:MM::DDThh:mm:ss.sTZD
     */
    public CreditNote withDateIssued(OffsetDateTime dateIssued) {
        Utils.checkNotNull(dateIssued, "dateIssued");
        this.dateIssued = Optional.ofNullable(dateIssued);
        return this;
    }

    /**
     * Date credit note issued - YYYY:MM::DDThh:mm:ss.sTZD
     */
    public CreditNote withDateIssued(Optional<OffsetDateTime> dateIssued) {
        Utils.checkNotNull(dateIssued, "dateIssued");
        this.dateIssued = dateIssued;
        return this;
    }

    /**
     * Date credit note paid - YYYY:MM::DDThh:mm:ss.sTZD
     */
    public CreditNote withDatePaid(OffsetDateTime datePaid) {
        Utils.checkNotNull(datePaid, "datePaid");
        this.datePaid = JsonNullable.of(datePaid);
        return this;
    }

    /**
     * Date credit note paid - YYYY:MM::DDThh:mm:ss.sTZD
     */
    public CreditNote withDatePaid(JsonNullable<OffsetDateTime> datePaid) {
        Utils.checkNotNull(datePaid, "datePaid");
        this.datePaid = datePaid;
        return this;
    }

    /**
     * Type of payment
     */
    public CreditNote withType(CreditNoteType type) {
        Utils.checkNotNull(type, "type");
        this.type = Optional.ofNullable(type);
        return this;
    }

    /**
     * Type of payment
     */
    public CreditNote withType(Optional<? extends CreditNoteType> type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    public CreditNote withAccount(LinkedLedgerAccount account) {
        Utils.checkNotNull(account, "account");
        this.account = JsonNullable.of(account);
        return this;
    }

    public CreditNote withAccount(JsonNullable<? extends LinkedLedgerAccount> account) {
        Utils.checkNotNull(account, "account");
        this.account = account;
        return this;
    }

    public CreditNote withLineItems(List<InvoiceLineItem> lineItems) {
        Utils.checkNotNull(lineItems, "lineItems");
        this.lineItems = Optional.ofNullable(lineItems);
        return this;
    }

    public CreditNote withLineItems(Optional<? extends List<InvoiceLineItem>> lineItems) {
        Utils.checkNotNull(lineItems, "lineItems");
        this.lineItems = lineItems;
        return this;
    }

    public CreditNote withAllocations(List<Allocation> allocations) {
        Utils.checkNotNull(allocations, "allocations");
        this.allocations = Optional.ofNullable(allocations);
        return this;
    }

    public CreditNote withAllocations(Optional<? extends List<Allocation>> allocations) {
        Utils.checkNotNull(allocations, "allocations");
        this.allocations = allocations;
        return this;
    }

    /**
     * Optional note to be associated with the credit note.
     */
    public CreditNote withNote(String note) {
        Utils.checkNotNull(note, "note");
        this.note = JsonNullable.of(note);
        return this;
    }

    /**
     * Optional note to be associated with the credit note.
     */
    public CreditNote withNote(JsonNullable<String> note) {
        Utils.checkNotNull(note, "note");
        this.note = note;
        return this;
    }

    /**
     * Optional terms to be associated with the credit note.
     */
    public CreditNote withTerms(String terms) {
        Utils.checkNotNull(terms, "terms");
        this.terms = JsonNullable.of(terms);
        return this;
    }

    /**
     * Optional terms to be associated with the credit note.
     */
    public CreditNote withTerms(JsonNullable<String> terms) {
        Utils.checkNotNull(terms, "terms");
        this.terms = terms;
        return this;
    }

    public CreditNote withBillingAddress(Address billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = Optional.ofNullable(billingAddress);
        return this;
    }

    public CreditNote withBillingAddress(Optional<? extends Address> billingAddress) {
        Utils.checkNotNull(billingAddress, "billingAddress");
        this.billingAddress = billingAddress;
        return this;
    }

    public CreditNote withShippingAddress(Address shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = Optional.ofNullable(shippingAddress);
        return this;
    }

    public CreditNote withShippingAddress(Optional<? extends Address> shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = shippingAddress;
        return this;
    }

    /**
     * A list of linked tracking categories.
     */
    public CreditNote withTrackingCategories(List<LinkedTrackingCategory> trackingCategories) {
        Utils.checkNotNull(trackingCategories, "trackingCategories");
        this.trackingCategories = JsonNullable.of(trackingCategories);
        return this;
    }

    /**
     * A list of linked tracking categories.
     */
    public CreditNote withTrackingCategories(JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories) {
        Utils.checkNotNull(trackingCategories, "trackingCategories");
        this.trackingCategories = trackingCategories;
        return this;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public CreditNote withCustomMappings(CustomMappings customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = JsonNullable.of(customMappings);
        return this;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public CreditNote withCustomMappings(JsonNullable<? extends CustomMappings> customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = customMappings;
        return this;
    }

    public CreditNote withCustomFields(List<CustomField> customFields) {
        Utils.checkNotNull(customFields, "customFields");
        this.customFields = Optional.ofNullable(customFields);
        return this;
    }

    public CreditNote withCustomFields(Optional<? extends List<CustomField>> customFields) {
        Utils.checkNotNull(customFields, "customFields");
        this.customFields = customFields;
        return this;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    public CreditNote withRowVersion(String rowVersion) {
        Utils.checkNotNull(rowVersion, "rowVersion");
        this.rowVersion = JsonNullable.of(rowVersion);
        return this;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    public CreditNote withRowVersion(JsonNullable<String> rowVersion) {
        Utils.checkNotNull(rowVersion, "rowVersion");
        this.rowVersion = rowVersion;
        return this;
    }

    /**
     * The user who last updated the object.
     */
    public CreditNote withUpdatedBy(String updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = JsonNullable.of(updatedBy);
        return this;
    }

    /**
     * The user who last updated the object.
     */
    public CreditNote withUpdatedBy(JsonNullable<String> updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = updatedBy;
        return this;
    }

    /**
     * The user who created the object.
     */
    public CreditNote withCreatedBy(String createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = JsonNullable.of(createdBy);
        return this;
    }

    /**
     * The user who created the object.
     */
    public CreditNote withCreatedBy(JsonNullable<String> createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = createdBy;
        return this;
    }

    /**
     * The date and time when the object was last updated.
     */
    public CreditNote withUpdatedAt(OffsetDateTime updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = JsonNullable.of(updatedAt);
        return this;
    }

    /**
     * The date and time when the object was last updated.
     */
    public CreditNote withUpdatedAt(JsonNullable<OffsetDateTime> updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = updatedAt;
        return this;
    }

    /**
     * The date and time when the object was created.
     */
    public CreditNote withCreatedAt(OffsetDateTime createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = JsonNullable.of(createdAt);
        return this;
    }

    /**
     * The date and time when the object was created.
     */
    public CreditNote withCreatedAt(JsonNullable<OffsetDateTime> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    public CreditNote withPassThrough(List<PassThroughBody> passThrough) {
        Utils.checkNotNull(passThrough, "passThrough");
        this.passThrough = Optional.ofNullable(passThrough);
        return this;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    public CreditNote withPassThrough(Optional<? extends List<PassThroughBody>> passThrough) {
        Utils.checkNotNull(passThrough, "passThrough");
        this.passThrough = passThrough;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CreditNote other = (CreditNote) o;
        return 
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.number, other.number) &&
            Objects.deepEquals(this.customer, other.customer) &&
            Objects.deepEquals(this.companyId, other.companyId) &&
            Objects.deepEquals(this.currency, other.currency) &&
            Objects.deepEquals(this.currencyRate, other.currencyRate) &&
            Objects.deepEquals(this.taxInclusive, other.taxInclusive) &&
            Objects.deepEquals(this.subTotal, other.subTotal) &&
            Objects.deepEquals(this.totalAmount, other.totalAmount) &&
            Objects.deepEquals(this.totalTax, other.totalTax) &&
            Objects.deepEquals(this.taxCode, other.taxCode) &&
            Objects.deepEquals(this.balance, other.balance) &&
            Objects.deepEquals(this.remainingCredit, other.remainingCredit) &&
            Objects.deepEquals(this.status, other.status) &&
            Objects.deepEquals(this.reference, other.reference) &&
            Objects.deepEquals(this.dateIssued, other.dateIssued) &&
            Objects.deepEquals(this.datePaid, other.datePaid) &&
            Objects.deepEquals(this.type, other.type) &&
            Objects.deepEquals(this.account, other.account) &&
            Objects.deepEquals(this.lineItems, other.lineItems) &&
            Objects.deepEquals(this.allocations, other.allocations) &&
            Objects.deepEquals(this.note, other.note) &&
            Objects.deepEquals(this.terms, other.terms) &&
            Objects.deepEquals(this.billingAddress, other.billingAddress) &&
            Objects.deepEquals(this.shippingAddress, other.shippingAddress) &&
            Objects.deepEquals(this.trackingCategories, other.trackingCategories) &&
            Objects.deepEquals(this.customMappings, other.customMappings) &&
            Objects.deepEquals(this.customFields, other.customFields) &&
            Objects.deepEquals(this.rowVersion, other.rowVersion) &&
            Objects.deepEquals(this.updatedBy, other.updatedBy) &&
            Objects.deepEquals(this.createdBy, other.createdBy) &&
            Objects.deepEquals(this.updatedAt, other.updatedAt) &&
            Objects.deepEquals(this.createdAt, other.createdAt) &&
            Objects.deepEquals(this.passThrough, other.passThrough);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            id,
            number,
            customer,
            companyId,
            currency,
            currencyRate,
            taxInclusive,
            subTotal,
            totalAmount,
            totalTax,
            taxCode,
            balance,
            remainingCredit,
            status,
            reference,
            dateIssued,
            datePaid,
            type,
            account,
            lineItems,
            allocations,
            note,
            terms,
            billingAddress,
            shippingAddress,
            trackingCategories,
            customMappings,
            customFields,
            rowVersion,
            updatedBy,
            createdBy,
            updatedAt,
            createdAt,
            passThrough);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CreditNote.class,
                "id", id,
                "number", number,
                "customer", customer,
                "companyId", companyId,
                "currency", currency,
                "currencyRate", currencyRate,
                "taxInclusive", taxInclusive,
                "subTotal", subTotal,
                "totalAmount", totalAmount,
                "totalTax", totalTax,
                "taxCode", taxCode,
                "balance", balance,
                "remainingCredit", remainingCredit,
                "status", status,
                "reference", reference,
                "dateIssued", dateIssued,
                "datePaid", datePaid,
                "type", type,
                "account", account,
                "lineItems", lineItems,
                "allocations", allocations,
                "note", note,
                "terms", terms,
                "billingAddress", billingAddress,
                "shippingAddress", shippingAddress,
                "trackingCategories", trackingCategories,
                "customMappings", customMappings,
                "customFields", customFields,
                "rowVersion", rowVersion,
                "updatedBy", updatedBy,
                "createdBy", createdBy,
                "updatedAt", updatedAt,
                "createdAt", createdAt,
                "passThrough", passThrough);
    }
    
    public final static class Builder {
 
        private String id;
 
        private JsonNullable<String> number = JsonNullable.undefined();
 
        private JsonNullable<? extends LinkedCustomer> customer = JsonNullable.undefined();
 
        private JsonNullable<String> companyId = JsonNullable.undefined();
 
        private JsonNullable<? extends Currency> currency = JsonNullable.undefined();
 
        private JsonNullable<Double> currencyRate = JsonNullable.undefined();
 
        private JsonNullable<Boolean> taxInclusive = JsonNullable.undefined();
 
        private JsonNullable<Double> subTotal = JsonNullable.undefined();
 
        private Double totalAmount;
 
        private JsonNullable<Double> totalTax = JsonNullable.undefined();
 
        private JsonNullable<String> taxCode = JsonNullable.undefined();
 
        private JsonNullable<Double> balance = JsonNullable.undefined();
 
        private JsonNullable<Double> remainingCredit = JsonNullable.undefined();
 
        private Optional<? extends CreditNoteStatus> status = Optional.empty();
 
        private JsonNullable<String> reference = JsonNullable.undefined();
 
        private Optional<OffsetDateTime> dateIssued = Optional.empty();
 
        private JsonNullable<OffsetDateTime> datePaid = JsonNullable.undefined();
 
        private Optional<? extends CreditNoteType> type = Optional.empty();
 
        private JsonNullable<? extends LinkedLedgerAccount> account = JsonNullable.undefined();
 
        private Optional<? extends List<InvoiceLineItem>> lineItems = Optional.empty();
 
        private Optional<? extends List<Allocation>> allocations = Optional.empty();
 
        private JsonNullable<String> note = JsonNullable.undefined();
 
        private JsonNullable<String> terms = JsonNullable.undefined();
 
        private Optional<? extends Address> billingAddress = Optional.empty();
 
        private Optional<? extends Address> shippingAddress = Optional.empty();
 
        private JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories = JsonNullable.undefined();
 
        private JsonNullable<? extends CustomMappings> customMappings = JsonNullable.undefined();
 
        private Optional<? extends List<CustomField>> customFields = Optional.empty();
 
        private JsonNullable<String> rowVersion = JsonNullable.undefined();
 
        private JsonNullable<String> updatedBy = JsonNullable.undefined();
 
        private JsonNullable<String> createdBy = JsonNullable.undefined();
 
        private JsonNullable<OffsetDateTime> updatedAt = JsonNullable.undefined();
 
        private JsonNullable<OffsetDateTime> createdAt = JsonNullable.undefined();
 
        private Optional<? extends List<PassThroughBody>> passThrough = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * Unique identifier representing the entity
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * Credit note number.
         */
        public Builder number(String number) {
            Utils.checkNotNull(number, "number");
            this.number = JsonNullable.of(number);
            return this;
        }

        /**
         * Credit note number.
         */
        public Builder number(JsonNullable<String> number) {
            Utils.checkNotNull(number, "number");
            this.number = number;
            return this;
        }

        /**
         * The customer this entity is linked to.
         */
        public Builder customer(LinkedCustomer customer) {
            Utils.checkNotNull(customer, "customer");
            this.customer = JsonNullable.of(customer);
            return this;
        }

        /**
         * The customer this entity is linked to.
         */
        public Builder customer(JsonNullable<? extends LinkedCustomer> customer) {
            Utils.checkNotNull(customer, "customer");
            this.customer = customer;
            return this;
        }

        /**
         * The company or subsidiary id the transaction belongs to
         */
        public Builder companyId(String companyId) {
            Utils.checkNotNull(companyId, "companyId");
            this.companyId = JsonNullable.of(companyId);
            return this;
        }

        /**
         * The company or subsidiary id the transaction belongs to
         */
        public Builder companyId(JsonNullable<String> companyId) {
            Utils.checkNotNull(companyId, "companyId");
            this.companyId = companyId;
            return this;
        }

        /**
         * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
         */
        public Builder currency(Currency currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = JsonNullable.of(currency);
            return this;
        }

        /**
         * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
         */
        public Builder currency(JsonNullable<? extends Currency> currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = currency;
            return this;
        }

        /**
         * Currency Exchange Rate at the time entity was recorded/generated.
         */
        public Builder currencyRate(double currencyRate) {
            Utils.checkNotNull(currencyRate, "currencyRate");
            this.currencyRate = JsonNullable.of(currencyRate);
            return this;
        }

        /**
         * Currency Exchange Rate at the time entity was recorded/generated.
         */
        public Builder currencyRate(JsonNullable<Double> currencyRate) {
            Utils.checkNotNull(currencyRate, "currencyRate");
            this.currencyRate = currencyRate;
            return this;
        }

        /**
         * Amounts are including tax
         */
        public Builder taxInclusive(boolean taxInclusive) {
            Utils.checkNotNull(taxInclusive, "taxInclusive");
            this.taxInclusive = JsonNullable.of(taxInclusive);
            return this;
        }

        /**
         * Amounts are including tax
         */
        public Builder taxInclusive(JsonNullable<Boolean> taxInclusive) {
            Utils.checkNotNull(taxInclusive, "taxInclusive");
            this.taxInclusive = taxInclusive;
            return this;
        }

        /**
         * Sub-total amount, normally before tax.
         */
        public Builder subTotal(double subTotal) {
            Utils.checkNotNull(subTotal, "subTotal");
            this.subTotal = JsonNullable.of(subTotal);
            return this;
        }

        /**
         * Sub-total amount, normally before tax.
         */
        public Builder subTotal(JsonNullable<Double> subTotal) {
            Utils.checkNotNull(subTotal, "subTotal");
            this.subTotal = subTotal;
            return this;
        }

        /**
         * Amount of transaction
         */
        public Builder totalAmount(double totalAmount) {
            Utils.checkNotNull(totalAmount, "totalAmount");
            this.totalAmount = totalAmount;
            return this;
        }

        /**
         * Total tax amount applied to this invoice.
         */
        public Builder totalTax(double totalTax) {
            Utils.checkNotNull(totalTax, "totalTax");
            this.totalTax = JsonNullable.of(totalTax);
            return this;
        }

        /**
         * Total tax amount applied to this invoice.
         */
        public Builder totalTax(JsonNullable<Double> totalTax) {
            Utils.checkNotNull(totalTax, "totalTax");
            this.totalTax = totalTax;
            return this;
        }

        /**
         * Applicable tax id/code override if tax is not supplied on a line item basis.
         */
        public Builder taxCode(String taxCode) {
            Utils.checkNotNull(taxCode, "taxCode");
            this.taxCode = JsonNullable.of(taxCode);
            return this;
        }

        /**
         * Applicable tax id/code override if tax is not supplied on a line item basis.
         */
        public Builder taxCode(JsonNullable<String> taxCode) {
            Utils.checkNotNull(taxCode, "taxCode");
            this.taxCode = taxCode;
            return this;
        }

        /**
         * The balance reflecting any payments made against the transaction.
         */
        public Builder balance(double balance) {
            Utils.checkNotNull(balance, "balance");
            this.balance = JsonNullable.of(balance);
            return this;
        }

        /**
         * The balance reflecting any payments made against the transaction.
         */
        public Builder balance(JsonNullable<Double> balance) {
            Utils.checkNotNull(balance, "balance");
            this.balance = balance;
            return this;
        }

        /**
         * Indicates the total credit amount still available to apply towards the payment.
         */
        public Builder remainingCredit(double remainingCredit) {
            Utils.checkNotNull(remainingCredit, "remainingCredit");
            this.remainingCredit = JsonNullable.of(remainingCredit);
            return this;
        }

        /**
         * Indicates the total credit amount still available to apply towards the payment.
         */
        public Builder remainingCredit(JsonNullable<Double> remainingCredit) {
            Utils.checkNotNull(remainingCredit, "remainingCredit");
            this.remainingCredit = remainingCredit;
            return this;
        }

        /**
         * Status of credit notes
         */
        public Builder status(CreditNoteStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * Status of credit notes
         */
        public Builder status(Optional<? extends CreditNoteStatus> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * Optional reference message ie: Debit remittance detail.
         */
        public Builder reference(String reference) {
            Utils.checkNotNull(reference, "reference");
            this.reference = JsonNullable.of(reference);
            return this;
        }

        /**
         * Optional reference message ie: Debit remittance detail.
         */
        public Builder reference(JsonNullable<String> reference) {
            Utils.checkNotNull(reference, "reference");
            this.reference = reference;
            return this;
        }

        /**
         * Date credit note issued - YYYY:MM::DDThh:mm:ss.sTZD
         */
        public Builder dateIssued(OffsetDateTime dateIssued) {
            Utils.checkNotNull(dateIssued, "dateIssued");
            this.dateIssued = Optional.ofNullable(dateIssued);
            return this;
        }

        /**
         * Date credit note issued - YYYY:MM::DDThh:mm:ss.sTZD
         */
        public Builder dateIssued(Optional<OffsetDateTime> dateIssued) {
            Utils.checkNotNull(dateIssued, "dateIssued");
            this.dateIssued = dateIssued;
            return this;
        }

        /**
         * Date credit note paid - YYYY:MM::DDThh:mm:ss.sTZD
         */
        public Builder datePaid(OffsetDateTime datePaid) {
            Utils.checkNotNull(datePaid, "datePaid");
            this.datePaid = JsonNullable.of(datePaid);
            return this;
        }

        /**
         * Date credit note paid - YYYY:MM::DDThh:mm:ss.sTZD
         */
        public Builder datePaid(JsonNullable<OffsetDateTime> datePaid) {
            Utils.checkNotNull(datePaid, "datePaid");
            this.datePaid = datePaid;
            return this;
        }

        /**
         * Type of payment
         */
        public Builder type(CreditNoteType type) {
            Utils.checkNotNull(type, "type");
            this.type = Optional.ofNullable(type);
            return this;
        }

        /**
         * Type of payment
         */
        public Builder type(Optional<? extends CreditNoteType> type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }

        public Builder account(LinkedLedgerAccount account) {
            Utils.checkNotNull(account, "account");
            this.account = JsonNullable.of(account);
            return this;
        }

        public Builder account(JsonNullable<? extends LinkedLedgerAccount> account) {
            Utils.checkNotNull(account, "account");
            this.account = account;
            return this;
        }

        public Builder lineItems(List<InvoiceLineItem> lineItems) {
            Utils.checkNotNull(lineItems, "lineItems");
            this.lineItems = Optional.ofNullable(lineItems);
            return this;
        }

        public Builder lineItems(Optional<? extends List<InvoiceLineItem>> lineItems) {
            Utils.checkNotNull(lineItems, "lineItems");
            this.lineItems = lineItems;
            return this;
        }

        public Builder allocations(List<Allocation> allocations) {
            Utils.checkNotNull(allocations, "allocations");
            this.allocations = Optional.ofNullable(allocations);
            return this;
        }

        public Builder allocations(Optional<? extends List<Allocation>> allocations) {
            Utils.checkNotNull(allocations, "allocations");
            this.allocations = allocations;
            return this;
        }

        /**
         * Optional note to be associated with the credit note.
         */
        public Builder note(String note) {
            Utils.checkNotNull(note, "note");
            this.note = JsonNullable.of(note);
            return this;
        }

        /**
         * Optional note to be associated with the credit note.
         */
        public Builder note(JsonNullable<String> note) {
            Utils.checkNotNull(note, "note");
            this.note = note;
            return this;
        }

        /**
         * Optional terms to be associated with the credit note.
         */
        public Builder terms(String terms) {
            Utils.checkNotNull(terms, "terms");
            this.terms = JsonNullable.of(terms);
            return this;
        }

        /**
         * Optional terms to be associated with the credit note.
         */
        public Builder terms(JsonNullable<String> terms) {
            Utils.checkNotNull(terms, "terms");
            this.terms = terms;
            return this;
        }

        public Builder billingAddress(Address billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = Optional.ofNullable(billingAddress);
            return this;
        }

        public Builder billingAddress(Optional<? extends Address> billingAddress) {
            Utils.checkNotNull(billingAddress, "billingAddress");
            this.billingAddress = billingAddress;
            return this;
        }

        public Builder shippingAddress(Address shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = Optional.ofNullable(shippingAddress);
            return this;
        }

        public Builder shippingAddress(Optional<? extends Address> shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = shippingAddress;
            return this;
        }

        /**
         * A list of linked tracking categories.
         */
        public Builder trackingCategories(List<LinkedTrackingCategory> trackingCategories) {
            Utils.checkNotNull(trackingCategories, "trackingCategories");
            this.trackingCategories = JsonNullable.of(trackingCategories);
            return this;
        }

        /**
         * A list of linked tracking categories.
         */
        public Builder trackingCategories(JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories) {
            Utils.checkNotNull(trackingCategories, "trackingCategories");
            this.trackingCategories = trackingCategories;
            return this;
        }

        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(CustomMappings customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = JsonNullable.of(customMappings);
            return this;
        }

        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(JsonNullable<? extends CustomMappings> customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = customMappings;
            return this;
        }

        public Builder customFields(List<CustomField> customFields) {
            Utils.checkNotNull(customFields, "customFields");
            this.customFields = Optional.ofNullable(customFields);
            return this;
        }

        public Builder customFields(Optional<? extends List<CustomField>> customFields) {
            Utils.checkNotNull(customFields, "customFields");
            this.customFields = customFields;
            return this;
        }

        /**
         * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
         */
        public Builder rowVersion(String rowVersion) {
            Utils.checkNotNull(rowVersion, "rowVersion");
            this.rowVersion = JsonNullable.of(rowVersion);
            return this;
        }

        /**
         * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
         */
        public Builder rowVersion(JsonNullable<String> rowVersion) {
            Utils.checkNotNull(rowVersion, "rowVersion");
            this.rowVersion = rowVersion;
            return this;
        }

        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(String updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = JsonNullable.of(updatedBy);
            return this;
        }

        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(JsonNullable<String> updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = updatedBy;
            return this;
        }

        /**
         * The user who created the object.
         */
        public Builder createdBy(String createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = JsonNullable.of(createdBy);
            return this;
        }

        /**
         * The user who created the object.
         */
        public Builder createdBy(JsonNullable<String> createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = createdBy;
            return this;
        }

        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(OffsetDateTime updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = JsonNullable.of(updatedAt);
            return this;
        }

        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(JsonNullable<OffsetDateTime> updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = updatedAt;
            return this;
        }

        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(OffsetDateTime createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = JsonNullable.of(createdAt);
            return this;
        }

        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(JsonNullable<OffsetDateTime> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
         */
        public Builder passThrough(List<PassThroughBody> passThrough) {
            Utils.checkNotNull(passThrough, "passThrough");
            this.passThrough = Optional.ofNullable(passThrough);
            return this;
        }

        /**
         * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
         */
        public Builder passThrough(Optional<? extends List<PassThroughBody>> passThrough) {
            Utils.checkNotNull(passThrough, "passThrough");
            this.passThrough = passThrough;
            return this;
        }
        
        public CreditNote build() {
            return new CreditNote(
                id,
                number,
                customer,
                companyId,
                currency,
                currencyRate,
                taxInclusive,
                subTotal,
                totalAmount,
                totalTax,
                taxCode,
                balance,
                remainingCredit,
                status,
                reference,
                dateIssued,
                datePaid,
                type,
                account,
                lineItems,
                allocations,
                note,
                terms,
                billingAddress,
                shippingAddress,
                trackingCategories,
                customMappings,
                customFields,
                rowVersion,
                updatedBy,
                createdBy,
                updatedAt,
                createdAt,
                passThrough);
        }
    }
}

