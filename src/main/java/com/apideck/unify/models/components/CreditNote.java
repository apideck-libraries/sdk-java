/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.apideck.unify.models.components;

import com.apideck.unify.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.annotation.Nonnull;
import jakarta.annotation.Nullable;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class CreditNote {
    /**
     * Unique identifier representing the entity
     */
    @JsonProperty("id")
    private String id;

    /**
     * Credit note number.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("number")
    private JsonNullable<String> number;

    /**
     * The customer this entity is linked to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customer")
    private JsonNullable<LinkedCustomer> customer;

    /**
     * The company or subsidiary id the transaction belongs to
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("company_id")
    private JsonNullable<String> companyId;

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency")
    private JsonNullable<Currency> currency;

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency_rate")
    private JsonNullable<Double> currencyRate;

    /**
     * Amounts are including tax
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tax_inclusive")
    private JsonNullable<Boolean> taxInclusive;

    /**
     * Sub-total amount, normally before tax.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sub_total")
    private JsonNullable<Double> subTotal;

    /**
     * Amount of transaction
     */
    @JsonProperty("total_amount")
    private double totalAmount;

    /**
     * Total tax amount applied to this invoice.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("total_tax")
    private JsonNullable<Double> totalTax;

    /**
     * Applicable tax id/code override if tax is not supplied on a line item basis.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tax_code")
    private JsonNullable<String> taxCode;

    /**
     * The balance reflecting any payments made against the transaction.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("balance")
    private JsonNullable<Double> balance;

    /**
     * Indicates the total credit amount still available to apply towards the payment.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("remaining_credit")
    private JsonNullable<Double> remainingCredit;

    /**
     * Status of credit notes
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private CreditNoteStatus status;

    /**
     * Optional reference message ie: Debit remittance detail.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("reference")
    private JsonNullable<String> reference;

    /**
     * Date credit note issued - YYYY:MM::DDThh:mm:ss.sTZD
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("date_issued")
    private OffsetDateTime dateIssued;

    /**
     * Date credit note paid - YYYY:MM::DDThh:mm:ss.sTZD
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("date_paid")
    private JsonNullable<OffsetDateTime> datePaid;

    /**
     * Type of payment
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("type")
    private CreditNoteType type;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("account")
    private JsonNullable<LinkedLedgerAccount> account;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("line_items")
    private List<InvoiceLineItem> lineItems;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allocations")
    private List<Allocation> allocations;

    /**
     * Optional note to be associated with the credit note.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("note")
    private JsonNullable<String> note;

    /**
     * Optional terms to be associated with the credit note.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("terms")
    private JsonNullable<String> terms;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("billing_address")
    private Address billingAddress;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shipping_address")
    private Address shippingAddress;

    /**
     * A list of linked tracking categories.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tracking_categories")
    private JsonNullable<List<LinkedTrackingCategory>> trackingCategories;

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_mappings")
    private JsonNullable<Map<String, Object>> customMappings;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_fields")
    private List<CustomField> customFields;

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("row_version")
    private JsonNullable<String> rowVersion;

    /**
     * The user who last updated the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_by")
    private JsonNullable<String> updatedBy;

    /**
     * The user who created the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_by")
    private JsonNullable<String> createdBy;

    /**
     * The date and time when the object was last updated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_at")
    private JsonNullable<OffsetDateTime> updatedAt;

    /**
     * The date and time when the object was created.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_at")
    private JsonNullable<OffsetDateTime> createdAt;

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pass_through")
    private List<PassThroughBody> passThrough;

    @JsonCreator
    public CreditNote(
            @JsonProperty("id") @Nonnull String id,
            @JsonProperty("number") @Nullable JsonNullable<String> number,
            @JsonProperty("customer") @Nullable JsonNullable<LinkedCustomer> customer,
            @JsonProperty("company_id") @Nullable JsonNullable<String> companyId,
            @JsonProperty("currency") @Nullable JsonNullable<Currency> currency,
            @JsonProperty("currency_rate") @Nullable JsonNullable<Double> currencyRate,
            @JsonProperty("tax_inclusive") @Nullable JsonNullable<Boolean> taxInclusive,
            @JsonProperty("sub_total") @Nullable JsonNullable<Double> subTotal,
            @JsonProperty("total_amount") double totalAmount,
            @JsonProperty("total_tax") @Nullable JsonNullable<Double> totalTax,
            @JsonProperty("tax_code") @Nullable JsonNullable<String> taxCode,
            @JsonProperty("balance") @Nullable JsonNullable<Double> balance,
            @JsonProperty("remaining_credit") @Nullable JsonNullable<Double> remainingCredit,
            @JsonProperty("status") @Nullable CreditNoteStatus status,
            @JsonProperty("reference") @Nullable JsonNullable<String> reference,
            @JsonProperty("date_issued") @Nullable OffsetDateTime dateIssued,
            @JsonProperty("date_paid") @Nullable JsonNullable<OffsetDateTime> datePaid,
            @JsonProperty("type") @Nullable CreditNoteType type,
            @JsonProperty("account") @Nullable JsonNullable<LinkedLedgerAccount> account,
            @JsonProperty("line_items") @Nullable List<InvoiceLineItem> lineItems,
            @JsonProperty("allocations") @Nullable List<Allocation> allocations,
            @JsonProperty("note") @Nullable JsonNullable<String> note,
            @JsonProperty("terms") @Nullable JsonNullable<String> terms,
            @JsonProperty("billing_address") @Nullable Address billingAddress,
            @JsonProperty("shipping_address") @Nullable Address shippingAddress,
            @JsonProperty("tracking_categories") @Nullable JsonNullable<List<LinkedTrackingCategory>> trackingCategories,
            @JsonProperty("custom_mappings") @Nullable JsonNullable<Map<String, Object>> customMappings,
            @JsonProperty("custom_fields") @Nullable List<CustomField> customFields,
            @JsonProperty("row_version") @Nullable JsonNullable<String> rowVersion,
            @JsonProperty("updated_by") @Nullable JsonNullable<String> updatedBy,
            @JsonProperty("created_by") @Nullable JsonNullable<String> createdBy,
            @JsonProperty("updated_at") @Nullable JsonNullable<OffsetDateTime> updatedAt,
            @JsonProperty("created_at") @Nullable JsonNullable<OffsetDateTime> createdAt,
            @JsonProperty("pass_through") @Nullable List<PassThroughBody> passThrough) {
        this.id = Optional.ofNullable(id)
            .orElseThrow(() -> new IllegalArgumentException("id cannot be null"));
        this.number = Optional.ofNullable(number)
            .orElse(JsonNullable.undefined());
        this.customer = Optional.ofNullable(customer)
            .orElse(JsonNullable.undefined());
        this.companyId = Optional.ofNullable(companyId)
            .orElse(JsonNullable.undefined());
        this.currency = Optional.ofNullable(currency)
            .orElse(JsonNullable.undefined());
        this.currencyRate = Optional.ofNullable(currencyRate)
            .orElse(JsonNullable.undefined());
        this.taxInclusive = Optional.ofNullable(taxInclusive)
            .orElse(JsonNullable.undefined());
        this.subTotal = Optional.ofNullable(subTotal)
            .orElse(JsonNullable.undefined());
        this.totalAmount = totalAmount;
        this.totalTax = Optional.ofNullable(totalTax)
            .orElse(JsonNullable.undefined());
        this.taxCode = Optional.ofNullable(taxCode)
            .orElse(JsonNullable.undefined());
        this.balance = Optional.ofNullable(balance)
            .orElse(JsonNullable.undefined());
        this.remainingCredit = Optional.ofNullable(remainingCredit)
            .orElse(JsonNullable.undefined());
        this.status = status;
        this.reference = Optional.ofNullable(reference)
            .orElse(JsonNullable.undefined());
        this.dateIssued = dateIssued;
        this.datePaid = Optional.ofNullable(datePaid)
            .orElse(JsonNullable.undefined());
        this.type = type;
        this.account = Optional.ofNullable(account)
            .orElse(JsonNullable.undefined());
        this.lineItems = lineItems;
        this.allocations = allocations;
        this.note = Optional.ofNullable(note)
            .orElse(JsonNullable.undefined());
        this.terms = Optional.ofNullable(terms)
            .orElse(JsonNullable.undefined());
        this.billingAddress = billingAddress;
        this.shippingAddress = shippingAddress;
        this.trackingCategories = Optional.ofNullable(trackingCategories)
            .orElse(JsonNullable.undefined());
        this.customMappings = Optional.ofNullable(customMappings)
            .orElse(JsonNullable.undefined());
        this.customFields = customFields;
        this.rowVersion = Optional.ofNullable(rowVersion)
            .orElse(JsonNullable.undefined());
        this.updatedBy = Optional.ofNullable(updatedBy)
            .orElse(JsonNullable.undefined());
        this.createdBy = Optional.ofNullable(createdBy)
            .orElse(JsonNullable.undefined());
        this.updatedAt = Optional.ofNullable(updatedAt)
            .orElse(JsonNullable.undefined());
        this.createdAt = Optional.ofNullable(createdAt)
            .orElse(JsonNullable.undefined());
        this.passThrough = passThrough;
    }
    
    public CreditNote(
            @Nonnull String id,
            double totalAmount) {
        this(id, null, null,
            null, null, null,
            null, null, totalAmount,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            null);
    }

    /**
     * Unique identifier representing the entity
     */
    public String id() {
        return this.id;
    }

    /**
     * Credit note number.
     */
    public JsonNullable<String> number() {
        return this.number;
    }

    /**
     * The customer this entity is linked to.
     */
    public JsonNullable<LinkedCustomer> customer() {
        return this.customer;
    }

    /**
     * The company or subsidiary id the transaction belongs to
     */
    public JsonNullable<String> companyId() {
        return this.companyId;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    public JsonNullable<Currency> currency() {
        return this.currency;
    }

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    public JsonNullable<Double> currencyRate() {
        return this.currencyRate;
    }

    /**
     * Amounts are including tax
     */
    public JsonNullable<Boolean> taxInclusive() {
        return this.taxInclusive;
    }

    /**
     * Sub-total amount, normally before tax.
     */
    public JsonNullable<Double> subTotal() {
        return this.subTotal;
    }

    /**
     * Amount of transaction
     */
    public double totalAmount() {
        return this.totalAmount;
    }

    /**
     * Total tax amount applied to this invoice.
     */
    public JsonNullable<Double> totalTax() {
        return this.totalTax;
    }

    /**
     * Applicable tax id/code override if tax is not supplied on a line item basis.
     */
    public JsonNullable<String> taxCode() {
        return this.taxCode;
    }

    /**
     * The balance reflecting any payments made against the transaction.
     */
    public JsonNullable<Double> balance() {
        return this.balance;
    }

    /**
     * Indicates the total credit amount still available to apply towards the payment.
     */
    public JsonNullable<Double> remainingCredit() {
        return this.remainingCredit;
    }

    /**
     * Status of credit notes
     */
    public Optional<CreditNoteStatus> status() {
        return Optional.ofNullable(this.status);
    }

    /**
     * Optional reference message ie: Debit remittance detail.
     */
    public JsonNullable<String> reference() {
        return this.reference;
    }

    /**
     * Date credit note issued - YYYY:MM::DDThh:mm:ss.sTZD
     */
    public Optional<OffsetDateTime> dateIssued() {
        return Optional.ofNullable(this.dateIssued);
    }

    /**
     * Date credit note paid - YYYY:MM::DDThh:mm:ss.sTZD
     */
    public JsonNullable<OffsetDateTime> datePaid() {
        return this.datePaid;
    }

    /**
     * Type of payment
     */
    public Optional<CreditNoteType> type() {
        return Optional.ofNullable(this.type);
    }

    public JsonNullable<LinkedLedgerAccount> account() {
        return this.account;
    }

    public Optional<List<InvoiceLineItem>> lineItems() {
        return Optional.ofNullable(this.lineItems);
    }

    public Optional<List<Allocation>> allocations() {
        return Optional.ofNullable(this.allocations);
    }

    /**
     * Optional note to be associated with the credit note.
     */
    public JsonNullable<String> note() {
        return this.note;
    }

    /**
     * Optional terms to be associated with the credit note.
     */
    public JsonNullable<String> terms() {
        return this.terms;
    }

    public Optional<Address> billingAddress() {
        return Optional.ofNullable(this.billingAddress);
    }

    public Optional<Address> shippingAddress() {
        return Optional.ofNullable(this.shippingAddress);
    }

    /**
     * A list of linked tracking categories.
     */
    public JsonNullable<List<LinkedTrackingCategory>> trackingCategories() {
        return this.trackingCategories;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public JsonNullable<Map<String, Object>> customMappings() {
        return this.customMappings;
    }

    public Optional<List<CustomField>> customFields() {
        return Optional.ofNullable(this.customFields);
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    public JsonNullable<String> rowVersion() {
        return this.rowVersion;
    }

    /**
     * The user who last updated the object.
     */
    public JsonNullable<String> updatedBy() {
        return this.updatedBy;
    }

    /**
     * The user who created the object.
     */
    public JsonNullable<String> createdBy() {
        return this.createdBy;
    }

    /**
     * The date and time when the object was last updated.
     */
    public JsonNullable<OffsetDateTime> updatedAt() {
        return this.updatedAt;
    }

    /**
     * The date and time when the object was created.
     */
    public JsonNullable<OffsetDateTime> createdAt() {
        return this.createdAt;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    public Optional<List<PassThroughBody>> passThrough() {
        return Optional.ofNullable(this.passThrough);
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Unique identifier representing the entity
     */
    public CreditNote withId(@Nonnull String id) {
        this.id = Utils.checkNotNull(id, "id");
        return this;
    }


    /**
     * Credit note number.
     */
    public CreditNote withNumber(@Nullable String number) {
        this.number = JsonNullable.of(number);
        return this;
    }


    /**
     * The customer this entity is linked to.
     */
    public CreditNote withCustomer(@Nullable LinkedCustomer customer) {
        this.customer = JsonNullable.of(customer);
        return this;
    }


    /**
     * The company or subsidiary id the transaction belongs to
     */
    public CreditNote withCompanyId(@Nullable String companyId) {
        this.companyId = JsonNullable.of(companyId);
        return this;
    }


    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    public CreditNote withCurrency(@Nullable Currency currency) {
        this.currency = JsonNullable.of(currency);
        return this;
    }


    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    public CreditNote withCurrencyRate(@Nullable Double currencyRate) {
        this.currencyRate = JsonNullable.of(currencyRate);
        return this;
    }


    /**
     * Amounts are including tax
     */
    public CreditNote withTaxInclusive(@Nullable Boolean taxInclusive) {
        this.taxInclusive = JsonNullable.of(taxInclusive);
        return this;
    }


    /**
     * Sub-total amount, normally before tax.
     */
    public CreditNote withSubTotal(@Nullable Double subTotal) {
        this.subTotal = JsonNullable.of(subTotal);
        return this;
    }


    /**
     * Amount of transaction
     */
    public CreditNote withTotalAmount(double totalAmount) {
        this.totalAmount = totalAmount;
        return this;
    }


    /**
     * Total tax amount applied to this invoice.
     */
    public CreditNote withTotalTax(@Nullable Double totalTax) {
        this.totalTax = JsonNullable.of(totalTax);
        return this;
    }


    /**
     * Applicable tax id/code override if tax is not supplied on a line item basis.
     */
    public CreditNote withTaxCode(@Nullable String taxCode) {
        this.taxCode = JsonNullable.of(taxCode);
        return this;
    }


    /**
     * The balance reflecting any payments made against the transaction.
     */
    public CreditNote withBalance(@Nullable Double balance) {
        this.balance = JsonNullable.of(balance);
        return this;
    }


    /**
     * Indicates the total credit amount still available to apply towards the payment.
     */
    public CreditNote withRemainingCredit(@Nullable Double remainingCredit) {
        this.remainingCredit = JsonNullable.of(remainingCredit);
        return this;
    }


    /**
     * Status of credit notes
     */
    public CreditNote withStatus(@Nullable CreditNoteStatus status) {
        this.status = status;
        return this;
    }


    /**
     * Optional reference message ie: Debit remittance detail.
     */
    public CreditNote withReference(@Nullable String reference) {
        this.reference = JsonNullable.of(reference);
        return this;
    }


    /**
     * Date credit note issued - YYYY:MM::DDThh:mm:ss.sTZD
     */
    public CreditNote withDateIssued(@Nullable OffsetDateTime dateIssued) {
        this.dateIssued = dateIssued;
        return this;
    }


    /**
     * Date credit note paid - YYYY:MM::DDThh:mm:ss.sTZD
     */
    public CreditNote withDatePaid(@Nullable OffsetDateTime datePaid) {
        this.datePaid = JsonNullable.of(datePaid);
        return this;
    }


    /**
     * Type of payment
     */
    public CreditNote withType(@Nullable CreditNoteType type) {
        this.type = type;
        return this;
    }


    public CreditNote withAccount(@Nullable LinkedLedgerAccount account) {
        this.account = JsonNullable.of(account);
        return this;
    }


    public CreditNote withLineItems(@Nullable List<InvoiceLineItem> lineItems) {
        this.lineItems = lineItems;
        return this;
    }


    public CreditNote withAllocations(@Nullable List<Allocation> allocations) {
        this.allocations = allocations;
        return this;
    }


    /**
     * Optional note to be associated with the credit note.
     */
    public CreditNote withNote(@Nullable String note) {
        this.note = JsonNullable.of(note);
        return this;
    }


    /**
     * Optional terms to be associated with the credit note.
     */
    public CreditNote withTerms(@Nullable String terms) {
        this.terms = JsonNullable.of(terms);
        return this;
    }


    public CreditNote withBillingAddress(@Nullable Address billingAddress) {
        this.billingAddress = billingAddress;
        return this;
    }


    public CreditNote withShippingAddress(@Nullable Address shippingAddress) {
        this.shippingAddress = shippingAddress;
        return this;
    }


    /**
     * A list of linked tracking categories.
     */
    public CreditNote withTrackingCategories(@Nullable List<LinkedTrackingCategory> trackingCategories) {
        this.trackingCategories = JsonNullable.of(trackingCategories);
        return this;
    }


    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public CreditNote withCustomMappings(@Nullable Map<String, Object> customMappings) {
        this.customMappings = JsonNullable.of(customMappings);
        return this;
    }


    public CreditNote withCustomFields(@Nullable List<CustomField> customFields) {
        this.customFields = customFields;
        return this;
    }


    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    public CreditNote withRowVersion(@Nullable String rowVersion) {
        this.rowVersion = JsonNullable.of(rowVersion);
        return this;
    }


    /**
     * The user who last updated the object.
     */
    public CreditNote withUpdatedBy(@Nullable String updatedBy) {
        this.updatedBy = JsonNullable.of(updatedBy);
        return this;
    }


    /**
     * The user who created the object.
     */
    public CreditNote withCreatedBy(@Nullable String createdBy) {
        this.createdBy = JsonNullable.of(createdBy);
        return this;
    }


    /**
     * The date and time when the object was last updated.
     */
    public CreditNote withUpdatedAt(@Nullable OffsetDateTime updatedAt) {
        this.updatedAt = JsonNullable.of(updatedAt);
        return this;
    }


    /**
     * The date and time when the object was created.
     */
    public CreditNote withCreatedAt(@Nullable OffsetDateTime createdAt) {
        this.createdAt = JsonNullable.of(createdAt);
        return this;
    }


    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    public CreditNote withPassThrough(@Nullable List<PassThroughBody> passThrough) {
        this.passThrough = passThrough;
        return this;
    }


    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        CreditNote other = (CreditNote) o;
        return 
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.number, other.number) &&
            Utils.enhancedDeepEquals(this.customer, other.customer) &&
            Utils.enhancedDeepEquals(this.companyId, other.companyId) &&
            Utils.enhancedDeepEquals(this.currency, other.currency) &&
            Utils.enhancedDeepEquals(this.currencyRate, other.currencyRate) &&
            Utils.enhancedDeepEquals(this.taxInclusive, other.taxInclusive) &&
            Utils.enhancedDeepEquals(this.subTotal, other.subTotal) &&
            Utils.enhancedDeepEquals(this.totalAmount, other.totalAmount) &&
            Utils.enhancedDeepEquals(this.totalTax, other.totalTax) &&
            Utils.enhancedDeepEquals(this.taxCode, other.taxCode) &&
            Utils.enhancedDeepEquals(this.balance, other.balance) &&
            Utils.enhancedDeepEquals(this.remainingCredit, other.remainingCredit) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.reference, other.reference) &&
            Utils.enhancedDeepEquals(this.dateIssued, other.dateIssued) &&
            Utils.enhancedDeepEquals(this.datePaid, other.datePaid) &&
            Utils.enhancedDeepEquals(this.type, other.type) &&
            Utils.enhancedDeepEquals(this.account, other.account) &&
            Utils.enhancedDeepEquals(this.lineItems, other.lineItems) &&
            Utils.enhancedDeepEquals(this.allocations, other.allocations) &&
            Utils.enhancedDeepEquals(this.note, other.note) &&
            Utils.enhancedDeepEquals(this.terms, other.terms) &&
            Utils.enhancedDeepEquals(this.billingAddress, other.billingAddress) &&
            Utils.enhancedDeepEquals(this.shippingAddress, other.shippingAddress) &&
            Utils.enhancedDeepEquals(this.trackingCategories, other.trackingCategories) &&
            Utils.enhancedDeepEquals(this.customMappings, other.customMappings) &&
            Utils.enhancedDeepEquals(this.customFields, other.customFields) &&
            Utils.enhancedDeepEquals(this.rowVersion, other.rowVersion) &&
            Utils.enhancedDeepEquals(this.updatedBy, other.updatedBy) &&
            Utils.enhancedDeepEquals(this.createdBy, other.createdBy) &&
            Utils.enhancedDeepEquals(this.updatedAt, other.updatedAt) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.passThrough, other.passThrough);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            id, number, customer,
            companyId, currency, currencyRate,
            taxInclusive, subTotal, totalAmount,
            totalTax, taxCode, balance,
            remainingCredit, status, reference,
            dateIssued, datePaid, type,
            account, lineItems, allocations,
            note, terms, billingAddress,
            shippingAddress, trackingCategories, customMappings,
            customFields, rowVersion, updatedBy,
            createdBy, updatedAt, createdAt,
            passThrough);
    }
    
    @Override
    public String toString() {
        return Utils.toString(CreditNote.class,
                "id", id,
                "number", number,
                "customer", customer,
                "companyId", companyId,
                "currency", currency,
                "currencyRate", currencyRate,
                "taxInclusive", taxInclusive,
                "subTotal", subTotal,
                "totalAmount", totalAmount,
                "totalTax", totalTax,
                "taxCode", taxCode,
                "balance", balance,
                "remainingCredit", remainingCredit,
                "status", status,
                "reference", reference,
                "dateIssued", dateIssued,
                "datePaid", datePaid,
                "type", type,
                "account", account,
                "lineItems", lineItems,
                "allocations", allocations,
                "note", note,
                "terms", terms,
                "billingAddress", billingAddress,
                "shippingAddress", shippingAddress,
                "trackingCategories", trackingCategories,
                "customMappings", customMappings,
                "customFields", customFields,
                "rowVersion", rowVersion,
                "updatedBy", updatedBy,
                "createdBy", createdBy,
                "updatedAt", updatedAt,
                "createdAt", createdAt,
                "passThrough", passThrough);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private String id;

        private JsonNullable<String> number;

        private JsonNullable<LinkedCustomer> customer;

        private JsonNullable<String> companyId;

        private JsonNullable<Currency> currency;

        private JsonNullable<Double> currencyRate;

        private JsonNullable<Boolean> taxInclusive;

        private JsonNullable<Double> subTotal;

        private double totalAmount;

        private JsonNullable<Double> totalTax;

        private JsonNullable<String> taxCode;

        private JsonNullable<Double> balance;

        private JsonNullable<Double> remainingCredit;

        private CreditNoteStatus status;

        private JsonNullable<String> reference;

        private OffsetDateTime dateIssued;

        private JsonNullable<OffsetDateTime> datePaid;

        private CreditNoteType type;

        private JsonNullable<LinkedLedgerAccount> account;

        private List<InvoiceLineItem> lineItems;

        private List<Allocation> allocations;

        private JsonNullable<String> note;

        private JsonNullable<String> terms;

        private Address billingAddress;

        private Address shippingAddress;

        private JsonNullable<List<LinkedTrackingCategory>> trackingCategories;

        private JsonNullable<Map<String, Object>> customMappings;

        private List<CustomField> customFields;

        private JsonNullable<String> rowVersion;

        private JsonNullable<String> updatedBy;

        private JsonNullable<String> createdBy;

        private JsonNullable<OffsetDateTime> updatedAt;

        private JsonNullable<OffsetDateTime> createdAt;

        private List<PassThroughBody> passThrough;

        private Builder() {
          // force use of static builder() method
        }

        /**
         * Unique identifier representing the entity
         */
        public Builder id(@Nonnull String id) {
            this.id = Utils.checkNotNull(id, "id");
            return this;
        }

        /**
         * Credit note number.
         */
        public Builder number(@Nullable String number) {
            this.number = JsonNullable.of(number);
            return this;
        }

        /**
         * The customer this entity is linked to.
         */
        public Builder customer(@Nullable LinkedCustomer customer) {
            this.customer = JsonNullable.of(customer);
            return this;
        }

        /**
         * The company or subsidiary id the transaction belongs to
         */
        public Builder companyId(@Nullable String companyId) {
            this.companyId = JsonNullable.of(companyId);
            return this;
        }

        /**
         * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
         */
        public Builder currency(@Nullable Currency currency) {
            this.currency = JsonNullable.of(currency);
            return this;
        }

        /**
         * Currency Exchange Rate at the time entity was recorded/generated.
         */
        public Builder currencyRate(@Nullable Double currencyRate) {
            this.currencyRate = JsonNullable.of(currencyRate);
            return this;
        }

        /**
         * Amounts are including tax
         */
        public Builder taxInclusive(@Nullable Boolean taxInclusive) {
            this.taxInclusive = JsonNullable.of(taxInclusive);
            return this;
        }

        /**
         * Sub-total amount, normally before tax.
         */
        public Builder subTotal(@Nullable Double subTotal) {
            this.subTotal = JsonNullable.of(subTotal);
            return this;
        }

        /**
         * Amount of transaction
         */
        public Builder totalAmount(double totalAmount) {
            this.totalAmount = totalAmount;
            return this;
        }

        /**
         * Total tax amount applied to this invoice.
         */
        public Builder totalTax(@Nullable Double totalTax) {
            this.totalTax = JsonNullable.of(totalTax);
            return this;
        }

        /**
         * Applicable tax id/code override if tax is not supplied on a line item basis.
         */
        public Builder taxCode(@Nullable String taxCode) {
            this.taxCode = JsonNullable.of(taxCode);
            return this;
        }

        /**
         * The balance reflecting any payments made against the transaction.
         */
        public Builder balance(@Nullable Double balance) {
            this.balance = JsonNullable.of(balance);
            return this;
        }

        /**
         * Indicates the total credit amount still available to apply towards the payment.
         */
        public Builder remainingCredit(@Nullable Double remainingCredit) {
            this.remainingCredit = JsonNullable.of(remainingCredit);
            return this;
        }

        /**
         * Status of credit notes
         */
        public Builder status(@Nullable CreditNoteStatus status) {
            this.status = status;
            return this;
        }

        /**
         * Optional reference message ie: Debit remittance detail.
         */
        public Builder reference(@Nullable String reference) {
            this.reference = JsonNullable.of(reference);
            return this;
        }

        /**
         * Date credit note issued - YYYY:MM::DDThh:mm:ss.sTZD
         */
        public Builder dateIssued(@Nullable OffsetDateTime dateIssued) {
            this.dateIssued = dateIssued;
            return this;
        }

        /**
         * Date credit note paid - YYYY:MM::DDThh:mm:ss.sTZD
         */
        public Builder datePaid(@Nullable OffsetDateTime datePaid) {
            this.datePaid = JsonNullable.of(datePaid);
            return this;
        }

        /**
         * Type of payment
         */
        public Builder type(@Nullable CreditNoteType type) {
            this.type = type;
            return this;
        }

        public Builder account(@Nullable LinkedLedgerAccount account) {
            this.account = JsonNullable.of(account);
            return this;
        }

        public Builder lineItems(@Nullable List<InvoiceLineItem> lineItems) {
            this.lineItems = lineItems;
            return this;
        }

        public Builder allocations(@Nullable List<Allocation> allocations) {
            this.allocations = allocations;
            return this;
        }

        /**
         * Optional note to be associated with the credit note.
         */
        public Builder note(@Nullable String note) {
            this.note = JsonNullable.of(note);
            return this;
        }

        /**
         * Optional terms to be associated with the credit note.
         */
        public Builder terms(@Nullable String terms) {
            this.terms = JsonNullable.of(terms);
            return this;
        }

        public Builder billingAddress(@Nullable Address billingAddress) {
            this.billingAddress = billingAddress;
            return this;
        }

        public Builder shippingAddress(@Nullable Address shippingAddress) {
            this.shippingAddress = shippingAddress;
            return this;
        }

        /**
         * A list of linked tracking categories.
         */
        public Builder trackingCategories(@Nullable List<LinkedTrackingCategory> trackingCategories) {
            this.trackingCategories = JsonNullable.of(trackingCategories);
            return this;
        }

        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(@Nullable Map<String, Object> customMappings) {
            this.customMappings = JsonNullable.of(customMappings);
            return this;
        }

        public Builder customFields(@Nullable List<CustomField> customFields) {
            this.customFields = customFields;
            return this;
        }

        /**
         * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
         */
        public Builder rowVersion(@Nullable String rowVersion) {
            this.rowVersion = JsonNullable.of(rowVersion);
            return this;
        }

        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(@Nullable String updatedBy) {
            this.updatedBy = JsonNullable.of(updatedBy);
            return this;
        }

        /**
         * The user who created the object.
         */
        public Builder createdBy(@Nullable String createdBy) {
            this.createdBy = JsonNullable.of(createdBy);
            return this;
        }

        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(@Nullable OffsetDateTime updatedAt) {
            this.updatedAt = JsonNullable.of(updatedAt);
            return this;
        }

        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(@Nullable OffsetDateTime createdAt) {
            this.createdAt = JsonNullable.of(createdAt);
            return this;
        }

        /**
         * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
         */
        public Builder passThrough(@Nullable List<PassThroughBody> passThrough) {
            this.passThrough = passThrough;
            return this;
        }

        public CreditNote build() {
            return new CreditNote(
                id, number, customer,
                companyId, currency, currencyRate,
                taxInclusive, subTotal, totalAmount,
                totalTax, taxCode, balance,
                remainingCredit, status, reference,
                dateIssued, datePaid, type,
                account, lineItems, allocations,
                note, terms, billingAddress,
                shippingAddress, trackingCategories, customMappings,
                customFields, rowVersion, updatedBy,
                createdBy, updatedAt, createdAt,
                passThrough);
        }

    }
}
