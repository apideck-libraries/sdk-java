/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.apideck.unify.models.components;

import com.apideck.unify.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.annotation.Nonnull;
import jakarta.annotation.Nullable;
import java.lang.Double;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class Expense {
    /**
     * A unique identifier for an object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private String id;

    /**
     * Number.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("number")
    private JsonNullable<String> number;

    /**
     * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("transaction_date")
    private JsonNullable<OffsetDateTime> transactionDate;

    /**
     * The unique identifier for the ledger account that this expense should be credited to.
     */
    @JsonProperty("account_id")
    private String accountId;

    /**
     * The ID of the customer this entity is linked to. Used for expenses that should be marked as billable to customers.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("customer_id")
    private String customerId;

    /**
     * The ID of the supplier this entity is linked to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supplier_id")
    private String supplierId;

    /**
     * The company or subsidiary id the transaction belongs to
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("company_id")
    private JsonNullable<String> companyId;

    /**
     * The ID of the department
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("department_id")
    private JsonNullable<String> departmentId;

    /**
     * The type of payment for the expense.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payment_type")
    private JsonNullable<ExpensePaymentType> paymentType;

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency")
    private JsonNullable<Currency> currency;

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency_rate")
    private JsonNullable<Double> currencyRate;

    /**
     * The type of expense.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("type")
    private JsonNullable<ExpenseType> type;

    /**
     * The memo of the expense.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("memo")
    private JsonNullable<String> memo;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tax_rate")
    private LinkedTaxRate taxRate;

    /**
     * The total amount of the expense line item.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("total_amount")
    private JsonNullable<Double> totalAmount;

    /**
     * Expense line items linked to this expense.
     */
    @JsonProperty("line_items")
    private List<ExpenseLineItem> lineItems;

    /**
     * Optional reference identifier for the transaction.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("reference")
    private JsonNullable<String> reference;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_fields")
    private List<CustomField> customFields;

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_mappings")
    private JsonNullable<Map<String, Object>> customMappings;

    /**
     * The date and time when the object was last updated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_at")
    private JsonNullable<OffsetDateTime> updatedAt;

    /**
     * The date and time when the object was created.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_at")
    private JsonNullable<OffsetDateTime> createdAt;

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("row_version")
    private JsonNullable<String> rowVersion;

    /**
     * The user who last updated the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_by")
    private JsonNullable<String> updatedBy;

    /**
     * The user who created the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_by")
    private JsonNullable<String> createdBy;

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pass_through")
    private List<PassThroughBody> passThrough;

    @JsonCreator
    public Expense(
            @JsonProperty("id") @Nullable String id,
            @JsonProperty("number") @Nullable JsonNullable<String> number,
            @JsonProperty("transaction_date") @Nullable OffsetDateTime transactionDate,
            @JsonProperty("account_id") @Nonnull String accountId,
            @JsonProperty("customer_id") @Nullable String customerId,
            @JsonProperty("supplier_id") @Nullable String supplierId,
            @JsonProperty("company_id") @Nullable JsonNullable<String> companyId,
            @JsonProperty("department_id") @Nullable JsonNullable<String> departmentId,
            @JsonProperty("payment_type") @Nullable JsonNullable<ExpensePaymentType> paymentType,
            @JsonProperty("currency") @Nullable JsonNullable<Currency> currency,
            @JsonProperty("currency_rate") @Nullable JsonNullable<Double> currencyRate,
            @JsonProperty("type") @Nullable JsonNullable<ExpenseType> type,
            @JsonProperty("memo") @Nullable JsonNullable<String> memo,
            @JsonProperty("tax_rate") @Nullable LinkedTaxRate taxRate,
            @JsonProperty("total_amount") @Nullable JsonNullable<Double> totalAmount,
            @JsonProperty("line_items") @Nonnull List<ExpenseLineItem> lineItems,
            @JsonProperty("reference") @Nullable JsonNullable<String> reference,
            @JsonProperty("custom_fields") @Nullable List<CustomField> customFields,
            @JsonProperty("custom_mappings") @Nullable JsonNullable<Map<String, Object>> customMappings,
            @JsonProperty("updated_at") @Nullable JsonNullable<OffsetDateTime> updatedAt,
            @JsonProperty("created_at") @Nullable JsonNullable<OffsetDateTime> createdAt,
            @JsonProperty("row_version") @Nullable JsonNullable<String> rowVersion,
            @JsonProperty("updated_by") @Nullable JsonNullable<String> updatedBy,
            @JsonProperty("created_by") @Nullable JsonNullable<String> createdBy,
            @JsonProperty("pass_through") @Nullable List<PassThroughBody> passThrough) {
        this.id = id;
        this.number = Optional.ofNullable(number)
            .orElse(JsonNullable.undefined());
        this.transactionDate = JsonNullable.of(transactionDate);
        this.accountId = Optional.ofNullable(accountId)
            .orElseThrow(() -> new IllegalArgumentException("accountId cannot be null"));
        this.customerId = customerId;
        this.supplierId = supplierId;
        this.companyId = Optional.ofNullable(companyId)
            .orElse(JsonNullable.undefined());
        this.departmentId = Optional.ofNullable(departmentId)
            .orElse(JsonNullable.undefined());
        this.paymentType = Optional.ofNullable(paymentType)
            .orElse(JsonNullable.undefined());
        this.currency = Optional.ofNullable(currency)
            .orElse(JsonNullable.undefined());
        this.currencyRate = Optional.ofNullable(currencyRate)
            .orElse(JsonNullable.undefined());
        this.type = Optional.ofNullable(type)
            .orElse(JsonNullable.undefined());
        this.memo = Optional.ofNullable(memo)
            .orElse(JsonNullable.undefined());
        this.taxRate = taxRate;
        this.totalAmount = Optional.ofNullable(totalAmount)
            .orElse(JsonNullable.undefined());
        this.lineItems = Optional.ofNullable(lineItems)
            .orElseThrow(() -> new IllegalArgumentException("lineItems cannot be null"));
        this.reference = Optional.ofNullable(reference)
            .orElse(JsonNullable.undefined());
        this.customFields = customFields;
        this.customMappings = Optional.ofNullable(customMappings)
            .orElse(JsonNullable.undefined());
        this.updatedAt = Optional.ofNullable(updatedAt)
            .orElse(JsonNullable.undefined());
        this.createdAt = Optional.ofNullable(createdAt)
            .orElse(JsonNullable.undefined());
        this.rowVersion = Optional.ofNullable(rowVersion)
            .orElse(JsonNullable.undefined());
        this.updatedBy = Optional.ofNullable(updatedBy)
            .orElse(JsonNullable.undefined());
        this.createdBy = Optional.ofNullable(createdBy)
            .orElse(JsonNullable.undefined());
        this.passThrough = passThrough;
    }
    
    public Expense(
            @Nonnull String accountId,
            @Nonnull List<ExpenseLineItem> lineItems) {
        this(null, null, null,
            accountId, null, null,
            null, null, null,
            null, null, null,
            null, null, null,
            lineItems, null, null,
            null, null, null,
            null, null, null,
            null);
    }

    /**
     * A unique identifier for an object.
     */
    public Optional<String> id() {
        return Optional.ofNullable(this.id);
    }

    /**
     * Number.
     */
    public JsonNullable<String> number() {
        return this.number;
    }

    /**
     * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
     */
    public JsonNullable<OffsetDateTime> transactionDate() {
        return this.transactionDate;
    }

    /**
     * The unique identifier for the ledger account that this expense should be credited to.
     */
    public String accountId() {
        return this.accountId;
    }

    /**
     * The ID of the customer this entity is linked to. Used for expenses that should be marked as billable to customers.
     */
    public Optional<String> customerId() {
        return Optional.ofNullable(this.customerId);
    }

    /**
     * The ID of the supplier this entity is linked to.
     */
    public Optional<String> supplierId() {
        return Optional.ofNullable(this.supplierId);
    }

    /**
     * The company or subsidiary id the transaction belongs to
     */
    public JsonNullable<String> companyId() {
        return this.companyId;
    }

    /**
     * The ID of the department
     */
    public JsonNullable<String> departmentId() {
        return this.departmentId;
    }

    /**
     * The type of payment for the expense.
     */
    public JsonNullable<ExpensePaymentType> paymentType() {
        return this.paymentType;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    public JsonNullable<Currency> currency() {
        return this.currency;
    }

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    public JsonNullable<Double> currencyRate() {
        return this.currencyRate;
    }

    /**
     * The type of expense.
     */
    public JsonNullable<ExpenseType> type() {
        return this.type;
    }

    /**
     * The memo of the expense.
     */
    public JsonNullable<String> memo() {
        return this.memo;
    }

    public Optional<LinkedTaxRate> taxRate() {
        return Optional.ofNullable(this.taxRate);
    }

    /**
     * The total amount of the expense line item.
     */
    public JsonNullable<Double> totalAmount() {
        return this.totalAmount;
    }

    /**
     * Expense line items linked to this expense.
     */
    public List<ExpenseLineItem> lineItems() {
        return this.lineItems;
    }

    /**
     * Optional reference identifier for the transaction.
     */
    public JsonNullable<String> reference() {
        return this.reference;
    }

    public Optional<List<CustomField>> customFields() {
        return Optional.ofNullable(this.customFields);
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public JsonNullable<Map<String, Object>> customMappings() {
        return this.customMappings;
    }

    /**
     * The date and time when the object was last updated.
     */
    public JsonNullable<OffsetDateTime> updatedAt() {
        return this.updatedAt;
    }

    /**
     * The date and time when the object was created.
     */
    public JsonNullable<OffsetDateTime> createdAt() {
        return this.createdAt;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    public JsonNullable<String> rowVersion() {
        return this.rowVersion;
    }

    /**
     * The user who last updated the object.
     */
    public JsonNullable<String> updatedBy() {
        return this.updatedBy;
    }

    /**
     * The user who created the object.
     */
    public JsonNullable<String> createdBy() {
        return this.createdBy;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    public Optional<List<PassThroughBody>> passThrough() {
        return Optional.ofNullable(this.passThrough);
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * A unique identifier for an object.
     */
    public Expense withId(@Nullable String id) {
        this.id = id;
        return this;
    }


    /**
     * Number.
     */
    public Expense withNumber(@Nullable String number) {
        this.number = JsonNullable.of(number);
        return this;
    }


    /**
     * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
     */
    public Expense withTransactionDate(@Nullable OffsetDateTime transactionDate) {
        this.transactionDate = JsonNullable.of(transactionDate);
        return this;
    }


    /**
     * The unique identifier for the ledger account that this expense should be credited to.
     */
    public Expense withAccountId(@Nonnull String accountId) {
        this.accountId = Utils.checkNotNull(accountId, "accountId");
        return this;
    }


    /**
     * The ID of the customer this entity is linked to. Used for expenses that should be marked as billable to customers.
     */
    public Expense withCustomerId(@Nullable String customerId) {
        this.customerId = customerId;
        return this;
    }


    /**
     * The ID of the supplier this entity is linked to.
     */
    public Expense withSupplierId(@Nullable String supplierId) {
        this.supplierId = supplierId;
        return this;
    }


    /**
     * The company or subsidiary id the transaction belongs to
     */
    public Expense withCompanyId(@Nullable String companyId) {
        this.companyId = JsonNullable.of(companyId);
        return this;
    }


    /**
     * The ID of the department
     */
    public Expense withDepartmentId(@Nullable String departmentId) {
        this.departmentId = JsonNullable.of(departmentId);
        return this;
    }


    /**
     * The type of payment for the expense.
     */
    public Expense withPaymentType(@Nullable ExpensePaymentType paymentType) {
        this.paymentType = JsonNullable.of(paymentType);
        return this;
    }


    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    public Expense withCurrency(@Nullable Currency currency) {
        this.currency = JsonNullable.of(currency);
        return this;
    }


    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    public Expense withCurrencyRate(@Nullable Double currencyRate) {
        this.currencyRate = JsonNullable.of(currencyRate);
        return this;
    }


    /**
     * The type of expense.
     */
    public Expense withType(@Nullable ExpenseType type) {
        this.type = JsonNullable.of(type);
        return this;
    }


    /**
     * The memo of the expense.
     */
    public Expense withMemo(@Nullable String memo) {
        this.memo = JsonNullable.of(memo);
        return this;
    }


    public Expense withTaxRate(@Nullable LinkedTaxRate taxRate) {
        this.taxRate = taxRate;
        return this;
    }


    /**
     * The total amount of the expense line item.
     */
    public Expense withTotalAmount(@Nullable Double totalAmount) {
        this.totalAmount = JsonNullable.of(totalAmount);
        return this;
    }


    /**
     * Expense line items linked to this expense.
     */
    public Expense withLineItems(@Nonnull List<ExpenseLineItem> lineItems) {
        this.lineItems = Utils.checkNotNull(lineItems, "lineItems");
        return this;
    }


    /**
     * Optional reference identifier for the transaction.
     */
    public Expense withReference(@Nullable String reference) {
        this.reference = JsonNullable.of(reference);
        return this;
    }


    public Expense withCustomFields(@Nullable List<CustomField> customFields) {
        this.customFields = customFields;
        return this;
    }


    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public Expense withCustomMappings(@Nullable Map<String, Object> customMappings) {
        this.customMappings = JsonNullable.of(customMappings);
        return this;
    }


    /**
     * The date and time when the object was last updated.
     */
    public Expense withUpdatedAt(@Nullable OffsetDateTime updatedAt) {
        this.updatedAt = JsonNullable.of(updatedAt);
        return this;
    }


    /**
     * The date and time when the object was created.
     */
    public Expense withCreatedAt(@Nullable OffsetDateTime createdAt) {
        this.createdAt = JsonNullable.of(createdAt);
        return this;
    }


    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    public Expense withRowVersion(@Nullable String rowVersion) {
        this.rowVersion = JsonNullable.of(rowVersion);
        return this;
    }


    /**
     * The user who last updated the object.
     */
    public Expense withUpdatedBy(@Nullable String updatedBy) {
        this.updatedBy = JsonNullable.of(updatedBy);
        return this;
    }


    /**
     * The user who created the object.
     */
    public Expense withCreatedBy(@Nullable String createdBy) {
        this.createdBy = JsonNullable.of(createdBy);
        return this;
    }


    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    public Expense withPassThrough(@Nullable List<PassThroughBody> passThrough) {
        this.passThrough = passThrough;
        return this;
    }


    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Expense other = (Expense) o;
        return 
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.number, other.number) &&
            Utils.enhancedDeepEquals(this.transactionDate, other.transactionDate) &&
            Utils.enhancedDeepEquals(this.accountId, other.accountId) &&
            Utils.enhancedDeepEquals(this.customerId, other.customerId) &&
            Utils.enhancedDeepEquals(this.supplierId, other.supplierId) &&
            Utils.enhancedDeepEquals(this.companyId, other.companyId) &&
            Utils.enhancedDeepEquals(this.departmentId, other.departmentId) &&
            Utils.enhancedDeepEquals(this.paymentType, other.paymentType) &&
            Utils.enhancedDeepEquals(this.currency, other.currency) &&
            Utils.enhancedDeepEquals(this.currencyRate, other.currencyRate) &&
            Utils.enhancedDeepEquals(this.type, other.type) &&
            Utils.enhancedDeepEquals(this.memo, other.memo) &&
            Utils.enhancedDeepEquals(this.taxRate, other.taxRate) &&
            Utils.enhancedDeepEquals(this.totalAmount, other.totalAmount) &&
            Utils.enhancedDeepEquals(this.lineItems, other.lineItems) &&
            Utils.enhancedDeepEquals(this.reference, other.reference) &&
            Utils.enhancedDeepEquals(this.customFields, other.customFields) &&
            Utils.enhancedDeepEquals(this.customMappings, other.customMappings) &&
            Utils.enhancedDeepEquals(this.updatedAt, other.updatedAt) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.rowVersion, other.rowVersion) &&
            Utils.enhancedDeepEquals(this.updatedBy, other.updatedBy) &&
            Utils.enhancedDeepEquals(this.createdBy, other.createdBy) &&
            Utils.enhancedDeepEquals(this.passThrough, other.passThrough);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            id, number, transactionDate,
            accountId, customerId, supplierId,
            companyId, departmentId, paymentType,
            currency, currencyRate, type,
            memo, taxRate, totalAmount,
            lineItems, reference, customFields,
            customMappings, updatedAt, createdAt,
            rowVersion, updatedBy, createdBy,
            passThrough);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Expense.class,
                "id", id,
                "number", number,
                "transactionDate", transactionDate,
                "accountId", accountId,
                "customerId", customerId,
                "supplierId", supplierId,
                "companyId", companyId,
                "departmentId", departmentId,
                "paymentType", paymentType,
                "currency", currency,
                "currencyRate", currencyRate,
                "type", type,
                "memo", memo,
                "taxRate", taxRate,
                "totalAmount", totalAmount,
                "lineItems", lineItems,
                "reference", reference,
                "customFields", customFields,
                "customMappings", customMappings,
                "updatedAt", updatedAt,
                "createdAt", createdAt,
                "rowVersion", rowVersion,
                "updatedBy", updatedBy,
                "createdBy", createdBy,
                "passThrough", passThrough);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private String id;

        private JsonNullable<String> number;

        private OffsetDateTime transactionDate;

        private String accountId;

        private String customerId;

        private String supplierId;

        private JsonNullable<String> companyId;

        private JsonNullable<String> departmentId;

        private JsonNullable<ExpensePaymentType> paymentType;

        private JsonNullable<Currency> currency;

        private JsonNullable<Double> currencyRate;

        private JsonNullable<ExpenseType> type;

        private JsonNullable<String> memo;

        private LinkedTaxRate taxRate;

        private JsonNullable<Double> totalAmount;

        private List<ExpenseLineItem> lineItems;

        private JsonNullable<String> reference;

        private List<CustomField> customFields;

        private JsonNullable<Map<String, Object>> customMappings;

        private JsonNullable<OffsetDateTime> updatedAt;

        private JsonNullable<OffsetDateTime> createdAt;

        private JsonNullable<String> rowVersion;

        private JsonNullable<String> updatedBy;

        private JsonNullable<String> createdBy;

        private List<PassThroughBody> passThrough;

        private Builder() {
          // force use of static builder() method
        }

        /**
         * A unique identifier for an object.
         */
        public Builder id(@Nullable String id) {
            this.id = id;
            return this;
        }

        /**
         * Number.
         */
        public Builder number(@Nullable String number) {
            this.number = JsonNullable.of(number);
            return this;
        }

        /**
         * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
         */
        public Builder transactionDate(@Nullable OffsetDateTime transactionDate) {
            this.transactionDate = transactionDate;
            return this;
        }

        /**
         * The unique identifier for the ledger account that this expense should be credited to.
         */
        public Builder accountId(@Nonnull String accountId) {
            this.accountId = Utils.checkNotNull(accountId, "accountId");
            return this;
        }

        /**
         * The ID of the customer this entity is linked to. Used for expenses that should be marked as billable to customers.
         */
        public Builder customerId(@Nullable String customerId) {
            this.customerId = customerId;
            return this;
        }

        /**
         * The ID of the supplier this entity is linked to.
         */
        public Builder supplierId(@Nullable String supplierId) {
            this.supplierId = supplierId;
            return this;
        }

        /**
         * The company or subsidiary id the transaction belongs to
         */
        public Builder companyId(@Nullable String companyId) {
            this.companyId = JsonNullable.of(companyId);
            return this;
        }

        /**
         * The ID of the department
         */
        public Builder departmentId(@Nullable String departmentId) {
            this.departmentId = JsonNullable.of(departmentId);
            return this;
        }

        /**
         * The type of payment for the expense.
         */
        public Builder paymentType(@Nullable ExpensePaymentType paymentType) {
            this.paymentType = JsonNullable.of(paymentType);
            return this;
        }

        /**
         * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
         */
        public Builder currency(@Nullable Currency currency) {
            this.currency = JsonNullable.of(currency);
            return this;
        }

        /**
         * Currency Exchange Rate at the time entity was recorded/generated.
         */
        public Builder currencyRate(@Nullable Double currencyRate) {
            this.currencyRate = JsonNullable.of(currencyRate);
            return this;
        }

        /**
         * The type of expense.
         */
        public Builder type(@Nullable ExpenseType type) {
            this.type = JsonNullable.of(type);
            return this;
        }

        /**
         * The memo of the expense.
         */
        public Builder memo(@Nullable String memo) {
            this.memo = JsonNullable.of(memo);
            return this;
        }

        public Builder taxRate(@Nullable LinkedTaxRate taxRate) {
            this.taxRate = taxRate;
            return this;
        }

        /**
         * The total amount of the expense line item.
         */
        public Builder totalAmount(@Nullable Double totalAmount) {
            this.totalAmount = JsonNullable.of(totalAmount);
            return this;
        }

        /**
         * Expense line items linked to this expense.
         */
        public Builder lineItems(@Nonnull List<ExpenseLineItem> lineItems) {
            this.lineItems = Utils.checkNotNull(lineItems, "lineItems");
            return this;
        }

        /**
         * Optional reference identifier for the transaction.
         */
        public Builder reference(@Nullable String reference) {
            this.reference = JsonNullable.of(reference);
            return this;
        }

        public Builder customFields(@Nullable List<CustomField> customFields) {
            this.customFields = customFields;
            return this;
        }

        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(@Nullable Map<String, Object> customMappings) {
            this.customMappings = JsonNullable.of(customMappings);
            return this;
        }

        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(@Nullable OffsetDateTime updatedAt) {
            this.updatedAt = JsonNullable.of(updatedAt);
            return this;
        }

        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(@Nullable OffsetDateTime createdAt) {
            this.createdAt = JsonNullable.of(createdAt);
            return this;
        }

        /**
         * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
         */
        public Builder rowVersion(@Nullable String rowVersion) {
            this.rowVersion = JsonNullable.of(rowVersion);
            return this;
        }

        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(@Nullable String updatedBy) {
            this.updatedBy = JsonNullable.of(updatedBy);
            return this;
        }

        /**
         * The user who created the object.
         */
        public Builder createdBy(@Nullable String createdBy) {
            this.createdBy = JsonNullable.of(createdBy);
            return this;
        }

        /**
         * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
         */
        public Builder passThrough(@Nullable List<PassThroughBody> passThrough) {
            this.passThrough = passThrough;
            return this;
        }

        public Expense build() {
            return new Expense(
                id, number, transactionDate,
                accountId, customerId, supplierId,
                companyId, departmentId, paymentType,
                currency, currencyRate, type,
                memo, taxRate, totalAmount,
                lineItems, reference, customFields,
                customMappings, updatedAt, createdAt,
                rowVersion, updatedBy, createdBy,
                passThrough);
        }

    }
}
