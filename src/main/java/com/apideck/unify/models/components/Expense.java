/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.apideck.unify.models.components;

import com.apideck.unify.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Boolean;
import java.lang.Deprecated;
import java.lang.Double;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class Expense {
    /**
     * A unique identifier for an object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * Id to be displayed.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("display_id")
    private JsonNullable<String> displayId;

    /**
     * Number.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("number")
    private JsonNullable<String> number;

    /**
     * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("transaction_date")
    private Optional<OffsetDateTime> transactionDate;

    /**
     * The unique identifier for the ledger account that this expense should be credited to. Deprecated,
     * use account instead.
     * 
     * @deprecated field: Deprecated. Use account instead..
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("account_id")
    @Deprecated
    private Optional<String> accountId;

    /**
     * A flexible account reference that can represent either a ledger account (GL account) or a bank
     * account, depending on the connector's requirements.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("account")
    private JsonNullable<? extends LinkedFinancialAccount> account;

    /**
     * The ID of the supplier this entity is linked to. Deprecated, use supplier instead.
     * 
     * @deprecated field: Deprecated. Use supplier instead..
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supplier_id")
    @Deprecated
    private Optional<String> supplierId;

    /**
     * The supplier this entity is linked to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supplier")
    private JsonNullable<? extends LinkedSupplier> supplier;

    /**
     * The company ID the transaction belongs to
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("company_id")
    private JsonNullable<String> companyId;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("location")
    private JsonNullable<? extends LinkedLocation> location;

    /**
     * The ID of the department
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("department_id")
    private JsonNullable<String> departmentId;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("department")
    private JsonNullable<? extends LinkedDepartment> department;

    /**
     * The type of payment for the expense.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payment_type")
    private JsonNullable<? extends ExpensePaymentType> paymentType;

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO
     * 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency")
    private JsonNullable<? extends Currency> currency;

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency_rate")
    private JsonNullable<Double> currencyRate;

    /**
     * The type of expense.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("type")
    private JsonNullable<? extends ExpenseType> type;

    /**
     * The memo of the expense.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("memo")
    private JsonNullable<String> memo;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tax_rate")
    private Optional<? extends LinkedTaxRate> taxRate;

    /**
     * Amounts are including tax
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tax_inclusive")
    private JsonNullable<Boolean> taxInclusive;

    /**
     * Subtotal amount, normally before tax.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sub_total")
    private JsonNullable<Double> subTotal;

    /**
     * Total tax amount applied to this transaction.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("total_tax")
    private JsonNullable<Double> totalTax;

    /**
     * The total amount of the expense line item.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("total_amount")
    private JsonNullable<Double> totalAmount;

    /**
     * A list of linked tracking categories.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tracking_categories")
    private JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories;

    /**
     * Expense line items linked to this expense.
     */
    @JsonProperty("line_items")
    private List<ExpenseLineItem> lineItems;

    /**
     * Optional reference identifier for the transaction.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("reference")
    private JsonNullable<String> reference;

    /**
     * URL link to a source document - shown as 'Go to [appName]' in the downstream app. Currently only
     * supported for Xero.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("source_document_url")
    private JsonNullable<String> sourceDocumentUrl;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_fields")
    private Optional<? extends List<CustomField>> customFields;

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_mappings")
    private JsonNullable<? extends Map<String, Object>> customMappings;

    /**
     * Expense status
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private JsonNullable<? extends ExpenseStatus> status;

    /**
     * The date and time when the object was last updated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_at")
    private JsonNullable<OffsetDateTime> updatedAt;

    /**
     * The date and time when the object was created.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_at")
    private JsonNullable<OffsetDateTime> createdAt;

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each
     * time an update is made to the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("row_version")
    private JsonNullable<String> rowVersion;

    /**
     * The user who last updated the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_by")
    private JsonNullable<String> updatedBy;

    /**
     * The user who created the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_by")
    private JsonNullable<String> createdBy;

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications
     * in request body when creating or updating resources.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pass_through")
    private Optional<? extends List<PassThroughBody>> passThrough;

    @JsonCreator
    public Expense(
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("display_id") JsonNullable<String> displayId,
            @JsonProperty("number") JsonNullable<String> number,
            @JsonProperty("transaction_date") Optional<OffsetDateTime> transactionDate,
            @JsonProperty("account_id") Optional<String> accountId,
            @JsonProperty("account") JsonNullable<? extends LinkedFinancialAccount> account,
            @JsonProperty("supplier_id") Optional<String> supplierId,
            @JsonProperty("supplier") JsonNullable<? extends LinkedSupplier> supplier,
            @JsonProperty("company_id") JsonNullable<String> companyId,
            @JsonProperty("location") JsonNullable<? extends LinkedLocation> location,
            @JsonProperty("department_id") JsonNullable<String> departmentId,
            @JsonProperty("department") JsonNullable<? extends LinkedDepartment> department,
            @JsonProperty("payment_type") JsonNullable<? extends ExpensePaymentType> paymentType,
            @JsonProperty("currency") JsonNullable<? extends Currency> currency,
            @JsonProperty("currency_rate") JsonNullable<Double> currencyRate,
            @JsonProperty("type") JsonNullable<? extends ExpenseType> type,
            @JsonProperty("memo") JsonNullable<String> memo,
            @JsonProperty("tax_rate") Optional<? extends LinkedTaxRate> taxRate,
            @JsonProperty("tax_inclusive") JsonNullable<Boolean> taxInclusive,
            @JsonProperty("sub_total") JsonNullable<Double> subTotal,
            @JsonProperty("total_tax") JsonNullable<Double> totalTax,
            @JsonProperty("total_amount") JsonNullable<Double> totalAmount,
            @JsonProperty("tracking_categories") JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories,
            @JsonProperty("line_items") List<ExpenseLineItem> lineItems,
            @JsonProperty("reference") JsonNullable<String> reference,
            @JsonProperty("source_document_url") JsonNullable<String> sourceDocumentUrl,
            @JsonProperty("custom_fields") Optional<? extends List<CustomField>> customFields,
            @JsonProperty("custom_mappings") JsonNullable<? extends Map<String, Object>> customMappings,
            @JsonProperty("status") JsonNullable<? extends ExpenseStatus> status,
            @JsonProperty("updated_at") JsonNullable<OffsetDateTime> updatedAt,
            @JsonProperty("created_at") JsonNullable<OffsetDateTime> createdAt,
            @JsonProperty("row_version") JsonNullable<String> rowVersion,
            @JsonProperty("updated_by") JsonNullable<String> updatedBy,
            @JsonProperty("created_by") JsonNullable<String> createdBy,
            @JsonProperty("pass_through") Optional<? extends List<PassThroughBody>> passThrough) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(displayId, "displayId");
        Utils.checkNotNull(number, "number");
        Utils.checkNotNull(transactionDate, "transactionDate");
        Utils.checkNotNull(accountId, "accountId");
        Utils.checkNotNull(account, "account");
        Utils.checkNotNull(supplierId, "supplierId");
        Utils.checkNotNull(supplier, "supplier");
        Utils.checkNotNull(companyId, "companyId");
        Utils.checkNotNull(location, "location");
        Utils.checkNotNull(departmentId, "departmentId");
        Utils.checkNotNull(department, "department");
        Utils.checkNotNull(paymentType, "paymentType");
        Utils.checkNotNull(currency, "currency");
        Utils.checkNotNull(currencyRate, "currencyRate");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(memo, "memo");
        Utils.checkNotNull(taxRate, "taxRate");
        Utils.checkNotNull(taxInclusive, "taxInclusive");
        Utils.checkNotNull(subTotal, "subTotal");
        Utils.checkNotNull(totalTax, "totalTax");
        Utils.checkNotNull(totalAmount, "totalAmount");
        Utils.checkNotNull(trackingCategories, "trackingCategories");
        Utils.checkNotNull(lineItems, "lineItems");
        Utils.checkNotNull(reference, "reference");
        Utils.checkNotNull(sourceDocumentUrl, "sourceDocumentUrl");
        Utils.checkNotNull(customFields, "customFields");
        Utils.checkNotNull(customMappings, "customMappings");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(updatedAt, "updatedAt");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(rowVersion, "rowVersion");
        Utils.checkNotNull(updatedBy, "updatedBy");
        Utils.checkNotNull(createdBy, "createdBy");
        Utils.checkNotNull(passThrough, "passThrough");
        this.id = id;
        this.displayId = displayId;
        this.number = number;
        this.transactionDate = transactionDate;
        this.accountId = accountId;
        this.account = account;
        this.supplierId = supplierId;
        this.supplier = supplier;
        this.companyId = companyId;
        this.location = location;
        this.departmentId = departmentId;
        this.department = department;
        this.paymentType = paymentType;
        this.currency = currency;
        this.currencyRate = currencyRate;
        this.type = type;
        this.memo = memo;
        this.taxRate = taxRate;
        this.taxInclusive = taxInclusive;
        this.subTotal = subTotal;
        this.totalTax = totalTax;
        this.totalAmount = totalAmount;
        this.trackingCategories = trackingCategories;
        this.lineItems = lineItems;
        this.reference = reference;
        this.sourceDocumentUrl = sourceDocumentUrl;
        this.customFields = customFields;
        this.customMappings = customMappings;
        this.status = status;
        this.updatedAt = updatedAt;
        this.createdAt = createdAt;
        this.rowVersion = rowVersion;
        this.updatedBy = updatedBy;
        this.createdBy = createdBy;
        this.passThrough = passThrough;
    }
    
    public Expense(
            List<ExpenseLineItem> lineItems) {
        this(Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            Optional.empty(), Optional.empty(), JsonNullable.undefined(),
            Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), lineItems,
            JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), Optional.empty());
    }

    /**
     * A unique identifier for an object.
     */
    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * Id to be displayed.
     */
    @JsonIgnore
    public JsonNullable<String> displayId() {
        return displayId;
    }

    /**
     * Number.
     */
    @JsonIgnore
    public JsonNullable<String> number() {
        return number;
    }

    /**
     * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
     */
    @JsonIgnore
    public Optional<OffsetDateTime> transactionDate() {
        return transactionDate;
    }

    /**
     * The unique identifier for the ledger account that this expense should be credited to. Deprecated,
     * use account instead.
     * 
     * @deprecated field: Deprecated. Use account instead..
     */
    @Deprecated
    @JsonIgnore
    public Optional<String> accountId() {
        return accountId;
    }

    /**
     * A flexible account reference that can represent either a ledger account (GL account) or a bank
     * account, depending on the connector's requirements.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<LinkedFinancialAccount> account() {
        return (JsonNullable<LinkedFinancialAccount>) account;
    }

    /**
     * The ID of the supplier this entity is linked to. Deprecated, use supplier instead.
     * 
     * @deprecated field: Deprecated. Use supplier instead..
     */
    @Deprecated
    @JsonIgnore
    public Optional<String> supplierId() {
        return supplierId;
    }

    /**
     * The supplier this entity is linked to.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<LinkedSupplier> supplier() {
        return (JsonNullable<LinkedSupplier>) supplier;
    }

    /**
     * The company ID the transaction belongs to
     */
    @JsonIgnore
    public JsonNullable<String> companyId() {
        return companyId;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<LinkedLocation> location() {
        return (JsonNullable<LinkedLocation>) location;
    }

    /**
     * The ID of the department
     */
    @JsonIgnore
    public JsonNullable<String> departmentId() {
        return departmentId;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<LinkedDepartment> department() {
        return (JsonNullable<LinkedDepartment>) department;
    }

    /**
     * The type of payment for the expense.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ExpensePaymentType> paymentType() {
        return (JsonNullable<ExpensePaymentType>) paymentType;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO
     * 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Currency> currency() {
        return (JsonNullable<Currency>) currency;
    }

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    @JsonIgnore
    public JsonNullable<Double> currencyRate() {
        return currencyRate;
    }

    /**
     * The type of expense.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ExpenseType> type() {
        return (JsonNullable<ExpenseType>) type;
    }

    /**
     * The memo of the expense.
     */
    @JsonIgnore
    public JsonNullable<String> memo() {
        return memo;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<LinkedTaxRate> taxRate() {
        return (Optional<LinkedTaxRate>) taxRate;
    }

    /**
     * Amounts are including tax
     */
    @JsonIgnore
    public JsonNullable<Boolean> taxInclusive() {
        return taxInclusive;
    }

    /**
     * Subtotal amount, normally before tax.
     */
    @JsonIgnore
    public JsonNullable<Double> subTotal() {
        return subTotal;
    }

    /**
     * Total tax amount applied to this transaction.
     */
    @JsonIgnore
    public JsonNullable<Double> totalTax() {
        return totalTax;
    }

    /**
     * The total amount of the expense line item.
     */
    @JsonIgnore
    public JsonNullable<Double> totalAmount() {
        return totalAmount;
    }

    /**
     * A list of linked tracking categories.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<LinkedTrackingCategory>> trackingCategories() {
        return (JsonNullable<List<LinkedTrackingCategory>>) trackingCategories;
    }

    /**
     * Expense line items linked to this expense.
     */
    @JsonIgnore
    public List<ExpenseLineItem> lineItems() {
        return lineItems;
    }

    /**
     * Optional reference identifier for the transaction.
     */
    @JsonIgnore
    public JsonNullable<String> reference() {
        return reference;
    }

    /**
     * URL link to a source document - shown as 'Go to [appName]' in the downstream app. Currently only
     * supported for Xero.
     */
    @JsonIgnore
    public JsonNullable<String> sourceDocumentUrl() {
        return sourceDocumentUrl;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<CustomField>> customFields() {
        return (Optional<List<CustomField>>) customFields;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Map<String, Object>> customMappings() {
        return (JsonNullable<Map<String, Object>>) customMappings;
    }

    /**
     * Expense status
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ExpenseStatus> status() {
        return (JsonNullable<ExpenseStatus>) status;
    }

    /**
     * The date and time when the object was last updated.
     */
    @JsonIgnore
    public JsonNullable<OffsetDateTime> updatedAt() {
        return updatedAt;
    }

    /**
     * The date and time when the object was created.
     */
    @JsonIgnore
    public JsonNullable<OffsetDateTime> createdAt() {
        return createdAt;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each
     * time an update is made to the object.
     */
    @JsonIgnore
    public JsonNullable<String> rowVersion() {
        return rowVersion;
    }

    /**
     * The user who last updated the object.
     */
    @JsonIgnore
    public JsonNullable<String> updatedBy() {
        return updatedBy;
    }

    /**
     * The user who created the object.
     */
    @JsonIgnore
    public JsonNullable<String> createdBy() {
        return createdBy;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications
     * in request body when creating or updating resources.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PassThroughBody>> passThrough() {
        return (Optional<List<PassThroughBody>>) passThrough;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * A unique identifier for an object.
     */
    public Expense withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }


    /**
     * A unique identifier for an object.
     */
    public Expense withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Id to be displayed.
     */
    public Expense withDisplayId(String displayId) {
        Utils.checkNotNull(displayId, "displayId");
        this.displayId = JsonNullable.of(displayId);
        return this;
    }

    /**
     * Id to be displayed.
     */
    public Expense withDisplayId(JsonNullable<String> displayId) {
        Utils.checkNotNull(displayId, "displayId");
        this.displayId = displayId;
        return this;
    }

    /**
     * Number.
     */
    public Expense withNumber(String number) {
        Utils.checkNotNull(number, "number");
        this.number = JsonNullable.of(number);
        return this;
    }

    /**
     * Number.
     */
    public Expense withNumber(JsonNullable<String> number) {
        Utils.checkNotNull(number, "number");
        this.number = number;
        return this;
    }

    /**
     * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
     */
    public Expense withTransactionDate(OffsetDateTime transactionDate) {
        Utils.checkNotNull(transactionDate, "transactionDate");
        this.transactionDate = Optional.ofNullable(transactionDate);
        return this;
    }


    /**
     * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
     */
    public Expense withTransactionDate(Optional<OffsetDateTime> transactionDate) {
        Utils.checkNotNull(transactionDate, "transactionDate");
        this.transactionDate = transactionDate;
        return this;
    }

    /**
     * The unique identifier for the ledger account that this expense should be credited to. Deprecated,
     * use account instead.
     * 
     * @deprecated field: Deprecated. Use account instead..
     */
    @Deprecated
    public Expense withAccountId(String accountId) {
        Utils.checkNotNull(accountId, "accountId");
        this.accountId = Optional.ofNullable(accountId);
        return this;
    }


    /**
     * The unique identifier for the ledger account that this expense should be credited to. Deprecated,
     * use account instead.
     * 
     * @deprecated field: Deprecated. Use account instead..
     */
    @Deprecated
    public Expense withAccountId(Optional<String> accountId) {
        Utils.checkNotNull(accountId, "accountId");
        this.accountId = accountId;
        return this;
    }

    /**
     * A flexible account reference that can represent either a ledger account (GL account) or a bank
     * account, depending on the connector's requirements.
     */
    public Expense withAccount(LinkedFinancialAccount account) {
        Utils.checkNotNull(account, "account");
        this.account = JsonNullable.of(account);
        return this;
    }

    /**
     * A flexible account reference that can represent either a ledger account (GL account) or a bank
     * account, depending on the connector's requirements.
     */
    public Expense withAccount(JsonNullable<? extends LinkedFinancialAccount> account) {
        Utils.checkNotNull(account, "account");
        this.account = account;
        return this;
    }

    /**
     * The ID of the supplier this entity is linked to. Deprecated, use supplier instead.
     * 
     * @deprecated field: Deprecated. Use supplier instead..
     */
    @Deprecated
    public Expense withSupplierId(String supplierId) {
        Utils.checkNotNull(supplierId, "supplierId");
        this.supplierId = Optional.ofNullable(supplierId);
        return this;
    }


    /**
     * The ID of the supplier this entity is linked to. Deprecated, use supplier instead.
     * 
     * @deprecated field: Deprecated. Use supplier instead..
     */
    @Deprecated
    public Expense withSupplierId(Optional<String> supplierId) {
        Utils.checkNotNull(supplierId, "supplierId");
        this.supplierId = supplierId;
        return this;
    }

    /**
     * The supplier this entity is linked to.
     */
    public Expense withSupplier(LinkedSupplier supplier) {
        Utils.checkNotNull(supplier, "supplier");
        this.supplier = JsonNullable.of(supplier);
        return this;
    }

    /**
     * The supplier this entity is linked to.
     */
    public Expense withSupplier(JsonNullable<? extends LinkedSupplier> supplier) {
        Utils.checkNotNull(supplier, "supplier");
        this.supplier = supplier;
        return this;
    }

    /**
     * The company ID the transaction belongs to
     */
    public Expense withCompanyId(String companyId) {
        Utils.checkNotNull(companyId, "companyId");
        this.companyId = JsonNullable.of(companyId);
        return this;
    }

    /**
     * The company ID the transaction belongs to
     */
    public Expense withCompanyId(JsonNullable<String> companyId) {
        Utils.checkNotNull(companyId, "companyId");
        this.companyId = companyId;
        return this;
    }

    public Expense withLocation(LinkedLocation location) {
        Utils.checkNotNull(location, "location");
        this.location = JsonNullable.of(location);
        return this;
    }

    public Expense withLocation(JsonNullable<? extends LinkedLocation> location) {
        Utils.checkNotNull(location, "location");
        this.location = location;
        return this;
    }

    /**
     * The ID of the department
     */
    public Expense withDepartmentId(String departmentId) {
        Utils.checkNotNull(departmentId, "departmentId");
        this.departmentId = JsonNullable.of(departmentId);
        return this;
    }

    /**
     * The ID of the department
     */
    public Expense withDepartmentId(JsonNullable<String> departmentId) {
        Utils.checkNotNull(departmentId, "departmentId");
        this.departmentId = departmentId;
        return this;
    }

    public Expense withDepartment(LinkedDepartment department) {
        Utils.checkNotNull(department, "department");
        this.department = JsonNullable.of(department);
        return this;
    }

    public Expense withDepartment(JsonNullable<? extends LinkedDepartment> department) {
        Utils.checkNotNull(department, "department");
        this.department = department;
        return this;
    }

    /**
     * The type of payment for the expense.
     */
    public Expense withPaymentType(ExpensePaymentType paymentType) {
        Utils.checkNotNull(paymentType, "paymentType");
        this.paymentType = JsonNullable.of(paymentType);
        return this;
    }

    /**
     * The type of payment for the expense.
     */
    public Expense withPaymentType(JsonNullable<? extends ExpensePaymentType> paymentType) {
        Utils.checkNotNull(paymentType, "paymentType");
        this.paymentType = paymentType;
        return this;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO
     * 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    public Expense withCurrency(Currency currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = JsonNullable.of(currency);
        return this;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO
     * 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    public Expense withCurrency(JsonNullable<? extends Currency> currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = currency;
        return this;
    }

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    public Expense withCurrencyRate(double currencyRate) {
        Utils.checkNotNull(currencyRate, "currencyRate");
        this.currencyRate = JsonNullable.of(currencyRate);
        return this;
    }

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    public Expense withCurrencyRate(JsonNullable<Double> currencyRate) {
        Utils.checkNotNull(currencyRate, "currencyRate");
        this.currencyRate = currencyRate;
        return this;
    }

    /**
     * The type of expense.
     */
    public Expense withType(ExpenseType type) {
        Utils.checkNotNull(type, "type");
        this.type = JsonNullable.of(type);
        return this;
    }

    /**
     * The type of expense.
     */
    public Expense withType(JsonNullable<? extends ExpenseType> type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * The memo of the expense.
     */
    public Expense withMemo(String memo) {
        Utils.checkNotNull(memo, "memo");
        this.memo = JsonNullable.of(memo);
        return this;
    }

    /**
     * The memo of the expense.
     */
    public Expense withMemo(JsonNullable<String> memo) {
        Utils.checkNotNull(memo, "memo");
        this.memo = memo;
        return this;
    }

    public Expense withTaxRate(LinkedTaxRate taxRate) {
        Utils.checkNotNull(taxRate, "taxRate");
        this.taxRate = Optional.ofNullable(taxRate);
        return this;
    }


    public Expense withTaxRate(Optional<? extends LinkedTaxRate> taxRate) {
        Utils.checkNotNull(taxRate, "taxRate");
        this.taxRate = taxRate;
        return this;
    }

    /**
     * Amounts are including tax
     */
    public Expense withTaxInclusive(boolean taxInclusive) {
        Utils.checkNotNull(taxInclusive, "taxInclusive");
        this.taxInclusive = JsonNullable.of(taxInclusive);
        return this;
    }

    /**
     * Amounts are including tax
     */
    public Expense withTaxInclusive(JsonNullable<Boolean> taxInclusive) {
        Utils.checkNotNull(taxInclusive, "taxInclusive");
        this.taxInclusive = taxInclusive;
        return this;
    }

    /**
     * Subtotal amount, normally before tax.
     */
    public Expense withSubTotal(double subTotal) {
        Utils.checkNotNull(subTotal, "subTotal");
        this.subTotal = JsonNullable.of(subTotal);
        return this;
    }

    /**
     * Subtotal amount, normally before tax.
     */
    public Expense withSubTotal(JsonNullable<Double> subTotal) {
        Utils.checkNotNull(subTotal, "subTotal");
        this.subTotal = subTotal;
        return this;
    }

    /**
     * Total tax amount applied to this transaction.
     */
    public Expense withTotalTax(double totalTax) {
        Utils.checkNotNull(totalTax, "totalTax");
        this.totalTax = JsonNullable.of(totalTax);
        return this;
    }

    /**
     * Total tax amount applied to this transaction.
     */
    public Expense withTotalTax(JsonNullable<Double> totalTax) {
        Utils.checkNotNull(totalTax, "totalTax");
        this.totalTax = totalTax;
        return this;
    }

    /**
     * The total amount of the expense line item.
     */
    public Expense withTotalAmount(double totalAmount) {
        Utils.checkNotNull(totalAmount, "totalAmount");
        this.totalAmount = JsonNullable.of(totalAmount);
        return this;
    }

    /**
     * The total amount of the expense line item.
     */
    public Expense withTotalAmount(JsonNullable<Double> totalAmount) {
        Utils.checkNotNull(totalAmount, "totalAmount");
        this.totalAmount = totalAmount;
        return this;
    }

    /**
     * A list of linked tracking categories.
     */
    public Expense withTrackingCategories(List<LinkedTrackingCategory> trackingCategories) {
        Utils.checkNotNull(trackingCategories, "trackingCategories");
        this.trackingCategories = JsonNullable.of(trackingCategories);
        return this;
    }

    /**
     * A list of linked tracking categories.
     */
    public Expense withTrackingCategories(JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories) {
        Utils.checkNotNull(trackingCategories, "trackingCategories");
        this.trackingCategories = trackingCategories;
        return this;
    }

    /**
     * Expense line items linked to this expense.
     */
    public Expense withLineItems(List<ExpenseLineItem> lineItems) {
        Utils.checkNotNull(lineItems, "lineItems");
        this.lineItems = lineItems;
        return this;
    }

    /**
     * Optional reference identifier for the transaction.
     */
    public Expense withReference(String reference) {
        Utils.checkNotNull(reference, "reference");
        this.reference = JsonNullable.of(reference);
        return this;
    }

    /**
     * Optional reference identifier for the transaction.
     */
    public Expense withReference(JsonNullable<String> reference) {
        Utils.checkNotNull(reference, "reference");
        this.reference = reference;
        return this;
    }

    /**
     * URL link to a source document - shown as 'Go to [appName]' in the downstream app. Currently only
     * supported for Xero.
     */
    public Expense withSourceDocumentUrl(String sourceDocumentUrl) {
        Utils.checkNotNull(sourceDocumentUrl, "sourceDocumentUrl");
        this.sourceDocumentUrl = JsonNullable.of(sourceDocumentUrl);
        return this;
    }

    /**
     * URL link to a source document - shown as 'Go to [appName]' in the downstream app. Currently only
     * supported for Xero.
     */
    public Expense withSourceDocumentUrl(JsonNullable<String> sourceDocumentUrl) {
        Utils.checkNotNull(sourceDocumentUrl, "sourceDocumentUrl");
        this.sourceDocumentUrl = sourceDocumentUrl;
        return this;
    }

    public Expense withCustomFields(List<CustomField> customFields) {
        Utils.checkNotNull(customFields, "customFields");
        this.customFields = Optional.ofNullable(customFields);
        return this;
    }


    public Expense withCustomFields(Optional<? extends List<CustomField>> customFields) {
        Utils.checkNotNull(customFields, "customFields");
        this.customFields = customFields;
        return this;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public Expense withCustomMappings(Map<String, Object> customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = JsonNullable.of(customMappings);
        return this;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public Expense withCustomMappings(JsonNullable<? extends Map<String, Object>> customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = customMappings;
        return this;
    }

    /**
     * Expense status
     */
    public Expense withStatus(ExpenseStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = JsonNullable.of(status);
        return this;
    }

    /**
     * Expense status
     */
    public Expense withStatus(JsonNullable<? extends ExpenseStatus> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * The date and time when the object was last updated.
     */
    public Expense withUpdatedAt(OffsetDateTime updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = JsonNullable.of(updatedAt);
        return this;
    }

    /**
     * The date and time when the object was last updated.
     */
    public Expense withUpdatedAt(JsonNullable<OffsetDateTime> updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = updatedAt;
        return this;
    }

    /**
     * The date and time when the object was created.
     */
    public Expense withCreatedAt(OffsetDateTime createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = JsonNullable.of(createdAt);
        return this;
    }

    /**
     * The date and time when the object was created.
     */
    public Expense withCreatedAt(JsonNullable<OffsetDateTime> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each
     * time an update is made to the object.
     */
    public Expense withRowVersion(String rowVersion) {
        Utils.checkNotNull(rowVersion, "rowVersion");
        this.rowVersion = JsonNullable.of(rowVersion);
        return this;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each
     * time an update is made to the object.
     */
    public Expense withRowVersion(JsonNullable<String> rowVersion) {
        Utils.checkNotNull(rowVersion, "rowVersion");
        this.rowVersion = rowVersion;
        return this;
    }

    /**
     * The user who last updated the object.
     */
    public Expense withUpdatedBy(String updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = JsonNullable.of(updatedBy);
        return this;
    }

    /**
     * The user who last updated the object.
     */
    public Expense withUpdatedBy(JsonNullable<String> updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = updatedBy;
        return this;
    }

    /**
     * The user who created the object.
     */
    public Expense withCreatedBy(String createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = JsonNullable.of(createdBy);
        return this;
    }

    /**
     * The user who created the object.
     */
    public Expense withCreatedBy(JsonNullable<String> createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = createdBy;
        return this;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications
     * in request body when creating or updating resources.
     */
    public Expense withPassThrough(List<PassThroughBody> passThrough) {
        Utils.checkNotNull(passThrough, "passThrough");
        this.passThrough = Optional.ofNullable(passThrough);
        return this;
    }


    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications
     * in request body when creating or updating resources.
     */
    public Expense withPassThrough(Optional<? extends List<PassThroughBody>> passThrough) {
        Utils.checkNotNull(passThrough, "passThrough");
        this.passThrough = passThrough;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Expense other = (Expense) o;
        return 
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.displayId, other.displayId) &&
            Utils.enhancedDeepEquals(this.number, other.number) &&
            Utils.enhancedDeepEquals(this.transactionDate, other.transactionDate) &&
            Utils.enhancedDeepEquals(this.accountId, other.accountId) &&
            Utils.enhancedDeepEquals(this.account, other.account) &&
            Utils.enhancedDeepEquals(this.supplierId, other.supplierId) &&
            Utils.enhancedDeepEquals(this.supplier, other.supplier) &&
            Utils.enhancedDeepEquals(this.companyId, other.companyId) &&
            Utils.enhancedDeepEquals(this.location, other.location) &&
            Utils.enhancedDeepEquals(this.departmentId, other.departmentId) &&
            Utils.enhancedDeepEquals(this.department, other.department) &&
            Utils.enhancedDeepEquals(this.paymentType, other.paymentType) &&
            Utils.enhancedDeepEquals(this.currency, other.currency) &&
            Utils.enhancedDeepEquals(this.currencyRate, other.currencyRate) &&
            Utils.enhancedDeepEquals(this.type, other.type) &&
            Utils.enhancedDeepEquals(this.memo, other.memo) &&
            Utils.enhancedDeepEquals(this.taxRate, other.taxRate) &&
            Utils.enhancedDeepEquals(this.taxInclusive, other.taxInclusive) &&
            Utils.enhancedDeepEquals(this.subTotal, other.subTotal) &&
            Utils.enhancedDeepEquals(this.totalTax, other.totalTax) &&
            Utils.enhancedDeepEquals(this.totalAmount, other.totalAmount) &&
            Utils.enhancedDeepEquals(this.trackingCategories, other.trackingCategories) &&
            Utils.enhancedDeepEquals(this.lineItems, other.lineItems) &&
            Utils.enhancedDeepEquals(this.reference, other.reference) &&
            Utils.enhancedDeepEquals(this.sourceDocumentUrl, other.sourceDocumentUrl) &&
            Utils.enhancedDeepEquals(this.customFields, other.customFields) &&
            Utils.enhancedDeepEquals(this.customMappings, other.customMappings) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.updatedAt, other.updatedAt) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.rowVersion, other.rowVersion) &&
            Utils.enhancedDeepEquals(this.updatedBy, other.updatedBy) &&
            Utils.enhancedDeepEquals(this.createdBy, other.createdBy) &&
            Utils.enhancedDeepEquals(this.passThrough, other.passThrough);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            id, displayId, number,
            transactionDate, accountId, account,
            supplierId, supplier, companyId,
            location, departmentId, department,
            paymentType, currency, currencyRate,
            type, memo, taxRate,
            taxInclusive, subTotal, totalTax,
            totalAmount, trackingCategories, lineItems,
            reference, sourceDocumentUrl, customFields,
            customMappings, status, updatedAt,
            createdAt, rowVersion, updatedBy,
            createdBy, passThrough);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Expense.class,
                "id", id,
                "displayId", displayId,
                "number", number,
                "transactionDate", transactionDate,
                "accountId", accountId,
                "account", account,
                "supplierId", supplierId,
                "supplier", supplier,
                "companyId", companyId,
                "location", location,
                "departmentId", departmentId,
                "department", department,
                "paymentType", paymentType,
                "currency", currency,
                "currencyRate", currencyRate,
                "type", type,
                "memo", memo,
                "taxRate", taxRate,
                "taxInclusive", taxInclusive,
                "subTotal", subTotal,
                "totalTax", totalTax,
                "totalAmount", totalAmount,
                "trackingCategories", trackingCategories,
                "lineItems", lineItems,
                "reference", reference,
                "sourceDocumentUrl", sourceDocumentUrl,
                "customFields", customFields,
                "customMappings", customMappings,
                "status", status,
                "updatedAt", updatedAt,
                "createdAt", createdAt,
                "rowVersion", rowVersion,
                "updatedBy", updatedBy,
                "createdBy", createdBy,
                "passThrough", passThrough);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<String> id = Optional.empty();

        private JsonNullable<String> displayId = JsonNullable.undefined();

        private JsonNullable<String> number = JsonNullable.undefined();

        private Optional<OffsetDateTime> transactionDate = Optional.empty();

        @Deprecated
        private Optional<String> accountId = Optional.empty();

        private JsonNullable<? extends LinkedFinancialAccount> account = JsonNullable.undefined();

        @Deprecated
        private Optional<String> supplierId = Optional.empty();

        private JsonNullable<? extends LinkedSupplier> supplier = JsonNullable.undefined();

        private JsonNullable<String> companyId = JsonNullable.undefined();

        private JsonNullable<? extends LinkedLocation> location = JsonNullable.undefined();

        private JsonNullable<String> departmentId = JsonNullable.undefined();

        private JsonNullable<? extends LinkedDepartment> department = JsonNullable.undefined();

        private JsonNullable<? extends ExpensePaymentType> paymentType = JsonNullable.undefined();

        private JsonNullable<? extends Currency> currency = JsonNullable.undefined();

        private JsonNullable<Double> currencyRate = JsonNullable.undefined();

        private JsonNullable<? extends ExpenseType> type = JsonNullable.undefined();

        private JsonNullable<String> memo = JsonNullable.undefined();

        private Optional<? extends LinkedTaxRate> taxRate = Optional.empty();

        private JsonNullable<Boolean> taxInclusive = JsonNullable.undefined();

        private JsonNullable<Double> subTotal = JsonNullable.undefined();

        private JsonNullable<Double> totalTax = JsonNullable.undefined();

        private JsonNullable<Double> totalAmount = JsonNullable.undefined();

        private JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories = JsonNullable.undefined();

        private List<ExpenseLineItem> lineItems;

        private JsonNullable<String> reference = JsonNullable.undefined();

        private JsonNullable<String> sourceDocumentUrl = JsonNullable.undefined();

        private Optional<? extends List<CustomField>> customFields = Optional.empty();

        private JsonNullable<? extends Map<String, Object>> customMappings = JsonNullable.undefined();

        private JsonNullable<? extends ExpenseStatus> status = JsonNullable.undefined();

        private JsonNullable<OffsetDateTime> updatedAt = JsonNullable.undefined();

        private JsonNullable<OffsetDateTime> createdAt = JsonNullable.undefined();

        private JsonNullable<String> rowVersion = JsonNullable.undefined();

        private JsonNullable<String> updatedBy = JsonNullable.undefined();

        private JsonNullable<String> createdBy = JsonNullable.undefined();

        private Optional<? extends List<PassThroughBody>> passThrough = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * A unique identifier for an object.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * A unique identifier for an object.
         */
        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        /**
         * Id to be displayed.
         */
        public Builder displayId(String displayId) {
            Utils.checkNotNull(displayId, "displayId");
            this.displayId = JsonNullable.of(displayId);
            return this;
        }

        /**
         * Id to be displayed.
         */
        public Builder displayId(JsonNullable<String> displayId) {
            Utils.checkNotNull(displayId, "displayId");
            this.displayId = displayId;
            return this;
        }


        /**
         * Number.
         */
        public Builder number(String number) {
            Utils.checkNotNull(number, "number");
            this.number = JsonNullable.of(number);
            return this;
        }

        /**
         * Number.
         */
        public Builder number(JsonNullable<String> number) {
            Utils.checkNotNull(number, "number");
            this.number = number;
            return this;
        }


        /**
         * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
         */
        public Builder transactionDate(OffsetDateTime transactionDate) {
            Utils.checkNotNull(transactionDate, "transactionDate");
            this.transactionDate = Optional.ofNullable(transactionDate);
            return this;
        }

        /**
         * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
         */
        public Builder transactionDate(Optional<OffsetDateTime> transactionDate) {
            Utils.checkNotNull(transactionDate, "transactionDate");
            this.transactionDate = transactionDate;
            return this;
        }


        /**
         * The unique identifier for the ledger account that this expense should be credited to. Deprecated,
         * use account instead.
         * 
         * @deprecated field: Deprecated. Use account instead..
         */
        @Deprecated
        public Builder accountId(String accountId) {
            Utils.checkNotNull(accountId, "accountId");
            this.accountId = Optional.ofNullable(accountId);
            return this;
        }

        /**
         * The unique identifier for the ledger account that this expense should be credited to. Deprecated,
         * use account instead.
         * 
         * @deprecated field: Deprecated. Use account instead..
         */
        @Deprecated
        public Builder accountId(Optional<String> accountId) {
            Utils.checkNotNull(accountId, "accountId");
            this.accountId = accountId;
            return this;
        }


        /**
         * A flexible account reference that can represent either a ledger account (GL account) or a bank
         * account, depending on the connector's requirements.
         */
        public Builder account(LinkedFinancialAccount account) {
            Utils.checkNotNull(account, "account");
            this.account = JsonNullable.of(account);
            return this;
        }

        /**
         * A flexible account reference that can represent either a ledger account (GL account) or a bank
         * account, depending on the connector's requirements.
         */
        public Builder account(JsonNullable<? extends LinkedFinancialAccount> account) {
            Utils.checkNotNull(account, "account");
            this.account = account;
            return this;
        }


        /**
         * The ID of the supplier this entity is linked to. Deprecated, use supplier instead.
         * 
         * @deprecated field: Deprecated. Use supplier instead..
         */
        @Deprecated
        public Builder supplierId(String supplierId) {
            Utils.checkNotNull(supplierId, "supplierId");
            this.supplierId = Optional.ofNullable(supplierId);
            return this;
        }

        /**
         * The ID of the supplier this entity is linked to. Deprecated, use supplier instead.
         * 
         * @deprecated field: Deprecated. Use supplier instead..
         */
        @Deprecated
        public Builder supplierId(Optional<String> supplierId) {
            Utils.checkNotNull(supplierId, "supplierId");
            this.supplierId = supplierId;
            return this;
        }


        /**
         * The supplier this entity is linked to.
         */
        public Builder supplier(LinkedSupplier supplier) {
            Utils.checkNotNull(supplier, "supplier");
            this.supplier = JsonNullable.of(supplier);
            return this;
        }

        /**
         * The supplier this entity is linked to.
         */
        public Builder supplier(JsonNullable<? extends LinkedSupplier> supplier) {
            Utils.checkNotNull(supplier, "supplier");
            this.supplier = supplier;
            return this;
        }


        /**
         * The company ID the transaction belongs to
         */
        public Builder companyId(String companyId) {
            Utils.checkNotNull(companyId, "companyId");
            this.companyId = JsonNullable.of(companyId);
            return this;
        }

        /**
         * The company ID the transaction belongs to
         */
        public Builder companyId(JsonNullable<String> companyId) {
            Utils.checkNotNull(companyId, "companyId");
            this.companyId = companyId;
            return this;
        }


        public Builder location(LinkedLocation location) {
            Utils.checkNotNull(location, "location");
            this.location = JsonNullable.of(location);
            return this;
        }

        public Builder location(JsonNullable<? extends LinkedLocation> location) {
            Utils.checkNotNull(location, "location");
            this.location = location;
            return this;
        }


        /**
         * The ID of the department
         */
        public Builder departmentId(String departmentId) {
            Utils.checkNotNull(departmentId, "departmentId");
            this.departmentId = JsonNullable.of(departmentId);
            return this;
        }

        /**
         * The ID of the department
         */
        public Builder departmentId(JsonNullable<String> departmentId) {
            Utils.checkNotNull(departmentId, "departmentId");
            this.departmentId = departmentId;
            return this;
        }


        public Builder department(LinkedDepartment department) {
            Utils.checkNotNull(department, "department");
            this.department = JsonNullable.of(department);
            return this;
        }

        public Builder department(JsonNullable<? extends LinkedDepartment> department) {
            Utils.checkNotNull(department, "department");
            this.department = department;
            return this;
        }


        /**
         * The type of payment for the expense.
         */
        public Builder paymentType(ExpensePaymentType paymentType) {
            Utils.checkNotNull(paymentType, "paymentType");
            this.paymentType = JsonNullable.of(paymentType);
            return this;
        }

        /**
         * The type of payment for the expense.
         */
        public Builder paymentType(JsonNullable<? extends ExpensePaymentType> paymentType) {
            Utils.checkNotNull(paymentType, "paymentType");
            this.paymentType = paymentType;
            return this;
        }


        /**
         * Indicates the associated currency for an amount of money. Values correspond to [ISO
         * 4217](https://en.wikipedia.org/wiki/ISO_4217).
         */
        public Builder currency(Currency currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = JsonNullable.of(currency);
            return this;
        }

        /**
         * Indicates the associated currency for an amount of money. Values correspond to [ISO
         * 4217](https://en.wikipedia.org/wiki/ISO_4217).
         */
        public Builder currency(JsonNullable<? extends Currency> currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = currency;
            return this;
        }


        /**
         * Currency Exchange Rate at the time entity was recorded/generated.
         */
        public Builder currencyRate(double currencyRate) {
            Utils.checkNotNull(currencyRate, "currencyRate");
            this.currencyRate = JsonNullable.of(currencyRate);
            return this;
        }

        /**
         * Currency Exchange Rate at the time entity was recorded/generated.
         */
        public Builder currencyRate(JsonNullable<Double> currencyRate) {
            Utils.checkNotNull(currencyRate, "currencyRate");
            this.currencyRate = currencyRate;
            return this;
        }


        /**
         * The type of expense.
         */
        public Builder type(ExpenseType type) {
            Utils.checkNotNull(type, "type");
            this.type = JsonNullable.of(type);
            return this;
        }

        /**
         * The type of expense.
         */
        public Builder type(JsonNullable<? extends ExpenseType> type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }


        /**
         * The memo of the expense.
         */
        public Builder memo(String memo) {
            Utils.checkNotNull(memo, "memo");
            this.memo = JsonNullable.of(memo);
            return this;
        }

        /**
         * The memo of the expense.
         */
        public Builder memo(JsonNullable<String> memo) {
            Utils.checkNotNull(memo, "memo");
            this.memo = memo;
            return this;
        }


        public Builder taxRate(LinkedTaxRate taxRate) {
            Utils.checkNotNull(taxRate, "taxRate");
            this.taxRate = Optional.ofNullable(taxRate);
            return this;
        }

        public Builder taxRate(Optional<? extends LinkedTaxRate> taxRate) {
            Utils.checkNotNull(taxRate, "taxRate");
            this.taxRate = taxRate;
            return this;
        }


        /**
         * Amounts are including tax
         */
        public Builder taxInclusive(boolean taxInclusive) {
            Utils.checkNotNull(taxInclusive, "taxInclusive");
            this.taxInclusive = JsonNullable.of(taxInclusive);
            return this;
        }

        /**
         * Amounts are including tax
         */
        public Builder taxInclusive(JsonNullable<Boolean> taxInclusive) {
            Utils.checkNotNull(taxInclusive, "taxInclusive");
            this.taxInclusive = taxInclusive;
            return this;
        }


        /**
         * Subtotal amount, normally before tax.
         */
        public Builder subTotal(double subTotal) {
            Utils.checkNotNull(subTotal, "subTotal");
            this.subTotal = JsonNullable.of(subTotal);
            return this;
        }

        /**
         * Subtotal amount, normally before tax.
         */
        public Builder subTotal(JsonNullable<Double> subTotal) {
            Utils.checkNotNull(subTotal, "subTotal");
            this.subTotal = subTotal;
            return this;
        }


        /**
         * Total tax amount applied to this transaction.
         */
        public Builder totalTax(double totalTax) {
            Utils.checkNotNull(totalTax, "totalTax");
            this.totalTax = JsonNullable.of(totalTax);
            return this;
        }

        /**
         * Total tax amount applied to this transaction.
         */
        public Builder totalTax(JsonNullable<Double> totalTax) {
            Utils.checkNotNull(totalTax, "totalTax");
            this.totalTax = totalTax;
            return this;
        }


        /**
         * The total amount of the expense line item.
         */
        public Builder totalAmount(double totalAmount) {
            Utils.checkNotNull(totalAmount, "totalAmount");
            this.totalAmount = JsonNullable.of(totalAmount);
            return this;
        }

        /**
         * The total amount of the expense line item.
         */
        public Builder totalAmount(JsonNullable<Double> totalAmount) {
            Utils.checkNotNull(totalAmount, "totalAmount");
            this.totalAmount = totalAmount;
            return this;
        }


        /**
         * A list of linked tracking categories.
         */
        public Builder trackingCategories(List<LinkedTrackingCategory> trackingCategories) {
            Utils.checkNotNull(trackingCategories, "trackingCategories");
            this.trackingCategories = JsonNullable.of(trackingCategories);
            return this;
        }

        /**
         * A list of linked tracking categories.
         */
        public Builder trackingCategories(JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories) {
            Utils.checkNotNull(trackingCategories, "trackingCategories");
            this.trackingCategories = trackingCategories;
            return this;
        }


        /**
         * Expense line items linked to this expense.
         */
        public Builder lineItems(List<ExpenseLineItem> lineItems) {
            Utils.checkNotNull(lineItems, "lineItems");
            this.lineItems = lineItems;
            return this;
        }


        /**
         * Optional reference identifier for the transaction.
         */
        public Builder reference(String reference) {
            Utils.checkNotNull(reference, "reference");
            this.reference = JsonNullable.of(reference);
            return this;
        }

        /**
         * Optional reference identifier for the transaction.
         */
        public Builder reference(JsonNullable<String> reference) {
            Utils.checkNotNull(reference, "reference");
            this.reference = reference;
            return this;
        }


        /**
         * URL link to a source document - shown as 'Go to [appName]' in the downstream app. Currently only
         * supported for Xero.
         */
        public Builder sourceDocumentUrl(String sourceDocumentUrl) {
            Utils.checkNotNull(sourceDocumentUrl, "sourceDocumentUrl");
            this.sourceDocumentUrl = JsonNullable.of(sourceDocumentUrl);
            return this;
        }

        /**
         * URL link to a source document - shown as 'Go to [appName]' in the downstream app. Currently only
         * supported for Xero.
         */
        public Builder sourceDocumentUrl(JsonNullable<String> sourceDocumentUrl) {
            Utils.checkNotNull(sourceDocumentUrl, "sourceDocumentUrl");
            this.sourceDocumentUrl = sourceDocumentUrl;
            return this;
        }


        public Builder customFields(List<CustomField> customFields) {
            Utils.checkNotNull(customFields, "customFields");
            this.customFields = Optional.ofNullable(customFields);
            return this;
        }

        public Builder customFields(Optional<? extends List<CustomField>> customFields) {
            Utils.checkNotNull(customFields, "customFields");
            this.customFields = customFields;
            return this;
        }


        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(Map<String, Object> customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = JsonNullable.of(customMappings);
            return this;
        }

        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(JsonNullable<? extends Map<String, Object>> customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = customMappings;
            return this;
        }


        /**
         * Expense status
         */
        public Builder status(ExpenseStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = JsonNullable.of(status);
            return this;
        }

        /**
         * Expense status
         */
        public Builder status(JsonNullable<? extends ExpenseStatus> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }


        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(OffsetDateTime updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = JsonNullable.of(updatedAt);
            return this;
        }

        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(JsonNullable<OffsetDateTime> updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = updatedAt;
            return this;
        }


        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(OffsetDateTime createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = JsonNullable.of(createdAt);
            return this;
        }

        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(JsonNullable<OffsetDateTime> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }


        /**
         * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each
         * time an update is made to the object.
         */
        public Builder rowVersion(String rowVersion) {
            Utils.checkNotNull(rowVersion, "rowVersion");
            this.rowVersion = JsonNullable.of(rowVersion);
            return this;
        }

        /**
         * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each
         * time an update is made to the object.
         */
        public Builder rowVersion(JsonNullable<String> rowVersion) {
            Utils.checkNotNull(rowVersion, "rowVersion");
            this.rowVersion = rowVersion;
            return this;
        }


        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(String updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = JsonNullable.of(updatedBy);
            return this;
        }

        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(JsonNullable<String> updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = updatedBy;
            return this;
        }


        /**
         * The user who created the object.
         */
        public Builder createdBy(String createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = JsonNullable.of(createdBy);
            return this;
        }

        /**
         * The user who created the object.
         */
        public Builder createdBy(JsonNullable<String> createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = createdBy;
            return this;
        }


        /**
         * The pass_through property allows passing service-specific, custom data or structured modifications
         * in request body when creating or updating resources.
         */
        public Builder passThrough(List<PassThroughBody> passThrough) {
            Utils.checkNotNull(passThrough, "passThrough");
            this.passThrough = Optional.ofNullable(passThrough);
            return this;
        }

        /**
         * The pass_through property allows passing service-specific, custom data or structured modifications
         * in request body when creating or updating resources.
         */
        public Builder passThrough(Optional<? extends List<PassThroughBody>> passThrough) {
            Utils.checkNotNull(passThrough, "passThrough");
            this.passThrough = passThrough;
            return this;
        }

        public Expense build() {

            return new Expense(
                id, displayId, number,
                transactionDate, accountId, account,
                supplierId, supplier, companyId,
                location, departmentId, department,
                paymentType, currency, currencyRate,
                type, memo, taxRate,
                taxInclusive, subTotal, totalTax,
                totalAmount, trackingCategories, lineItems,
                reference, sourceDocumentUrl, customFields,
                customMappings, status, updatedAt,
                createdAt, rowVersion, updatedBy,
                createdBy, passThrough);
        }

    }
}
