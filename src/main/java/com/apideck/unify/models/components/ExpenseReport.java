/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.apideck.unify.models.components;

import com.apideck.unify.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class ExpenseReport {
    /**
     * A unique identifier for an object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * Id to be displayed.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("display_id")
    private JsonNullable<String> displayId;

    /**
     * The expense report number.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("number")
    private JsonNullable<String> number;

    /**
     * Title or purpose of the expense report.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("title")
    private JsonNullable<String> title;

    /**
     * The employee who submitted the expense report.
     */
    @JsonProperty("employee")
    private ExpenseReportEmployee employee;

    /**
     * The status of the expense report.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private JsonNullable<? extends ExpenseReportStatus> status;

    /**
     * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("transaction_date")
    private Optional<OffsetDateTime> transactionDate;

    /**
     * The date the expense report was posted to the general ledger.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("posting_date")
    private JsonNullable<LocalDate> postingDate;

    /**
     * Date when reimbursement is due.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("due_date")
    private JsonNullable<LocalDate> dueDate;

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO
     * 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency")
    private JsonNullable<? extends Currency> currency;

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency_rate")
    private JsonNullable<Double> currencyRate;

    /**
     * Subtotal amount, normally before tax.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sub_total")
    private JsonNullable<Double> subTotal;

    /**
     * Total tax amount applied to this transaction.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("total_tax")
    private JsonNullable<Double> totalTax;

    /**
     * Total amount of all expense lines including tax.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("total_amount")
    private JsonNullable<Double> totalAmount;

    /**
     * Total reimbursable amount (may differ from total if some expenses are non-reimbursable).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("reimbursable_amount")
    private JsonNullable<Double> reimbursableAmount;

    /**
     * The memo of the expense report.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("memo")
    private JsonNullable<String> memo;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("department")
    private JsonNullable<? extends LinkedDepartment> department;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("location")
    private JsonNullable<? extends LinkedLocation> location;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("account")
    private JsonNullable<? extends LinkedLedgerAccount> account;

    /**
     * The accounting period the expense report is posted to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accounting_period")
    private JsonNullable<? extends AccountingPeriod> accountingPeriod;

    /**
     * Expense line items linked to this expense report.
     */
    @JsonProperty("line_items")
    private List<ExpenseReportLineItem> lineItems;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subsidiary")
    private JsonNullable<? extends LinkedSubsidiary> subsidiary;

    /**
     * A list of linked tracking categories.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tracking_categories")
    private JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories;

    /**
     * Amounts are including tax
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tax_inclusive")
    private JsonNullable<Boolean> taxInclusive;

    /**
     * The person who approved the expense report.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("approved_by")
    private JsonNullable<? extends ApprovedBy> approvedBy;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_fields")
    private Optional<? extends List<CustomField>> customFields;

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_mappings")
    private JsonNullable<? extends Map<String, Object>> customMappings;

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each
     * time an update is made to the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("row_version")
    private JsonNullable<String> rowVersion;

    /**
     * The user who last updated the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_by")
    private JsonNullable<String> updatedBy;

    /**
     * The user who created the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_by")
    private JsonNullable<String> createdBy;

    /**
     * The date and time when the object was last updated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_at")
    private JsonNullable<OffsetDateTime> updatedAt;

    /**
     * The date and time when the object was created.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_at")
    private JsonNullable<OffsetDateTime> createdAt;

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications
     * in request body when creating or updating resources.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pass_through")
    private Optional<? extends List<PassThroughBody>> passThrough;

    @JsonCreator
    public ExpenseReport(
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("display_id") JsonNullable<String> displayId,
            @JsonProperty("number") JsonNullable<String> number,
            @JsonProperty("title") JsonNullable<String> title,
            @JsonProperty("employee") ExpenseReportEmployee employee,
            @JsonProperty("status") JsonNullable<? extends ExpenseReportStatus> status,
            @JsonProperty("transaction_date") Optional<OffsetDateTime> transactionDate,
            @JsonProperty("posting_date") JsonNullable<LocalDate> postingDate,
            @JsonProperty("due_date") JsonNullable<LocalDate> dueDate,
            @JsonProperty("currency") JsonNullable<? extends Currency> currency,
            @JsonProperty("currency_rate") JsonNullable<Double> currencyRate,
            @JsonProperty("sub_total") JsonNullable<Double> subTotal,
            @JsonProperty("total_tax") JsonNullable<Double> totalTax,
            @JsonProperty("total_amount") JsonNullable<Double> totalAmount,
            @JsonProperty("reimbursable_amount") JsonNullable<Double> reimbursableAmount,
            @JsonProperty("memo") JsonNullable<String> memo,
            @JsonProperty("department") JsonNullable<? extends LinkedDepartment> department,
            @JsonProperty("location") JsonNullable<? extends LinkedLocation> location,
            @JsonProperty("account") JsonNullable<? extends LinkedLedgerAccount> account,
            @JsonProperty("accounting_period") JsonNullable<? extends AccountingPeriod> accountingPeriod,
            @JsonProperty("line_items") List<ExpenseReportLineItem> lineItems,
            @JsonProperty("subsidiary") JsonNullable<? extends LinkedSubsidiary> subsidiary,
            @JsonProperty("tracking_categories") JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories,
            @JsonProperty("tax_inclusive") JsonNullable<Boolean> taxInclusive,
            @JsonProperty("approved_by") JsonNullable<? extends ApprovedBy> approvedBy,
            @JsonProperty("custom_fields") Optional<? extends List<CustomField>> customFields,
            @JsonProperty("custom_mappings") JsonNullable<? extends Map<String, Object>> customMappings,
            @JsonProperty("row_version") JsonNullable<String> rowVersion,
            @JsonProperty("updated_by") JsonNullable<String> updatedBy,
            @JsonProperty("created_by") JsonNullable<String> createdBy,
            @JsonProperty("updated_at") JsonNullable<OffsetDateTime> updatedAt,
            @JsonProperty("created_at") JsonNullable<OffsetDateTime> createdAt,
            @JsonProperty("pass_through") Optional<? extends List<PassThroughBody>> passThrough) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(displayId, "displayId");
        Utils.checkNotNull(number, "number");
        Utils.checkNotNull(title, "title");
        Utils.checkNotNull(employee, "employee");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(transactionDate, "transactionDate");
        Utils.checkNotNull(postingDate, "postingDate");
        Utils.checkNotNull(dueDate, "dueDate");
        Utils.checkNotNull(currency, "currency");
        Utils.checkNotNull(currencyRate, "currencyRate");
        Utils.checkNotNull(subTotal, "subTotal");
        Utils.checkNotNull(totalTax, "totalTax");
        Utils.checkNotNull(totalAmount, "totalAmount");
        Utils.checkNotNull(reimbursableAmount, "reimbursableAmount");
        Utils.checkNotNull(memo, "memo");
        Utils.checkNotNull(department, "department");
        Utils.checkNotNull(location, "location");
        Utils.checkNotNull(account, "account");
        Utils.checkNotNull(accountingPeriod, "accountingPeriod");
        Utils.checkNotNull(lineItems, "lineItems");
        Utils.checkNotNull(subsidiary, "subsidiary");
        Utils.checkNotNull(trackingCategories, "trackingCategories");
        Utils.checkNotNull(taxInclusive, "taxInclusive");
        Utils.checkNotNull(approvedBy, "approvedBy");
        Utils.checkNotNull(customFields, "customFields");
        Utils.checkNotNull(customMappings, "customMappings");
        Utils.checkNotNull(rowVersion, "rowVersion");
        Utils.checkNotNull(updatedBy, "updatedBy");
        Utils.checkNotNull(createdBy, "createdBy");
        Utils.checkNotNull(updatedAt, "updatedAt");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(passThrough, "passThrough");
        this.id = id;
        this.displayId = displayId;
        this.number = number;
        this.title = title;
        this.employee = employee;
        this.status = status;
        this.transactionDate = transactionDate;
        this.postingDate = postingDate;
        this.dueDate = dueDate;
        this.currency = currency;
        this.currencyRate = currencyRate;
        this.subTotal = subTotal;
        this.totalTax = totalTax;
        this.totalAmount = totalAmount;
        this.reimbursableAmount = reimbursableAmount;
        this.memo = memo;
        this.department = department;
        this.location = location;
        this.account = account;
        this.accountingPeriod = accountingPeriod;
        this.lineItems = lineItems;
        this.subsidiary = subsidiary;
        this.trackingCategories = trackingCategories;
        this.taxInclusive = taxInclusive;
        this.approvedBy = approvedBy;
        this.customFields = customFields;
        this.customMappings = customMappings;
        this.rowVersion = rowVersion;
        this.updatedBy = updatedBy;
        this.createdBy = createdBy;
        this.updatedAt = updatedAt;
        this.createdAt = createdAt;
        this.passThrough = passThrough;
    }
    
    public ExpenseReport(
            ExpenseReportEmployee employee,
            List<ExpenseReportLineItem> lineItems) {
        this(Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), employee, JsonNullable.undefined(),
            Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), lineItems,
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty());
    }

    /**
     * A unique identifier for an object.
     */
    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * Id to be displayed.
     */
    @JsonIgnore
    public JsonNullable<String> displayId() {
        return displayId;
    }

    /**
     * The expense report number.
     */
    @JsonIgnore
    public JsonNullable<String> number() {
        return number;
    }

    /**
     * Title or purpose of the expense report.
     */
    @JsonIgnore
    public JsonNullable<String> title() {
        return title;
    }

    /**
     * The employee who submitted the expense report.
     */
    @JsonIgnore
    public ExpenseReportEmployee employee() {
        return employee;
    }

    /**
     * The status of the expense report.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ExpenseReportStatus> status() {
        return (JsonNullable<ExpenseReportStatus>) status;
    }

    /**
     * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
     */
    @JsonIgnore
    public Optional<OffsetDateTime> transactionDate() {
        return transactionDate;
    }

    /**
     * The date the expense report was posted to the general ledger.
     */
    @JsonIgnore
    public JsonNullable<LocalDate> postingDate() {
        return postingDate;
    }

    /**
     * Date when reimbursement is due.
     */
    @JsonIgnore
    public JsonNullable<LocalDate> dueDate() {
        return dueDate;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO
     * 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Currency> currency() {
        return (JsonNullable<Currency>) currency;
    }

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    @JsonIgnore
    public JsonNullable<Double> currencyRate() {
        return currencyRate;
    }

    /**
     * Subtotal amount, normally before tax.
     */
    @JsonIgnore
    public JsonNullable<Double> subTotal() {
        return subTotal;
    }

    /**
     * Total tax amount applied to this transaction.
     */
    @JsonIgnore
    public JsonNullable<Double> totalTax() {
        return totalTax;
    }

    /**
     * Total amount of all expense lines including tax.
     */
    @JsonIgnore
    public JsonNullable<Double> totalAmount() {
        return totalAmount;
    }

    /**
     * Total reimbursable amount (may differ from total if some expenses are non-reimbursable).
     */
    @JsonIgnore
    public JsonNullable<Double> reimbursableAmount() {
        return reimbursableAmount;
    }

    /**
     * The memo of the expense report.
     */
    @JsonIgnore
    public JsonNullable<String> memo() {
        return memo;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<LinkedDepartment> department() {
        return (JsonNullable<LinkedDepartment>) department;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<LinkedLocation> location() {
        return (JsonNullable<LinkedLocation>) location;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<LinkedLedgerAccount> account() {
        return (JsonNullable<LinkedLedgerAccount>) account;
    }

    /**
     * The accounting period the expense report is posted to.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<AccountingPeriod> accountingPeriod() {
        return (JsonNullable<AccountingPeriod>) accountingPeriod;
    }

    /**
     * Expense line items linked to this expense report.
     */
    @JsonIgnore
    public List<ExpenseReportLineItem> lineItems() {
        return lineItems;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<LinkedSubsidiary> subsidiary() {
        return (JsonNullable<LinkedSubsidiary>) subsidiary;
    }

    /**
     * A list of linked tracking categories.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<LinkedTrackingCategory>> trackingCategories() {
        return (JsonNullable<List<LinkedTrackingCategory>>) trackingCategories;
    }

    /**
     * Amounts are including tax
     */
    @JsonIgnore
    public JsonNullable<Boolean> taxInclusive() {
        return taxInclusive;
    }

    /**
     * The person who approved the expense report.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<ApprovedBy> approvedBy() {
        return (JsonNullable<ApprovedBy>) approvedBy;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<CustomField>> customFields() {
        return (Optional<List<CustomField>>) customFields;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Map<String, Object>> customMappings() {
        return (JsonNullable<Map<String, Object>>) customMappings;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each
     * time an update is made to the object.
     */
    @JsonIgnore
    public JsonNullable<String> rowVersion() {
        return rowVersion;
    }

    /**
     * The user who last updated the object.
     */
    @JsonIgnore
    public JsonNullable<String> updatedBy() {
        return updatedBy;
    }

    /**
     * The user who created the object.
     */
    @JsonIgnore
    public JsonNullable<String> createdBy() {
        return createdBy;
    }

    /**
     * The date and time when the object was last updated.
     */
    @JsonIgnore
    public JsonNullable<OffsetDateTime> updatedAt() {
        return updatedAt;
    }

    /**
     * The date and time when the object was created.
     */
    @JsonIgnore
    public JsonNullable<OffsetDateTime> createdAt() {
        return createdAt;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications
     * in request body when creating or updating resources.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PassThroughBody>> passThrough() {
        return (Optional<List<PassThroughBody>>) passThrough;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * A unique identifier for an object.
     */
    public ExpenseReport withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }


    /**
     * A unique identifier for an object.
     */
    public ExpenseReport withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * Id to be displayed.
     */
    public ExpenseReport withDisplayId(String displayId) {
        Utils.checkNotNull(displayId, "displayId");
        this.displayId = JsonNullable.of(displayId);
        return this;
    }

    /**
     * Id to be displayed.
     */
    public ExpenseReport withDisplayId(JsonNullable<String> displayId) {
        Utils.checkNotNull(displayId, "displayId");
        this.displayId = displayId;
        return this;
    }

    /**
     * The expense report number.
     */
    public ExpenseReport withNumber(String number) {
        Utils.checkNotNull(number, "number");
        this.number = JsonNullable.of(number);
        return this;
    }

    /**
     * The expense report number.
     */
    public ExpenseReport withNumber(JsonNullable<String> number) {
        Utils.checkNotNull(number, "number");
        this.number = number;
        return this;
    }

    /**
     * Title or purpose of the expense report.
     */
    public ExpenseReport withTitle(String title) {
        Utils.checkNotNull(title, "title");
        this.title = JsonNullable.of(title);
        return this;
    }

    /**
     * Title or purpose of the expense report.
     */
    public ExpenseReport withTitle(JsonNullable<String> title) {
        Utils.checkNotNull(title, "title");
        this.title = title;
        return this;
    }

    /**
     * The employee who submitted the expense report.
     */
    public ExpenseReport withEmployee(ExpenseReportEmployee employee) {
        Utils.checkNotNull(employee, "employee");
        this.employee = employee;
        return this;
    }

    /**
     * The status of the expense report.
     */
    public ExpenseReport withStatus(ExpenseReportStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = JsonNullable.of(status);
        return this;
    }

    /**
     * The status of the expense report.
     */
    public ExpenseReport withStatus(JsonNullable<? extends ExpenseReportStatus> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
     */
    public ExpenseReport withTransactionDate(OffsetDateTime transactionDate) {
        Utils.checkNotNull(transactionDate, "transactionDate");
        this.transactionDate = Optional.ofNullable(transactionDate);
        return this;
    }


    /**
     * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
     */
    public ExpenseReport withTransactionDate(Optional<OffsetDateTime> transactionDate) {
        Utils.checkNotNull(transactionDate, "transactionDate");
        this.transactionDate = transactionDate;
        return this;
    }

    /**
     * The date the expense report was posted to the general ledger.
     */
    public ExpenseReport withPostingDate(LocalDate postingDate) {
        Utils.checkNotNull(postingDate, "postingDate");
        this.postingDate = JsonNullable.of(postingDate);
        return this;
    }

    /**
     * The date the expense report was posted to the general ledger.
     */
    public ExpenseReport withPostingDate(JsonNullable<LocalDate> postingDate) {
        Utils.checkNotNull(postingDate, "postingDate");
        this.postingDate = postingDate;
        return this;
    }

    /**
     * Date when reimbursement is due.
     */
    public ExpenseReport withDueDate(LocalDate dueDate) {
        Utils.checkNotNull(dueDate, "dueDate");
        this.dueDate = JsonNullable.of(dueDate);
        return this;
    }

    /**
     * Date when reimbursement is due.
     */
    public ExpenseReport withDueDate(JsonNullable<LocalDate> dueDate) {
        Utils.checkNotNull(dueDate, "dueDate");
        this.dueDate = dueDate;
        return this;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO
     * 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    public ExpenseReport withCurrency(Currency currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = JsonNullable.of(currency);
        return this;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO
     * 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    public ExpenseReport withCurrency(JsonNullable<? extends Currency> currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = currency;
        return this;
    }

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    public ExpenseReport withCurrencyRate(double currencyRate) {
        Utils.checkNotNull(currencyRate, "currencyRate");
        this.currencyRate = JsonNullable.of(currencyRate);
        return this;
    }

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    public ExpenseReport withCurrencyRate(JsonNullable<Double> currencyRate) {
        Utils.checkNotNull(currencyRate, "currencyRate");
        this.currencyRate = currencyRate;
        return this;
    }

    /**
     * Subtotal amount, normally before tax.
     */
    public ExpenseReport withSubTotal(double subTotal) {
        Utils.checkNotNull(subTotal, "subTotal");
        this.subTotal = JsonNullable.of(subTotal);
        return this;
    }

    /**
     * Subtotal amount, normally before tax.
     */
    public ExpenseReport withSubTotal(JsonNullable<Double> subTotal) {
        Utils.checkNotNull(subTotal, "subTotal");
        this.subTotal = subTotal;
        return this;
    }

    /**
     * Total tax amount applied to this transaction.
     */
    public ExpenseReport withTotalTax(double totalTax) {
        Utils.checkNotNull(totalTax, "totalTax");
        this.totalTax = JsonNullable.of(totalTax);
        return this;
    }

    /**
     * Total tax amount applied to this transaction.
     */
    public ExpenseReport withTotalTax(JsonNullable<Double> totalTax) {
        Utils.checkNotNull(totalTax, "totalTax");
        this.totalTax = totalTax;
        return this;
    }

    /**
     * Total amount of all expense lines including tax.
     */
    public ExpenseReport withTotalAmount(double totalAmount) {
        Utils.checkNotNull(totalAmount, "totalAmount");
        this.totalAmount = JsonNullable.of(totalAmount);
        return this;
    }

    /**
     * Total amount of all expense lines including tax.
     */
    public ExpenseReport withTotalAmount(JsonNullable<Double> totalAmount) {
        Utils.checkNotNull(totalAmount, "totalAmount");
        this.totalAmount = totalAmount;
        return this;
    }

    /**
     * Total reimbursable amount (may differ from total if some expenses are non-reimbursable).
     */
    public ExpenseReport withReimbursableAmount(double reimbursableAmount) {
        Utils.checkNotNull(reimbursableAmount, "reimbursableAmount");
        this.reimbursableAmount = JsonNullable.of(reimbursableAmount);
        return this;
    }

    /**
     * Total reimbursable amount (may differ from total if some expenses are non-reimbursable).
     */
    public ExpenseReport withReimbursableAmount(JsonNullable<Double> reimbursableAmount) {
        Utils.checkNotNull(reimbursableAmount, "reimbursableAmount");
        this.reimbursableAmount = reimbursableAmount;
        return this;
    }

    /**
     * The memo of the expense report.
     */
    public ExpenseReport withMemo(String memo) {
        Utils.checkNotNull(memo, "memo");
        this.memo = JsonNullable.of(memo);
        return this;
    }

    /**
     * The memo of the expense report.
     */
    public ExpenseReport withMemo(JsonNullable<String> memo) {
        Utils.checkNotNull(memo, "memo");
        this.memo = memo;
        return this;
    }

    public ExpenseReport withDepartment(LinkedDepartment department) {
        Utils.checkNotNull(department, "department");
        this.department = JsonNullable.of(department);
        return this;
    }

    public ExpenseReport withDepartment(JsonNullable<? extends LinkedDepartment> department) {
        Utils.checkNotNull(department, "department");
        this.department = department;
        return this;
    }

    public ExpenseReport withLocation(LinkedLocation location) {
        Utils.checkNotNull(location, "location");
        this.location = JsonNullable.of(location);
        return this;
    }

    public ExpenseReport withLocation(JsonNullable<? extends LinkedLocation> location) {
        Utils.checkNotNull(location, "location");
        this.location = location;
        return this;
    }

    public ExpenseReport withAccount(LinkedLedgerAccount account) {
        Utils.checkNotNull(account, "account");
        this.account = JsonNullable.of(account);
        return this;
    }

    public ExpenseReport withAccount(JsonNullable<? extends LinkedLedgerAccount> account) {
        Utils.checkNotNull(account, "account");
        this.account = account;
        return this;
    }

    /**
     * The accounting period the expense report is posted to.
     */
    public ExpenseReport withAccountingPeriod(AccountingPeriod accountingPeriod) {
        Utils.checkNotNull(accountingPeriod, "accountingPeriod");
        this.accountingPeriod = JsonNullable.of(accountingPeriod);
        return this;
    }

    /**
     * The accounting period the expense report is posted to.
     */
    public ExpenseReport withAccountingPeriod(JsonNullable<? extends AccountingPeriod> accountingPeriod) {
        Utils.checkNotNull(accountingPeriod, "accountingPeriod");
        this.accountingPeriod = accountingPeriod;
        return this;
    }

    /**
     * Expense line items linked to this expense report.
     */
    public ExpenseReport withLineItems(List<ExpenseReportLineItem> lineItems) {
        Utils.checkNotNull(lineItems, "lineItems");
        this.lineItems = lineItems;
        return this;
    }

    public ExpenseReport withSubsidiary(LinkedSubsidiary subsidiary) {
        Utils.checkNotNull(subsidiary, "subsidiary");
        this.subsidiary = JsonNullable.of(subsidiary);
        return this;
    }

    public ExpenseReport withSubsidiary(JsonNullable<? extends LinkedSubsidiary> subsidiary) {
        Utils.checkNotNull(subsidiary, "subsidiary");
        this.subsidiary = subsidiary;
        return this;
    }

    /**
     * A list of linked tracking categories.
     */
    public ExpenseReport withTrackingCategories(List<LinkedTrackingCategory> trackingCategories) {
        Utils.checkNotNull(trackingCategories, "trackingCategories");
        this.trackingCategories = JsonNullable.of(trackingCategories);
        return this;
    }

    /**
     * A list of linked tracking categories.
     */
    public ExpenseReport withTrackingCategories(JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories) {
        Utils.checkNotNull(trackingCategories, "trackingCategories");
        this.trackingCategories = trackingCategories;
        return this;
    }

    /**
     * Amounts are including tax
     */
    public ExpenseReport withTaxInclusive(boolean taxInclusive) {
        Utils.checkNotNull(taxInclusive, "taxInclusive");
        this.taxInclusive = JsonNullable.of(taxInclusive);
        return this;
    }

    /**
     * Amounts are including tax
     */
    public ExpenseReport withTaxInclusive(JsonNullable<Boolean> taxInclusive) {
        Utils.checkNotNull(taxInclusive, "taxInclusive");
        this.taxInclusive = taxInclusive;
        return this;
    }

    /**
     * The person who approved the expense report.
     */
    public ExpenseReport withApprovedBy(ApprovedBy approvedBy) {
        Utils.checkNotNull(approvedBy, "approvedBy");
        this.approvedBy = JsonNullable.of(approvedBy);
        return this;
    }

    /**
     * The person who approved the expense report.
     */
    public ExpenseReport withApprovedBy(JsonNullable<? extends ApprovedBy> approvedBy) {
        Utils.checkNotNull(approvedBy, "approvedBy");
        this.approvedBy = approvedBy;
        return this;
    }

    public ExpenseReport withCustomFields(List<CustomField> customFields) {
        Utils.checkNotNull(customFields, "customFields");
        this.customFields = Optional.ofNullable(customFields);
        return this;
    }


    public ExpenseReport withCustomFields(Optional<? extends List<CustomField>> customFields) {
        Utils.checkNotNull(customFields, "customFields");
        this.customFields = customFields;
        return this;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public ExpenseReport withCustomMappings(Map<String, Object> customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = JsonNullable.of(customMappings);
        return this;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public ExpenseReport withCustomMappings(JsonNullable<? extends Map<String, Object>> customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = customMappings;
        return this;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each
     * time an update is made to the object.
     */
    public ExpenseReport withRowVersion(String rowVersion) {
        Utils.checkNotNull(rowVersion, "rowVersion");
        this.rowVersion = JsonNullable.of(rowVersion);
        return this;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each
     * time an update is made to the object.
     */
    public ExpenseReport withRowVersion(JsonNullable<String> rowVersion) {
        Utils.checkNotNull(rowVersion, "rowVersion");
        this.rowVersion = rowVersion;
        return this;
    }

    /**
     * The user who last updated the object.
     */
    public ExpenseReport withUpdatedBy(String updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = JsonNullable.of(updatedBy);
        return this;
    }

    /**
     * The user who last updated the object.
     */
    public ExpenseReport withUpdatedBy(JsonNullable<String> updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = updatedBy;
        return this;
    }

    /**
     * The user who created the object.
     */
    public ExpenseReport withCreatedBy(String createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = JsonNullable.of(createdBy);
        return this;
    }

    /**
     * The user who created the object.
     */
    public ExpenseReport withCreatedBy(JsonNullable<String> createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = createdBy;
        return this;
    }

    /**
     * The date and time when the object was last updated.
     */
    public ExpenseReport withUpdatedAt(OffsetDateTime updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = JsonNullable.of(updatedAt);
        return this;
    }

    /**
     * The date and time when the object was last updated.
     */
    public ExpenseReport withUpdatedAt(JsonNullable<OffsetDateTime> updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = updatedAt;
        return this;
    }

    /**
     * The date and time when the object was created.
     */
    public ExpenseReport withCreatedAt(OffsetDateTime createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = JsonNullable.of(createdAt);
        return this;
    }

    /**
     * The date and time when the object was created.
     */
    public ExpenseReport withCreatedAt(JsonNullable<OffsetDateTime> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications
     * in request body when creating or updating resources.
     */
    public ExpenseReport withPassThrough(List<PassThroughBody> passThrough) {
        Utils.checkNotNull(passThrough, "passThrough");
        this.passThrough = Optional.ofNullable(passThrough);
        return this;
    }


    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications
     * in request body when creating or updating resources.
     */
    public ExpenseReport withPassThrough(Optional<? extends List<PassThroughBody>> passThrough) {
        Utils.checkNotNull(passThrough, "passThrough");
        this.passThrough = passThrough;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ExpenseReport other = (ExpenseReport) o;
        return 
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.displayId, other.displayId) &&
            Utils.enhancedDeepEquals(this.number, other.number) &&
            Utils.enhancedDeepEquals(this.title, other.title) &&
            Utils.enhancedDeepEquals(this.employee, other.employee) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.transactionDate, other.transactionDate) &&
            Utils.enhancedDeepEquals(this.postingDate, other.postingDate) &&
            Utils.enhancedDeepEquals(this.dueDate, other.dueDate) &&
            Utils.enhancedDeepEquals(this.currency, other.currency) &&
            Utils.enhancedDeepEquals(this.currencyRate, other.currencyRate) &&
            Utils.enhancedDeepEquals(this.subTotal, other.subTotal) &&
            Utils.enhancedDeepEquals(this.totalTax, other.totalTax) &&
            Utils.enhancedDeepEquals(this.totalAmount, other.totalAmount) &&
            Utils.enhancedDeepEquals(this.reimbursableAmount, other.reimbursableAmount) &&
            Utils.enhancedDeepEquals(this.memo, other.memo) &&
            Utils.enhancedDeepEquals(this.department, other.department) &&
            Utils.enhancedDeepEquals(this.location, other.location) &&
            Utils.enhancedDeepEquals(this.account, other.account) &&
            Utils.enhancedDeepEquals(this.accountingPeriod, other.accountingPeriod) &&
            Utils.enhancedDeepEquals(this.lineItems, other.lineItems) &&
            Utils.enhancedDeepEquals(this.subsidiary, other.subsidiary) &&
            Utils.enhancedDeepEquals(this.trackingCategories, other.trackingCategories) &&
            Utils.enhancedDeepEquals(this.taxInclusive, other.taxInclusive) &&
            Utils.enhancedDeepEquals(this.approvedBy, other.approvedBy) &&
            Utils.enhancedDeepEquals(this.customFields, other.customFields) &&
            Utils.enhancedDeepEquals(this.customMappings, other.customMappings) &&
            Utils.enhancedDeepEquals(this.rowVersion, other.rowVersion) &&
            Utils.enhancedDeepEquals(this.updatedBy, other.updatedBy) &&
            Utils.enhancedDeepEquals(this.createdBy, other.createdBy) &&
            Utils.enhancedDeepEquals(this.updatedAt, other.updatedAt) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.passThrough, other.passThrough);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            id, displayId, number,
            title, employee, status,
            transactionDate, postingDate, dueDate,
            currency, currencyRate, subTotal,
            totalTax, totalAmount, reimbursableAmount,
            memo, department, location,
            account, accountingPeriod, lineItems,
            subsidiary, trackingCategories, taxInclusive,
            approvedBy, customFields, customMappings,
            rowVersion, updatedBy, createdBy,
            updatedAt, createdAt, passThrough);
    }
    
    @Override
    public String toString() {
        return Utils.toString(ExpenseReport.class,
                "id", id,
                "displayId", displayId,
                "number", number,
                "title", title,
                "employee", employee,
                "status", status,
                "transactionDate", transactionDate,
                "postingDate", postingDate,
                "dueDate", dueDate,
                "currency", currency,
                "currencyRate", currencyRate,
                "subTotal", subTotal,
                "totalTax", totalTax,
                "totalAmount", totalAmount,
                "reimbursableAmount", reimbursableAmount,
                "memo", memo,
                "department", department,
                "location", location,
                "account", account,
                "accountingPeriod", accountingPeriod,
                "lineItems", lineItems,
                "subsidiary", subsidiary,
                "trackingCategories", trackingCategories,
                "taxInclusive", taxInclusive,
                "approvedBy", approvedBy,
                "customFields", customFields,
                "customMappings", customMappings,
                "rowVersion", rowVersion,
                "updatedBy", updatedBy,
                "createdBy", createdBy,
                "updatedAt", updatedAt,
                "createdAt", createdAt,
                "passThrough", passThrough);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<String> id = Optional.empty();

        private JsonNullable<String> displayId = JsonNullable.undefined();

        private JsonNullable<String> number = JsonNullable.undefined();

        private JsonNullable<String> title = JsonNullable.undefined();

        private ExpenseReportEmployee employee;

        private JsonNullable<? extends ExpenseReportStatus> status = JsonNullable.undefined();

        private Optional<OffsetDateTime> transactionDate = Optional.empty();

        private JsonNullable<LocalDate> postingDate = JsonNullable.undefined();

        private JsonNullable<LocalDate> dueDate = JsonNullable.undefined();

        private JsonNullable<? extends Currency> currency = JsonNullable.undefined();

        private JsonNullable<Double> currencyRate = JsonNullable.undefined();

        private JsonNullable<Double> subTotal = JsonNullable.undefined();

        private JsonNullable<Double> totalTax = JsonNullable.undefined();

        private JsonNullable<Double> totalAmount = JsonNullable.undefined();

        private JsonNullable<Double> reimbursableAmount = JsonNullable.undefined();

        private JsonNullable<String> memo = JsonNullable.undefined();

        private JsonNullable<? extends LinkedDepartment> department = JsonNullable.undefined();

        private JsonNullable<? extends LinkedLocation> location = JsonNullable.undefined();

        private JsonNullable<? extends LinkedLedgerAccount> account = JsonNullable.undefined();

        private JsonNullable<? extends AccountingPeriod> accountingPeriod = JsonNullable.undefined();

        private List<ExpenseReportLineItem> lineItems;

        private JsonNullable<? extends LinkedSubsidiary> subsidiary = JsonNullable.undefined();

        private JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories = JsonNullable.undefined();

        private JsonNullable<Boolean> taxInclusive = JsonNullable.undefined();

        private JsonNullable<? extends ApprovedBy> approvedBy = JsonNullable.undefined();

        private Optional<? extends List<CustomField>> customFields = Optional.empty();

        private JsonNullable<? extends Map<String, Object>> customMappings = JsonNullable.undefined();

        private JsonNullable<String> rowVersion = JsonNullable.undefined();

        private JsonNullable<String> updatedBy = JsonNullable.undefined();

        private JsonNullable<String> createdBy = JsonNullable.undefined();

        private JsonNullable<OffsetDateTime> updatedAt = JsonNullable.undefined();

        private JsonNullable<OffsetDateTime> createdAt = JsonNullable.undefined();

        private Optional<? extends List<PassThroughBody>> passThrough = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * A unique identifier for an object.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * A unique identifier for an object.
         */
        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        /**
         * Id to be displayed.
         */
        public Builder displayId(String displayId) {
            Utils.checkNotNull(displayId, "displayId");
            this.displayId = JsonNullable.of(displayId);
            return this;
        }

        /**
         * Id to be displayed.
         */
        public Builder displayId(JsonNullable<String> displayId) {
            Utils.checkNotNull(displayId, "displayId");
            this.displayId = displayId;
            return this;
        }


        /**
         * The expense report number.
         */
        public Builder number(String number) {
            Utils.checkNotNull(number, "number");
            this.number = JsonNullable.of(number);
            return this;
        }

        /**
         * The expense report number.
         */
        public Builder number(JsonNullable<String> number) {
            Utils.checkNotNull(number, "number");
            this.number = number;
            return this;
        }


        /**
         * Title or purpose of the expense report.
         */
        public Builder title(String title) {
            Utils.checkNotNull(title, "title");
            this.title = JsonNullable.of(title);
            return this;
        }

        /**
         * Title or purpose of the expense report.
         */
        public Builder title(JsonNullable<String> title) {
            Utils.checkNotNull(title, "title");
            this.title = title;
            return this;
        }


        /**
         * The employee who submitted the expense report.
         */
        public Builder employee(ExpenseReportEmployee employee) {
            Utils.checkNotNull(employee, "employee");
            this.employee = employee;
            return this;
        }


        /**
         * The status of the expense report.
         */
        public Builder status(ExpenseReportStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = JsonNullable.of(status);
            return this;
        }

        /**
         * The status of the expense report.
         */
        public Builder status(JsonNullable<? extends ExpenseReportStatus> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }


        /**
         * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
         */
        public Builder transactionDate(OffsetDateTime transactionDate) {
            Utils.checkNotNull(transactionDate, "transactionDate");
            this.transactionDate = Optional.ofNullable(transactionDate);
            return this;
        }

        /**
         * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
         */
        public Builder transactionDate(Optional<OffsetDateTime> transactionDate) {
            Utils.checkNotNull(transactionDate, "transactionDate");
            this.transactionDate = transactionDate;
            return this;
        }


        /**
         * The date the expense report was posted to the general ledger.
         */
        public Builder postingDate(LocalDate postingDate) {
            Utils.checkNotNull(postingDate, "postingDate");
            this.postingDate = JsonNullable.of(postingDate);
            return this;
        }

        /**
         * The date the expense report was posted to the general ledger.
         */
        public Builder postingDate(JsonNullable<LocalDate> postingDate) {
            Utils.checkNotNull(postingDate, "postingDate");
            this.postingDate = postingDate;
            return this;
        }


        /**
         * Date when reimbursement is due.
         */
        public Builder dueDate(LocalDate dueDate) {
            Utils.checkNotNull(dueDate, "dueDate");
            this.dueDate = JsonNullable.of(dueDate);
            return this;
        }

        /**
         * Date when reimbursement is due.
         */
        public Builder dueDate(JsonNullable<LocalDate> dueDate) {
            Utils.checkNotNull(dueDate, "dueDate");
            this.dueDate = dueDate;
            return this;
        }


        /**
         * Indicates the associated currency for an amount of money. Values correspond to [ISO
         * 4217](https://en.wikipedia.org/wiki/ISO_4217).
         */
        public Builder currency(Currency currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = JsonNullable.of(currency);
            return this;
        }

        /**
         * Indicates the associated currency for an amount of money. Values correspond to [ISO
         * 4217](https://en.wikipedia.org/wiki/ISO_4217).
         */
        public Builder currency(JsonNullable<? extends Currency> currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = currency;
            return this;
        }


        /**
         * Currency Exchange Rate at the time entity was recorded/generated.
         */
        public Builder currencyRate(double currencyRate) {
            Utils.checkNotNull(currencyRate, "currencyRate");
            this.currencyRate = JsonNullable.of(currencyRate);
            return this;
        }

        /**
         * Currency Exchange Rate at the time entity was recorded/generated.
         */
        public Builder currencyRate(JsonNullable<Double> currencyRate) {
            Utils.checkNotNull(currencyRate, "currencyRate");
            this.currencyRate = currencyRate;
            return this;
        }


        /**
         * Subtotal amount, normally before tax.
         */
        public Builder subTotal(double subTotal) {
            Utils.checkNotNull(subTotal, "subTotal");
            this.subTotal = JsonNullable.of(subTotal);
            return this;
        }

        /**
         * Subtotal amount, normally before tax.
         */
        public Builder subTotal(JsonNullable<Double> subTotal) {
            Utils.checkNotNull(subTotal, "subTotal");
            this.subTotal = subTotal;
            return this;
        }


        /**
         * Total tax amount applied to this transaction.
         */
        public Builder totalTax(double totalTax) {
            Utils.checkNotNull(totalTax, "totalTax");
            this.totalTax = JsonNullable.of(totalTax);
            return this;
        }

        /**
         * Total tax amount applied to this transaction.
         */
        public Builder totalTax(JsonNullable<Double> totalTax) {
            Utils.checkNotNull(totalTax, "totalTax");
            this.totalTax = totalTax;
            return this;
        }


        /**
         * Total amount of all expense lines including tax.
         */
        public Builder totalAmount(double totalAmount) {
            Utils.checkNotNull(totalAmount, "totalAmount");
            this.totalAmount = JsonNullable.of(totalAmount);
            return this;
        }

        /**
         * Total amount of all expense lines including tax.
         */
        public Builder totalAmount(JsonNullable<Double> totalAmount) {
            Utils.checkNotNull(totalAmount, "totalAmount");
            this.totalAmount = totalAmount;
            return this;
        }


        /**
         * Total reimbursable amount (may differ from total if some expenses are non-reimbursable).
         */
        public Builder reimbursableAmount(double reimbursableAmount) {
            Utils.checkNotNull(reimbursableAmount, "reimbursableAmount");
            this.reimbursableAmount = JsonNullable.of(reimbursableAmount);
            return this;
        }

        /**
         * Total reimbursable amount (may differ from total if some expenses are non-reimbursable).
         */
        public Builder reimbursableAmount(JsonNullable<Double> reimbursableAmount) {
            Utils.checkNotNull(reimbursableAmount, "reimbursableAmount");
            this.reimbursableAmount = reimbursableAmount;
            return this;
        }


        /**
         * The memo of the expense report.
         */
        public Builder memo(String memo) {
            Utils.checkNotNull(memo, "memo");
            this.memo = JsonNullable.of(memo);
            return this;
        }

        /**
         * The memo of the expense report.
         */
        public Builder memo(JsonNullable<String> memo) {
            Utils.checkNotNull(memo, "memo");
            this.memo = memo;
            return this;
        }


        public Builder department(LinkedDepartment department) {
            Utils.checkNotNull(department, "department");
            this.department = JsonNullable.of(department);
            return this;
        }

        public Builder department(JsonNullable<? extends LinkedDepartment> department) {
            Utils.checkNotNull(department, "department");
            this.department = department;
            return this;
        }


        public Builder location(LinkedLocation location) {
            Utils.checkNotNull(location, "location");
            this.location = JsonNullable.of(location);
            return this;
        }

        public Builder location(JsonNullable<? extends LinkedLocation> location) {
            Utils.checkNotNull(location, "location");
            this.location = location;
            return this;
        }


        public Builder account(LinkedLedgerAccount account) {
            Utils.checkNotNull(account, "account");
            this.account = JsonNullable.of(account);
            return this;
        }

        public Builder account(JsonNullable<? extends LinkedLedgerAccount> account) {
            Utils.checkNotNull(account, "account");
            this.account = account;
            return this;
        }


        /**
         * The accounting period the expense report is posted to.
         */
        public Builder accountingPeriod(AccountingPeriod accountingPeriod) {
            Utils.checkNotNull(accountingPeriod, "accountingPeriod");
            this.accountingPeriod = JsonNullable.of(accountingPeriod);
            return this;
        }

        /**
         * The accounting period the expense report is posted to.
         */
        public Builder accountingPeriod(JsonNullable<? extends AccountingPeriod> accountingPeriod) {
            Utils.checkNotNull(accountingPeriod, "accountingPeriod");
            this.accountingPeriod = accountingPeriod;
            return this;
        }


        /**
         * Expense line items linked to this expense report.
         */
        public Builder lineItems(List<ExpenseReportLineItem> lineItems) {
            Utils.checkNotNull(lineItems, "lineItems");
            this.lineItems = lineItems;
            return this;
        }


        public Builder subsidiary(LinkedSubsidiary subsidiary) {
            Utils.checkNotNull(subsidiary, "subsidiary");
            this.subsidiary = JsonNullable.of(subsidiary);
            return this;
        }

        public Builder subsidiary(JsonNullable<? extends LinkedSubsidiary> subsidiary) {
            Utils.checkNotNull(subsidiary, "subsidiary");
            this.subsidiary = subsidiary;
            return this;
        }


        /**
         * A list of linked tracking categories.
         */
        public Builder trackingCategories(List<LinkedTrackingCategory> trackingCategories) {
            Utils.checkNotNull(trackingCategories, "trackingCategories");
            this.trackingCategories = JsonNullable.of(trackingCategories);
            return this;
        }

        /**
         * A list of linked tracking categories.
         */
        public Builder trackingCategories(JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories) {
            Utils.checkNotNull(trackingCategories, "trackingCategories");
            this.trackingCategories = trackingCategories;
            return this;
        }


        /**
         * Amounts are including tax
         */
        public Builder taxInclusive(boolean taxInclusive) {
            Utils.checkNotNull(taxInclusive, "taxInclusive");
            this.taxInclusive = JsonNullable.of(taxInclusive);
            return this;
        }

        /**
         * Amounts are including tax
         */
        public Builder taxInclusive(JsonNullable<Boolean> taxInclusive) {
            Utils.checkNotNull(taxInclusive, "taxInclusive");
            this.taxInclusive = taxInclusive;
            return this;
        }


        /**
         * The person who approved the expense report.
         */
        public Builder approvedBy(ApprovedBy approvedBy) {
            Utils.checkNotNull(approvedBy, "approvedBy");
            this.approvedBy = JsonNullable.of(approvedBy);
            return this;
        }

        /**
         * The person who approved the expense report.
         */
        public Builder approvedBy(JsonNullable<? extends ApprovedBy> approvedBy) {
            Utils.checkNotNull(approvedBy, "approvedBy");
            this.approvedBy = approvedBy;
            return this;
        }


        public Builder customFields(List<CustomField> customFields) {
            Utils.checkNotNull(customFields, "customFields");
            this.customFields = Optional.ofNullable(customFields);
            return this;
        }

        public Builder customFields(Optional<? extends List<CustomField>> customFields) {
            Utils.checkNotNull(customFields, "customFields");
            this.customFields = customFields;
            return this;
        }


        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(Map<String, Object> customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = JsonNullable.of(customMappings);
            return this;
        }

        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(JsonNullable<? extends Map<String, Object>> customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = customMappings;
            return this;
        }


        /**
         * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each
         * time an update is made to the object.
         */
        public Builder rowVersion(String rowVersion) {
            Utils.checkNotNull(rowVersion, "rowVersion");
            this.rowVersion = JsonNullable.of(rowVersion);
            return this;
        }

        /**
         * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each
         * time an update is made to the object.
         */
        public Builder rowVersion(JsonNullable<String> rowVersion) {
            Utils.checkNotNull(rowVersion, "rowVersion");
            this.rowVersion = rowVersion;
            return this;
        }


        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(String updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = JsonNullable.of(updatedBy);
            return this;
        }

        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(JsonNullable<String> updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = updatedBy;
            return this;
        }


        /**
         * The user who created the object.
         */
        public Builder createdBy(String createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = JsonNullable.of(createdBy);
            return this;
        }

        /**
         * The user who created the object.
         */
        public Builder createdBy(JsonNullable<String> createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = createdBy;
            return this;
        }


        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(OffsetDateTime updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = JsonNullable.of(updatedAt);
            return this;
        }

        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(JsonNullable<OffsetDateTime> updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = updatedAt;
            return this;
        }


        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(OffsetDateTime createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = JsonNullable.of(createdAt);
            return this;
        }

        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(JsonNullable<OffsetDateTime> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }


        /**
         * The pass_through property allows passing service-specific, custom data or structured modifications
         * in request body when creating or updating resources.
         */
        public Builder passThrough(List<PassThroughBody> passThrough) {
            Utils.checkNotNull(passThrough, "passThrough");
            this.passThrough = Optional.ofNullable(passThrough);
            return this;
        }

        /**
         * The pass_through property allows passing service-specific, custom data or structured modifications
         * in request body when creating or updating resources.
         */
        public Builder passThrough(Optional<? extends List<PassThroughBody>> passThrough) {
            Utils.checkNotNull(passThrough, "passThrough");
            this.passThrough = passThrough;
            return this;
        }

        public ExpenseReport build() {

            return new ExpenseReport(
                id, displayId, number,
                title, employee, status,
                transactionDate, postingDate, dueDate,
                currency, currencyRate, subTotal,
                totalTax, totalAmount, reimbursableAmount,
                memo, department, location,
                account, accountingPeriod, lineItems,
                subsidiary, trackingCategories, taxInclusive,
                approvedBy, customFields, customMappings,
                rowVersion, updatedBy, createdBy,
                updatedAt, createdAt, passThrough);
        }

    }
}
