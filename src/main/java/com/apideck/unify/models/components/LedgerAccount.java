/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package com.apideck.unify.models.components;


import com.apideck.unify.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Boolean;
import java.lang.Deprecated;
import java.lang.Double;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class LedgerAccount {

    /**
     * A unique identifier for an object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * The human readable display ID used when displaying the account
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("display_id")
    private Optional<String> displayId;

    /**
     * The nominal code of the ledger account.
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("nominal_code")
    @Deprecated
    private JsonNullable<String> nominalCode;

    /**
     * The code assigned to the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("code")
    private JsonNullable<String> code;

    /**
     * The classification of account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("classification")
    private JsonNullable<? extends Classification> classification;

    /**
     * The type of account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("type")
    private Optional<? extends LedgerAccountType> type;

    /**
     * The sub type of account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sub_type")
    private JsonNullable<String> subType;

    /**
     * The name of the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("name")
    private JsonNullable<String> name;

    /**
     * The fully qualified name of the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fully_qualified_name")
    private JsonNullable<String> fullyQualifiedName;

    /**
     * The description of the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private JsonNullable<String> description;

    /**
     * The opening balance of the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("opening_balance")
    private JsonNullable<Double> openingBalance;

    /**
     * The current balance of the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("current_balance")
    private JsonNullable<Double> currentBalance;

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency")
    private JsonNullable<? extends Currency> currency;

    /**
     * The tax type of the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tax_type")
    private JsonNullable<String> taxType;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tax_rate")
    private Optional<? extends LinkedTaxRate> taxRate;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("level")
    private JsonNullable<Double> level;

    /**
     * Whether the account is active or not.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("active")
    private JsonNullable<Boolean> active;

    /**
     * The status of the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private JsonNullable<? extends AccountStatus> status;

    /**
     * Whether the account is a header or not.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("header")
    private JsonNullable<Boolean> header;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bank_account")
    private Optional<? extends BankAccount> bankAccount;

    /**
     * The categories of the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("categories")
    private Optional<? extends List<Categories>> categories;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parent_account")
    private Optional<? extends ParentAccount> parentAccount;

    /**
     * Whether the account is a sub account or not.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sub_account")
    private JsonNullable<Boolean> subAccount;

    /**
     * The sub accounts of the account.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sub_accounts")
    private Optional<? extends List<SubAccounts>> subAccounts;

    /**
     * Reconciliation Date means the last calendar day of each Reconciliation Period.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("last_reconciliation_date")
    private JsonNullable<LocalDate> lastReconciliationDate;

    /**
     * The subsidiaries the account belongs to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subsidiaries")
    private Optional<? extends List<Subsidiaries>> subsidiaries;

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_mappings")
    private JsonNullable<? extends CustomMappings> customMappings;

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("row_version")
    private JsonNullable<String> rowVersion;

    /**
     * The user who last updated the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_by")
    private JsonNullable<String> updatedBy;

    /**
     * The user who created the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_by")
    private JsonNullable<String> createdBy;

    /**
     * The date and time when the object was last updated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_at")
    private JsonNullable<OffsetDateTime> updatedAt;

    /**
     * The date and time when the object was created.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_at")
    private JsonNullable<OffsetDateTime> createdAt;

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pass_through")
    private Optional<? extends List<PassThroughBody>> passThrough;

    @JsonCreator
    public LedgerAccount(
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("display_id") Optional<String> displayId,
            @JsonProperty("nominal_code") JsonNullable<String> nominalCode,
            @JsonProperty("code") JsonNullable<String> code,
            @JsonProperty("classification") JsonNullable<? extends Classification> classification,
            @JsonProperty("type") Optional<? extends LedgerAccountType> type,
            @JsonProperty("sub_type") JsonNullable<String> subType,
            @JsonProperty("name") JsonNullable<String> name,
            @JsonProperty("fully_qualified_name") JsonNullable<String> fullyQualifiedName,
            @JsonProperty("description") JsonNullable<String> description,
            @JsonProperty("opening_balance") JsonNullable<Double> openingBalance,
            @JsonProperty("current_balance") JsonNullable<Double> currentBalance,
            @JsonProperty("currency") JsonNullable<? extends Currency> currency,
            @JsonProperty("tax_type") JsonNullable<String> taxType,
            @JsonProperty("tax_rate") Optional<? extends LinkedTaxRate> taxRate,
            @JsonProperty("level") JsonNullable<Double> level,
            @JsonProperty("active") JsonNullable<Boolean> active,
            @JsonProperty("status") JsonNullable<? extends AccountStatus> status,
            @JsonProperty("header") JsonNullable<Boolean> header,
            @JsonProperty("bank_account") Optional<? extends BankAccount> bankAccount,
            @JsonProperty("categories") Optional<? extends List<Categories>> categories,
            @JsonProperty("parent_account") Optional<? extends ParentAccount> parentAccount,
            @JsonProperty("sub_account") JsonNullable<Boolean> subAccount,
            @JsonProperty("sub_accounts") Optional<? extends List<SubAccounts>> subAccounts,
            @JsonProperty("last_reconciliation_date") JsonNullable<LocalDate> lastReconciliationDate,
            @JsonProperty("subsidiaries") Optional<? extends List<Subsidiaries>> subsidiaries,
            @JsonProperty("custom_mappings") JsonNullable<? extends CustomMappings> customMappings,
            @JsonProperty("row_version") JsonNullable<String> rowVersion,
            @JsonProperty("updated_by") JsonNullable<String> updatedBy,
            @JsonProperty("created_by") JsonNullable<String> createdBy,
            @JsonProperty("updated_at") JsonNullable<OffsetDateTime> updatedAt,
            @JsonProperty("created_at") JsonNullable<OffsetDateTime> createdAt,
            @JsonProperty("pass_through") Optional<? extends List<PassThroughBody>> passThrough) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(displayId, "displayId");
        Utils.checkNotNull(nominalCode, "nominalCode");
        Utils.checkNotNull(code, "code");
        Utils.checkNotNull(classification, "classification");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(subType, "subType");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(fullyQualifiedName, "fullyQualifiedName");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(openingBalance, "openingBalance");
        Utils.checkNotNull(currentBalance, "currentBalance");
        Utils.checkNotNull(currency, "currency");
        Utils.checkNotNull(taxType, "taxType");
        Utils.checkNotNull(taxRate, "taxRate");
        Utils.checkNotNull(level, "level");
        Utils.checkNotNull(active, "active");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(header, "header");
        Utils.checkNotNull(bankAccount, "bankAccount");
        Utils.checkNotNull(categories, "categories");
        Utils.checkNotNull(parentAccount, "parentAccount");
        Utils.checkNotNull(subAccount, "subAccount");
        Utils.checkNotNull(subAccounts, "subAccounts");
        Utils.checkNotNull(lastReconciliationDate, "lastReconciliationDate");
        Utils.checkNotNull(subsidiaries, "subsidiaries");
        Utils.checkNotNull(customMappings, "customMappings");
        Utils.checkNotNull(rowVersion, "rowVersion");
        Utils.checkNotNull(updatedBy, "updatedBy");
        Utils.checkNotNull(createdBy, "createdBy");
        Utils.checkNotNull(updatedAt, "updatedAt");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(passThrough, "passThrough");
        this.id = id;
        this.displayId = displayId;
        this.nominalCode = nominalCode;
        this.code = code;
        this.classification = classification;
        this.type = type;
        this.subType = subType;
        this.name = name;
        this.fullyQualifiedName = fullyQualifiedName;
        this.description = description;
        this.openingBalance = openingBalance;
        this.currentBalance = currentBalance;
        this.currency = currency;
        this.taxType = taxType;
        this.taxRate = taxRate;
        this.level = level;
        this.active = active;
        this.status = status;
        this.header = header;
        this.bankAccount = bankAccount;
        this.categories = categories;
        this.parentAccount = parentAccount;
        this.subAccount = subAccount;
        this.subAccounts = subAccounts;
        this.lastReconciliationDate = lastReconciliationDate;
        this.subsidiaries = subsidiaries;
        this.customMappings = customMappings;
        this.rowVersion = rowVersion;
        this.updatedBy = updatedBy;
        this.createdBy = createdBy;
        this.updatedAt = updatedAt;
        this.createdAt = createdAt;
        this.passThrough = passThrough;
    }
    
    public LedgerAccount() {
        this(Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty());
    }

    /**
     * A unique identifier for an object.
     */
    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * The human readable display ID used when displaying the account
     */
    @JsonIgnore
    public Optional<String> displayId() {
        return displayId;
    }

    /**
     * The nominal code of the ledger account.
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    @JsonIgnore
    public JsonNullable<String> nominalCode() {
        return nominalCode;
    }

    /**
     * The code assigned to the account.
     */
    @JsonIgnore
    public JsonNullable<String> code() {
        return code;
    }

    /**
     * The classification of account.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Classification> classification() {
        return (JsonNullable<Classification>) classification;
    }

    /**
     * The type of account.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<LedgerAccountType> type() {
        return (Optional<LedgerAccountType>) type;
    }

    /**
     * The sub type of account.
     */
    @JsonIgnore
    public JsonNullable<String> subType() {
        return subType;
    }

    /**
     * The name of the account.
     */
    @JsonIgnore
    public JsonNullable<String> name() {
        return name;
    }

    /**
     * The fully qualified name of the account.
     */
    @JsonIgnore
    public JsonNullable<String> fullyQualifiedName() {
        return fullyQualifiedName;
    }

    /**
     * The description of the account.
     */
    @JsonIgnore
    public JsonNullable<String> description() {
        return description;
    }

    /**
     * The opening balance of the account.
     */
    @JsonIgnore
    public JsonNullable<Double> openingBalance() {
        return openingBalance;
    }

    /**
     * The current balance of the account.
     */
    @JsonIgnore
    public JsonNullable<Double> currentBalance() {
        return currentBalance;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Currency> currency() {
        return (JsonNullable<Currency>) currency;
    }

    /**
     * The tax type of the account.
     */
    @JsonIgnore
    public JsonNullable<String> taxType() {
        return taxType;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<LinkedTaxRate> taxRate() {
        return (Optional<LinkedTaxRate>) taxRate;
    }

    @JsonIgnore
    public JsonNullable<Double> level() {
        return level;
    }

    /**
     * Whether the account is active or not.
     */
    @JsonIgnore
    public JsonNullable<Boolean> active() {
        return active;
    }

    /**
     * The status of the account.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<AccountStatus> status() {
        return (JsonNullable<AccountStatus>) status;
    }

    /**
     * Whether the account is a header or not.
     */
    @JsonIgnore
    public JsonNullable<Boolean> header() {
        return header;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BankAccount> bankAccount() {
        return (Optional<BankAccount>) bankAccount;
    }

    /**
     * The categories of the account.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Categories>> categories() {
        return (Optional<List<Categories>>) categories;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<ParentAccount> parentAccount() {
        return (Optional<ParentAccount>) parentAccount;
    }

    /**
     * Whether the account is a sub account or not.
     */
    @JsonIgnore
    public JsonNullable<Boolean> subAccount() {
        return subAccount;
    }

    /**
     * The sub accounts of the account.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<SubAccounts>> subAccounts() {
        return (Optional<List<SubAccounts>>) subAccounts;
    }

    /**
     * Reconciliation Date means the last calendar day of each Reconciliation Period.
     */
    @JsonIgnore
    public JsonNullable<LocalDate> lastReconciliationDate() {
        return lastReconciliationDate;
    }

    /**
     * The subsidiaries the account belongs to.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<Subsidiaries>> subsidiaries() {
        return (Optional<List<Subsidiaries>>) subsidiaries;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CustomMappings> customMappings() {
        return (JsonNullable<CustomMappings>) customMappings;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    @JsonIgnore
    public JsonNullable<String> rowVersion() {
        return rowVersion;
    }

    /**
     * The user who last updated the object.
     */
    @JsonIgnore
    public JsonNullable<String> updatedBy() {
        return updatedBy;
    }

    /**
     * The user who created the object.
     */
    @JsonIgnore
    public JsonNullable<String> createdBy() {
        return createdBy;
    }

    /**
     * The date and time when the object was last updated.
     */
    @JsonIgnore
    public JsonNullable<OffsetDateTime> updatedAt() {
        return updatedAt;
    }

    /**
     * The date and time when the object was created.
     */
    @JsonIgnore
    public JsonNullable<OffsetDateTime> createdAt() {
        return createdAt;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PassThroughBody>> passThrough() {
        return (Optional<List<PassThroughBody>>) passThrough;
    }

    public final static Builder builder() {
        return new Builder();
    }

    /**
     * A unique identifier for an object.
     */
    public LedgerAccount withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }

    /**
     * A unique identifier for an object.
     */
    public LedgerAccount withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * The human readable display ID used when displaying the account
     */
    public LedgerAccount withDisplayId(String displayId) {
        Utils.checkNotNull(displayId, "displayId");
        this.displayId = Optional.ofNullable(displayId);
        return this;
    }

    /**
     * The human readable display ID used when displaying the account
     */
    public LedgerAccount withDisplayId(Optional<String> displayId) {
        Utils.checkNotNull(displayId, "displayId");
        this.displayId = displayId;
        return this;
    }

    /**
     * The nominal code of the ledger account.
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public LedgerAccount withNominalCode(String nominalCode) {
        Utils.checkNotNull(nominalCode, "nominalCode");
        this.nominalCode = JsonNullable.of(nominalCode);
        return this;
    }

    /**
     * The nominal code of the ledger account.
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    @Deprecated
    public LedgerAccount withNominalCode(JsonNullable<String> nominalCode) {
        Utils.checkNotNull(nominalCode, "nominalCode");
        this.nominalCode = nominalCode;
        return this;
    }

    /**
     * The code assigned to the account.
     */
    public LedgerAccount withCode(String code) {
        Utils.checkNotNull(code, "code");
        this.code = JsonNullable.of(code);
        return this;
    }

    /**
     * The code assigned to the account.
     */
    public LedgerAccount withCode(JsonNullable<String> code) {
        Utils.checkNotNull(code, "code");
        this.code = code;
        return this;
    }

    /**
     * The classification of account.
     */
    public LedgerAccount withClassification(Classification classification) {
        Utils.checkNotNull(classification, "classification");
        this.classification = JsonNullable.of(classification);
        return this;
    }

    /**
     * The classification of account.
     */
    public LedgerAccount withClassification(JsonNullable<? extends Classification> classification) {
        Utils.checkNotNull(classification, "classification");
        this.classification = classification;
        return this;
    }

    /**
     * The type of account.
     */
    public LedgerAccount withType(LedgerAccountType type) {
        Utils.checkNotNull(type, "type");
        this.type = Optional.ofNullable(type);
        return this;
    }

    /**
     * The type of account.
     */
    public LedgerAccount withType(Optional<? extends LedgerAccountType> type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * The sub type of account.
     */
    public LedgerAccount withSubType(String subType) {
        Utils.checkNotNull(subType, "subType");
        this.subType = JsonNullable.of(subType);
        return this;
    }

    /**
     * The sub type of account.
     */
    public LedgerAccount withSubType(JsonNullable<String> subType) {
        Utils.checkNotNull(subType, "subType");
        this.subType = subType;
        return this;
    }

    /**
     * The name of the account.
     */
    public LedgerAccount withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = JsonNullable.of(name);
        return this;
    }

    /**
     * The name of the account.
     */
    public LedgerAccount withName(JsonNullable<String> name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    /**
     * The fully qualified name of the account.
     */
    public LedgerAccount withFullyQualifiedName(String fullyQualifiedName) {
        Utils.checkNotNull(fullyQualifiedName, "fullyQualifiedName");
        this.fullyQualifiedName = JsonNullable.of(fullyQualifiedName);
        return this;
    }

    /**
     * The fully qualified name of the account.
     */
    public LedgerAccount withFullyQualifiedName(JsonNullable<String> fullyQualifiedName) {
        Utils.checkNotNull(fullyQualifiedName, "fullyQualifiedName");
        this.fullyQualifiedName = fullyQualifiedName;
        return this;
    }

    /**
     * The description of the account.
     */
    public LedgerAccount withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = JsonNullable.of(description);
        return this;
    }

    /**
     * The description of the account.
     */
    public LedgerAccount withDescription(JsonNullable<String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * The opening balance of the account.
     */
    public LedgerAccount withOpeningBalance(double openingBalance) {
        Utils.checkNotNull(openingBalance, "openingBalance");
        this.openingBalance = JsonNullable.of(openingBalance);
        return this;
    }

    /**
     * The opening balance of the account.
     */
    public LedgerAccount withOpeningBalance(JsonNullable<Double> openingBalance) {
        Utils.checkNotNull(openingBalance, "openingBalance");
        this.openingBalance = openingBalance;
        return this;
    }

    /**
     * The current balance of the account.
     */
    public LedgerAccount withCurrentBalance(double currentBalance) {
        Utils.checkNotNull(currentBalance, "currentBalance");
        this.currentBalance = JsonNullable.of(currentBalance);
        return this;
    }

    /**
     * The current balance of the account.
     */
    public LedgerAccount withCurrentBalance(JsonNullable<Double> currentBalance) {
        Utils.checkNotNull(currentBalance, "currentBalance");
        this.currentBalance = currentBalance;
        return this;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    public LedgerAccount withCurrency(Currency currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = JsonNullable.of(currency);
        return this;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    public LedgerAccount withCurrency(JsonNullable<? extends Currency> currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = currency;
        return this;
    }

    /**
     * The tax type of the account.
     */
    public LedgerAccount withTaxType(String taxType) {
        Utils.checkNotNull(taxType, "taxType");
        this.taxType = JsonNullable.of(taxType);
        return this;
    }

    /**
     * The tax type of the account.
     */
    public LedgerAccount withTaxType(JsonNullable<String> taxType) {
        Utils.checkNotNull(taxType, "taxType");
        this.taxType = taxType;
        return this;
    }

    public LedgerAccount withTaxRate(LinkedTaxRate taxRate) {
        Utils.checkNotNull(taxRate, "taxRate");
        this.taxRate = Optional.ofNullable(taxRate);
        return this;
    }

    public LedgerAccount withTaxRate(Optional<? extends LinkedTaxRate> taxRate) {
        Utils.checkNotNull(taxRate, "taxRate");
        this.taxRate = taxRate;
        return this;
    }

    public LedgerAccount withLevel(double level) {
        Utils.checkNotNull(level, "level");
        this.level = JsonNullable.of(level);
        return this;
    }

    public LedgerAccount withLevel(JsonNullable<Double> level) {
        Utils.checkNotNull(level, "level");
        this.level = level;
        return this;
    }

    /**
     * Whether the account is active or not.
     */
    public LedgerAccount withActive(boolean active) {
        Utils.checkNotNull(active, "active");
        this.active = JsonNullable.of(active);
        return this;
    }

    /**
     * Whether the account is active or not.
     */
    public LedgerAccount withActive(JsonNullable<Boolean> active) {
        Utils.checkNotNull(active, "active");
        this.active = active;
        return this;
    }

    /**
     * The status of the account.
     */
    public LedgerAccount withStatus(AccountStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = JsonNullable.of(status);
        return this;
    }

    /**
     * The status of the account.
     */
    public LedgerAccount withStatus(JsonNullable<? extends AccountStatus> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * Whether the account is a header or not.
     */
    public LedgerAccount withHeader(boolean header) {
        Utils.checkNotNull(header, "header");
        this.header = JsonNullable.of(header);
        return this;
    }

    /**
     * Whether the account is a header or not.
     */
    public LedgerAccount withHeader(JsonNullable<Boolean> header) {
        Utils.checkNotNull(header, "header");
        this.header = header;
        return this;
    }

    public LedgerAccount withBankAccount(BankAccount bankAccount) {
        Utils.checkNotNull(bankAccount, "bankAccount");
        this.bankAccount = Optional.ofNullable(bankAccount);
        return this;
    }

    public LedgerAccount withBankAccount(Optional<? extends BankAccount> bankAccount) {
        Utils.checkNotNull(bankAccount, "bankAccount");
        this.bankAccount = bankAccount;
        return this;
    }

    /**
     * The categories of the account.
     */
    public LedgerAccount withCategories(List<Categories> categories) {
        Utils.checkNotNull(categories, "categories");
        this.categories = Optional.ofNullable(categories);
        return this;
    }

    /**
     * The categories of the account.
     */
    public LedgerAccount withCategories(Optional<? extends List<Categories>> categories) {
        Utils.checkNotNull(categories, "categories");
        this.categories = categories;
        return this;
    }

    public LedgerAccount withParentAccount(ParentAccount parentAccount) {
        Utils.checkNotNull(parentAccount, "parentAccount");
        this.parentAccount = Optional.ofNullable(parentAccount);
        return this;
    }

    public LedgerAccount withParentAccount(Optional<? extends ParentAccount> parentAccount) {
        Utils.checkNotNull(parentAccount, "parentAccount");
        this.parentAccount = parentAccount;
        return this;
    }

    /**
     * Whether the account is a sub account or not.
     */
    public LedgerAccount withSubAccount(boolean subAccount) {
        Utils.checkNotNull(subAccount, "subAccount");
        this.subAccount = JsonNullable.of(subAccount);
        return this;
    }

    /**
     * Whether the account is a sub account or not.
     */
    public LedgerAccount withSubAccount(JsonNullable<Boolean> subAccount) {
        Utils.checkNotNull(subAccount, "subAccount");
        this.subAccount = subAccount;
        return this;
    }

    /**
     * The sub accounts of the account.
     */
    public LedgerAccount withSubAccounts(List<SubAccounts> subAccounts) {
        Utils.checkNotNull(subAccounts, "subAccounts");
        this.subAccounts = Optional.ofNullable(subAccounts);
        return this;
    }

    /**
     * The sub accounts of the account.
     */
    public LedgerAccount withSubAccounts(Optional<? extends List<SubAccounts>> subAccounts) {
        Utils.checkNotNull(subAccounts, "subAccounts");
        this.subAccounts = subAccounts;
        return this;
    }

    /**
     * Reconciliation Date means the last calendar day of each Reconciliation Period.
     */
    public LedgerAccount withLastReconciliationDate(LocalDate lastReconciliationDate) {
        Utils.checkNotNull(lastReconciliationDate, "lastReconciliationDate");
        this.lastReconciliationDate = JsonNullable.of(lastReconciliationDate);
        return this;
    }

    /**
     * Reconciliation Date means the last calendar day of each Reconciliation Period.
     */
    public LedgerAccount withLastReconciliationDate(JsonNullable<LocalDate> lastReconciliationDate) {
        Utils.checkNotNull(lastReconciliationDate, "lastReconciliationDate");
        this.lastReconciliationDate = lastReconciliationDate;
        return this;
    }

    /**
     * The subsidiaries the account belongs to.
     */
    public LedgerAccount withSubsidiaries(List<Subsidiaries> subsidiaries) {
        Utils.checkNotNull(subsidiaries, "subsidiaries");
        this.subsidiaries = Optional.ofNullable(subsidiaries);
        return this;
    }

    /**
     * The subsidiaries the account belongs to.
     */
    public LedgerAccount withSubsidiaries(Optional<? extends List<Subsidiaries>> subsidiaries) {
        Utils.checkNotNull(subsidiaries, "subsidiaries");
        this.subsidiaries = subsidiaries;
        return this;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public LedgerAccount withCustomMappings(CustomMappings customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = JsonNullable.of(customMappings);
        return this;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public LedgerAccount withCustomMappings(JsonNullable<? extends CustomMappings> customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = customMappings;
        return this;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    public LedgerAccount withRowVersion(String rowVersion) {
        Utils.checkNotNull(rowVersion, "rowVersion");
        this.rowVersion = JsonNullable.of(rowVersion);
        return this;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    public LedgerAccount withRowVersion(JsonNullable<String> rowVersion) {
        Utils.checkNotNull(rowVersion, "rowVersion");
        this.rowVersion = rowVersion;
        return this;
    }

    /**
     * The user who last updated the object.
     */
    public LedgerAccount withUpdatedBy(String updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = JsonNullable.of(updatedBy);
        return this;
    }

    /**
     * The user who last updated the object.
     */
    public LedgerAccount withUpdatedBy(JsonNullable<String> updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = updatedBy;
        return this;
    }

    /**
     * The user who created the object.
     */
    public LedgerAccount withCreatedBy(String createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = JsonNullable.of(createdBy);
        return this;
    }

    /**
     * The user who created the object.
     */
    public LedgerAccount withCreatedBy(JsonNullable<String> createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = createdBy;
        return this;
    }

    /**
     * The date and time when the object was last updated.
     */
    public LedgerAccount withUpdatedAt(OffsetDateTime updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = JsonNullable.of(updatedAt);
        return this;
    }

    /**
     * The date and time when the object was last updated.
     */
    public LedgerAccount withUpdatedAt(JsonNullable<OffsetDateTime> updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = updatedAt;
        return this;
    }

    /**
     * The date and time when the object was created.
     */
    public LedgerAccount withCreatedAt(OffsetDateTime createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = JsonNullable.of(createdAt);
        return this;
    }

    /**
     * The date and time when the object was created.
     */
    public LedgerAccount withCreatedAt(JsonNullable<OffsetDateTime> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    public LedgerAccount withPassThrough(List<PassThroughBody> passThrough) {
        Utils.checkNotNull(passThrough, "passThrough");
        this.passThrough = Optional.ofNullable(passThrough);
        return this;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    public LedgerAccount withPassThrough(Optional<? extends List<PassThroughBody>> passThrough) {
        Utils.checkNotNull(passThrough, "passThrough");
        this.passThrough = passThrough;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        LedgerAccount other = (LedgerAccount) o;
        return 
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.displayId, other.displayId) &&
            Objects.deepEquals(this.nominalCode, other.nominalCode) &&
            Objects.deepEquals(this.code, other.code) &&
            Objects.deepEquals(this.classification, other.classification) &&
            Objects.deepEquals(this.type, other.type) &&
            Objects.deepEquals(this.subType, other.subType) &&
            Objects.deepEquals(this.name, other.name) &&
            Objects.deepEquals(this.fullyQualifiedName, other.fullyQualifiedName) &&
            Objects.deepEquals(this.description, other.description) &&
            Objects.deepEquals(this.openingBalance, other.openingBalance) &&
            Objects.deepEquals(this.currentBalance, other.currentBalance) &&
            Objects.deepEquals(this.currency, other.currency) &&
            Objects.deepEquals(this.taxType, other.taxType) &&
            Objects.deepEquals(this.taxRate, other.taxRate) &&
            Objects.deepEquals(this.level, other.level) &&
            Objects.deepEquals(this.active, other.active) &&
            Objects.deepEquals(this.status, other.status) &&
            Objects.deepEquals(this.header, other.header) &&
            Objects.deepEquals(this.bankAccount, other.bankAccount) &&
            Objects.deepEquals(this.categories, other.categories) &&
            Objects.deepEquals(this.parentAccount, other.parentAccount) &&
            Objects.deepEquals(this.subAccount, other.subAccount) &&
            Objects.deepEquals(this.subAccounts, other.subAccounts) &&
            Objects.deepEquals(this.lastReconciliationDate, other.lastReconciliationDate) &&
            Objects.deepEquals(this.subsidiaries, other.subsidiaries) &&
            Objects.deepEquals(this.customMappings, other.customMappings) &&
            Objects.deepEquals(this.rowVersion, other.rowVersion) &&
            Objects.deepEquals(this.updatedBy, other.updatedBy) &&
            Objects.deepEquals(this.createdBy, other.createdBy) &&
            Objects.deepEquals(this.updatedAt, other.updatedAt) &&
            Objects.deepEquals(this.createdAt, other.createdAt) &&
            Objects.deepEquals(this.passThrough, other.passThrough);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            id,
            displayId,
            nominalCode,
            code,
            classification,
            type,
            subType,
            name,
            fullyQualifiedName,
            description,
            openingBalance,
            currentBalance,
            currency,
            taxType,
            taxRate,
            level,
            active,
            status,
            header,
            bankAccount,
            categories,
            parentAccount,
            subAccount,
            subAccounts,
            lastReconciliationDate,
            subsidiaries,
            customMappings,
            rowVersion,
            updatedBy,
            createdBy,
            updatedAt,
            createdAt,
            passThrough);
    }
    
    @Override
    public String toString() {
        return Utils.toString(LedgerAccount.class,
                "id", id,
                "displayId", displayId,
                "nominalCode", nominalCode,
                "code", code,
                "classification", classification,
                "type", type,
                "subType", subType,
                "name", name,
                "fullyQualifiedName", fullyQualifiedName,
                "description", description,
                "openingBalance", openingBalance,
                "currentBalance", currentBalance,
                "currency", currency,
                "taxType", taxType,
                "taxRate", taxRate,
                "level", level,
                "active", active,
                "status", status,
                "header", header,
                "bankAccount", bankAccount,
                "categories", categories,
                "parentAccount", parentAccount,
                "subAccount", subAccount,
                "subAccounts", subAccounts,
                "lastReconciliationDate", lastReconciliationDate,
                "subsidiaries", subsidiaries,
                "customMappings", customMappings,
                "rowVersion", rowVersion,
                "updatedBy", updatedBy,
                "createdBy", createdBy,
                "updatedAt", updatedAt,
                "createdAt", createdAt,
                "passThrough", passThrough);
    }
    
    public final static class Builder {
 
        private Optional<String> id = Optional.empty();
 
        private Optional<String> displayId = Optional.empty();
 
        @Deprecated
        private JsonNullable<String> nominalCode = JsonNullable.undefined();
 
        private JsonNullable<String> code = JsonNullable.undefined();
 
        private JsonNullable<? extends Classification> classification = JsonNullable.undefined();
 
        private Optional<? extends LedgerAccountType> type = Optional.empty();
 
        private JsonNullable<String> subType = JsonNullable.undefined();
 
        private JsonNullable<String> name = JsonNullable.undefined();
 
        private JsonNullable<String> fullyQualifiedName = JsonNullable.undefined();
 
        private JsonNullable<String> description = JsonNullable.undefined();
 
        private JsonNullable<Double> openingBalance = JsonNullable.undefined();
 
        private JsonNullable<Double> currentBalance = JsonNullable.undefined();
 
        private JsonNullable<? extends Currency> currency = JsonNullable.undefined();
 
        private JsonNullable<String> taxType = JsonNullable.undefined();
 
        private Optional<? extends LinkedTaxRate> taxRate = Optional.empty();
 
        private JsonNullable<Double> level = JsonNullable.undefined();
 
        private JsonNullable<Boolean> active = JsonNullable.undefined();
 
        private JsonNullable<? extends AccountStatus> status = JsonNullable.undefined();
 
        private JsonNullable<Boolean> header = JsonNullable.undefined();
 
        private Optional<? extends BankAccount> bankAccount = Optional.empty();
 
        private Optional<? extends List<Categories>> categories = Optional.empty();
 
        private Optional<? extends ParentAccount> parentAccount = Optional.empty();
 
        private JsonNullable<Boolean> subAccount = JsonNullable.undefined();
 
        private Optional<? extends List<SubAccounts>> subAccounts = Optional.empty();
 
        private JsonNullable<LocalDate> lastReconciliationDate = JsonNullable.undefined();
 
        private Optional<? extends List<Subsidiaries>> subsidiaries = Optional.empty();
 
        private JsonNullable<? extends CustomMappings> customMappings = JsonNullable.undefined();
 
        private JsonNullable<String> rowVersion = JsonNullable.undefined();
 
        private JsonNullable<String> updatedBy = JsonNullable.undefined();
 
        private JsonNullable<String> createdBy = JsonNullable.undefined();
 
        private JsonNullable<OffsetDateTime> updatedAt = JsonNullable.undefined();
 
        private JsonNullable<OffsetDateTime> createdAt = JsonNullable.undefined();
 
        private Optional<? extends List<PassThroughBody>> passThrough = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * A unique identifier for an object.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * A unique identifier for an object.
         */
        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * The human readable display ID used when displaying the account
         */
        public Builder displayId(String displayId) {
            Utils.checkNotNull(displayId, "displayId");
            this.displayId = Optional.ofNullable(displayId);
            return this;
        }

        /**
         * The human readable display ID used when displaying the account
         */
        public Builder displayId(Optional<String> displayId) {
            Utils.checkNotNull(displayId, "displayId");
            this.displayId = displayId;
            return this;
        }

        /**
         * The nominal code of the ledger account.
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder nominalCode(String nominalCode) {
            Utils.checkNotNull(nominalCode, "nominalCode");
            this.nominalCode = JsonNullable.of(nominalCode);
            return this;
        }

        /**
         * The nominal code of the ledger account.
         * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
         */
        @Deprecated
        public Builder nominalCode(JsonNullable<String> nominalCode) {
            Utils.checkNotNull(nominalCode, "nominalCode");
            this.nominalCode = nominalCode;
            return this;
        }

        /**
         * The code assigned to the account.
         */
        public Builder code(String code) {
            Utils.checkNotNull(code, "code");
            this.code = JsonNullable.of(code);
            return this;
        }

        /**
         * The code assigned to the account.
         */
        public Builder code(JsonNullable<String> code) {
            Utils.checkNotNull(code, "code");
            this.code = code;
            return this;
        }

        /**
         * The classification of account.
         */
        public Builder classification(Classification classification) {
            Utils.checkNotNull(classification, "classification");
            this.classification = JsonNullable.of(classification);
            return this;
        }

        /**
         * The classification of account.
         */
        public Builder classification(JsonNullable<? extends Classification> classification) {
            Utils.checkNotNull(classification, "classification");
            this.classification = classification;
            return this;
        }

        /**
         * The type of account.
         */
        public Builder type(LedgerAccountType type) {
            Utils.checkNotNull(type, "type");
            this.type = Optional.ofNullable(type);
            return this;
        }

        /**
         * The type of account.
         */
        public Builder type(Optional<? extends LedgerAccountType> type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }

        /**
         * The sub type of account.
         */
        public Builder subType(String subType) {
            Utils.checkNotNull(subType, "subType");
            this.subType = JsonNullable.of(subType);
            return this;
        }

        /**
         * The sub type of account.
         */
        public Builder subType(JsonNullable<String> subType) {
            Utils.checkNotNull(subType, "subType");
            this.subType = subType;
            return this;
        }

        /**
         * The name of the account.
         */
        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = JsonNullable.of(name);
            return this;
        }

        /**
         * The name of the account.
         */
        public Builder name(JsonNullable<String> name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        /**
         * The fully qualified name of the account.
         */
        public Builder fullyQualifiedName(String fullyQualifiedName) {
            Utils.checkNotNull(fullyQualifiedName, "fullyQualifiedName");
            this.fullyQualifiedName = JsonNullable.of(fullyQualifiedName);
            return this;
        }

        /**
         * The fully qualified name of the account.
         */
        public Builder fullyQualifiedName(JsonNullable<String> fullyQualifiedName) {
            Utils.checkNotNull(fullyQualifiedName, "fullyQualifiedName");
            this.fullyQualifiedName = fullyQualifiedName;
            return this;
        }

        /**
         * The description of the account.
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = JsonNullable.of(description);
            return this;
        }

        /**
         * The description of the account.
         */
        public Builder description(JsonNullable<String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }

        /**
         * The opening balance of the account.
         */
        public Builder openingBalance(double openingBalance) {
            Utils.checkNotNull(openingBalance, "openingBalance");
            this.openingBalance = JsonNullable.of(openingBalance);
            return this;
        }

        /**
         * The opening balance of the account.
         */
        public Builder openingBalance(JsonNullable<Double> openingBalance) {
            Utils.checkNotNull(openingBalance, "openingBalance");
            this.openingBalance = openingBalance;
            return this;
        }

        /**
         * The current balance of the account.
         */
        public Builder currentBalance(double currentBalance) {
            Utils.checkNotNull(currentBalance, "currentBalance");
            this.currentBalance = JsonNullable.of(currentBalance);
            return this;
        }

        /**
         * The current balance of the account.
         */
        public Builder currentBalance(JsonNullable<Double> currentBalance) {
            Utils.checkNotNull(currentBalance, "currentBalance");
            this.currentBalance = currentBalance;
            return this;
        }

        /**
         * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
         */
        public Builder currency(Currency currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = JsonNullable.of(currency);
            return this;
        }

        /**
         * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
         */
        public Builder currency(JsonNullable<? extends Currency> currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = currency;
            return this;
        }

        /**
         * The tax type of the account.
         */
        public Builder taxType(String taxType) {
            Utils.checkNotNull(taxType, "taxType");
            this.taxType = JsonNullable.of(taxType);
            return this;
        }

        /**
         * The tax type of the account.
         */
        public Builder taxType(JsonNullable<String> taxType) {
            Utils.checkNotNull(taxType, "taxType");
            this.taxType = taxType;
            return this;
        }

        public Builder taxRate(LinkedTaxRate taxRate) {
            Utils.checkNotNull(taxRate, "taxRate");
            this.taxRate = Optional.ofNullable(taxRate);
            return this;
        }

        public Builder taxRate(Optional<? extends LinkedTaxRate> taxRate) {
            Utils.checkNotNull(taxRate, "taxRate");
            this.taxRate = taxRate;
            return this;
        }

        public Builder level(double level) {
            Utils.checkNotNull(level, "level");
            this.level = JsonNullable.of(level);
            return this;
        }

        public Builder level(JsonNullable<Double> level) {
            Utils.checkNotNull(level, "level");
            this.level = level;
            return this;
        }

        /**
         * Whether the account is active or not.
         */
        public Builder active(boolean active) {
            Utils.checkNotNull(active, "active");
            this.active = JsonNullable.of(active);
            return this;
        }

        /**
         * Whether the account is active or not.
         */
        public Builder active(JsonNullable<Boolean> active) {
            Utils.checkNotNull(active, "active");
            this.active = active;
            return this;
        }

        /**
         * The status of the account.
         */
        public Builder status(AccountStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = JsonNullable.of(status);
            return this;
        }

        /**
         * The status of the account.
         */
        public Builder status(JsonNullable<? extends AccountStatus> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }

        /**
         * Whether the account is a header or not.
         */
        public Builder header(boolean header) {
            Utils.checkNotNull(header, "header");
            this.header = JsonNullable.of(header);
            return this;
        }

        /**
         * Whether the account is a header or not.
         */
        public Builder header(JsonNullable<Boolean> header) {
            Utils.checkNotNull(header, "header");
            this.header = header;
            return this;
        }

        public Builder bankAccount(BankAccount bankAccount) {
            Utils.checkNotNull(bankAccount, "bankAccount");
            this.bankAccount = Optional.ofNullable(bankAccount);
            return this;
        }

        public Builder bankAccount(Optional<? extends BankAccount> bankAccount) {
            Utils.checkNotNull(bankAccount, "bankAccount");
            this.bankAccount = bankAccount;
            return this;
        }

        /**
         * The categories of the account.
         */
        public Builder categories(List<Categories> categories) {
            Utils.checkNotNull(categories, "categories");
            this.categories = Optional.ofNullable(categories);
            return this;
        }

        /**
         * The categories of the account.
         */
        public Builder categories(Optional<? extends List<Categories>> categories) {
            Utils.checkNotNull(categories, "categories");
            this.categories = categories;
            return this;
        }

        public Builder parentAccount(ParentAccount parentAccount) {
            Utils.checkNotNull(parentAccount, "parentAccount");
            this.parentAccount = Optional.ofNullable(parentAccount);
            return this;
        }

        public Builder parentAccount(Optional<? extends ParentAccount> parentAccount) {
            Utils.checkNotNull(parentAccount, "parentAccount");
            this.parentAccount = parentAccount;
            return this;
        }

        /**
         * Whether the account is a sub account or not.
         */
        public Builder subAccount(boolean subAccount) {
            Utils.checkNotNull(subAccount, "subAccount");
            this.subAccount = JsonNullable.of(subAccount);
            return this;
        }

        /**
         * Whether the account is a sub account or not.
         */
        public Builder subAccount(JsonNullable<Boolean> subAccount) {
            Utils.checkNotNull(subAccount, "subAccount");
            this.subAccount = subAccount;
            return this;
        }

        /**
         * The sub accounts of the account.
         */
        public Builder subAccounts(List<SubAccounts> subAccounts) {
            Utils.checkNotNull(subAccounts, "subAccounts");
            this.subAccounts = Optional.ofNullable(subAccounts);
            return this;
        }

        /**
         * The sub accounts of the account.
         */
        public Builder subAccounts(Optional<? extends List<SubAccounts>> subAccounts) {
            Utils.checkNotNull(subAccounts, "subAccounts");
            this.subAccounts = subAccounts;
            return this;
        }

        /**
         * Reconciliation Date means the last calendar day of each Reconciliation Period.
         */
        public Builder lastReconciliationDate(LocalDate lastReconciliationDate) {
            Utils.checkNotNull(lastReconciliationDate, "lastReconciliationDate");
            this.lastReconciliationDate = JsonNullable.of(lastReconciliationDate);
            return this;
        }

        /**
         * Reconciliation Date means the last calendar day of each Reconciliation Period.
         */
        public Builder lastReconciliationDate(JsonNullable<LocalDate> lastReconciliationDate) {
            Utils.checkNotNull(lastReconciliationDate, "lastReconciliationDate");
            this.lastReconciliationDate = lastReconciliationDate;
            return this;
        }

        /**
         * The subsidiaries the account belongs to.
         */
        public Builder subsidiaries(List<Subsidiaries> subsidiaries) {
            Utils.checkNotNull(subsidiaries, "subsidiaries");
            this.subsidiaries = Optional.ofNullable(subsidiaries);
            return this;
        }

        /**
         * The subsidiaries the account belongs to.
         */
        public Builder subsidiaries(Optional<? extends List<Subsidiaries>> subsidiaries) {
            Utils.checkNotNull(subsidiaries, "subsidiaries");
            this.subsidiaries = subsidiaries;
            return this;
        }

        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(CustomMappings customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = JsonNullable.of(customMappings);
            return this;
        }

        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(JsonNullable<? extends CustomMappings> customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = customMappings;
            return this;
        }

        /**
         * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
         */
        public Builder rowVersion(String rowVersion) {
            Utils.checkNotNull(rowVersion, "rowVersion");
            this.rowVersion = JsonNullable.of(rowVersion);
            return this;
        }

        /**
         * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
         */
        public Builder rowVersion(JsonNullable<String> rowVersion) {
            Utils.checkNotNull(rowVersion, "rowVersion");
            this.rowVersion = rowVersion;
            return this;
        }

        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(String updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = JsonNullable.of(updatedBy);
            return this;
        }

        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(JsonNullable<String> updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = updatedBy;
            return this;
        }

        /**
         * The user who created the object.
         */
        public Builder createdBy(String createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = JsonNullable.of(createdBy);
            return this;
        }

        /**
         * The user who created the object.
         */
        public Builder createdBy(JsonNullable<String> createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = createdBy;
            return this;
        }

        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(OffsetDateTime updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = JsonNullable.of(updatedAt);
            return this;
        }

        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(JsonNullable<OffsetDateTime> updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = updatedAt;
            return this;
        }

        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(OffsetDateTime createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = JsonNullable.of(createdAt);
            return this;
        }

        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(JsonNullable<OffsetDateTime> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }

        /**
         * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
         */
        public Builder passThrough(List<PassThroughBody> passThrough) {
            Utils.checkNotNull(passThrough, "passThrough");
            this.passThrough = Optional.ofNullable(passThrough);
            return this;
        }

        /**
         * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
         */
        public Builder passThrough(Optional<? extends List<PassThroughBody>> passThrough) {
            Utils.checkNotNull(passThrough, "passThrough");
            this.passThrough = passThrough;
            return this;
        }
        
        public LedgerAccount build() {
            return new LedgerAccount(
                id,
                displayId,
                nominalCode,
                code,
                classification,
                type,
                subType,
                name,
                fullyQualifiedName,
                description,
                openingBalance,
                currentBalance,
                currency,
                taxType,
                taxRate,
                level,
                active,
                status,
                header,
                bankAccount,
                categories,
                parentAccount,
                subAccount,
                subAccounts,
                lastReconciliationDate,
                subsidiaries,
                customMappings,
                rowVersion,
                updatedBy,
                createdBy,
                updatedAt,
                createdAt,
                passThrough);
        }
    }
}

