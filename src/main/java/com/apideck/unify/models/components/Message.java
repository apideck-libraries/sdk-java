/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.apideck.unify.models.components;

import com.apideck.unify.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class Message {
    /**
     * A unique identifier for an object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * The phone number that initiated the message.
     */
    @JsonProperty("from")
    private String from;

    /**
     * The phone number that received the message.
     */
    @JsonProperty("to")
    private String to;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subject")
    private Optional<String> subject;

    /**
     * The message text.
     */
    @JsonProperty("body")
    private String body;

    /**
     * Set to sms for SMS messages and mms for MMS messages.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("type")
    private Optional<? extends MessageType> type;

    /**
     * The number of units that make up the complete message. Messages can be split up due to the constraints of the message size.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("number_of_units")
    private Optional<Long> numberOfUnits;

    /**
     * The number of media files associated with the message.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("number_of_media_files")
    private Optional<Long> numberOfMediaFiles;

    /**
     * The direction of the message.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("direction")
    private Optional<? extends Direction> direction;

    /**
     * Status of the delivery of the message.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private Optional<? extends MessageStatus> status;

    /**
     * The scheduled date and time of the message.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("scheduled_at")
    private Optional<OffsetDateTime> scheduledAt;

    /**
     * The date and time that the message was sent
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sent_at")
    private Optional<OffsetDateTime> sentAt;

    /**
     * Define a webhook to receive delivery notifications.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("webhook_url")
    private Optional<String> webhookUrl;

    /**
     * A client reference.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("reference")
    private Optional<String> reference;

    /**
     * Price of the message.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("price")
    private Optional<? extends Price> price;

    /**
     * The error returned if your message status is failed or undelivered.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("error")
    private Optional<? extends Error> error;

    /**
     * The ID of the Messaging Service used with the message. In case of Plivo this links to the Powerpack ID.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("messaging_service_id")
    private Optional<String> messagingServiceId;

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_mappings")
    private JsonNullable<? extends Map<String, Object>> customMappings;

    /**
     * The user who last updated the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_by")
    private JsonNullable<String> updatedBy;

    /**
     * The user who created the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_by")
    private JsonNullable<String> createdBy;

    /**
     * The date and time when the object was last updated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_at")
    private JsonNullable<OffsetDateTime> updatedAt;

    /**
     * The date and time when the object was created.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_at")
    private JsonNullable<OffsetDateTime> createdAt;

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pass_through")
    private Optional<? extends List<PassThroughBody>> passThrough;

    @JsonCreator
    public Message(
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("from") String from,
            @JsonProperty("to") String to,
            @JsonProperty("subject") Optional<String> subject,
            @JsonProperty("body") String body,
            @JsonProperty("type") Optional<? extends MessageType> type,
            @JsonProperty("number_of_units") Optional<Long> numberOfUnits,
            @JsonProperty("number_of_media_files") Optional<Long> numberOfMediaFiles,
            @JsonProperty("direction") Optional<? extends Direction> direction,
            @JsonProperty("status") Optional<? extends MessageStatus> status,
            @JsonProperty("scheduled_at") Optional<OffsetDateTime> scheduledAt,
            @JsonProperty("sent_at") Optional<OffsetDateTime> sentAt,
            @JsonProperty("webhook_url") Optional<String> webhookUrl,
            @JsonProperty("reference") Optional<String> reference,
            @JsonProperty("price") Optional<? extends Price> price,
            @JsonProperty("error") Optional<? extends Error> error,
            @JsonProperty("messaging_service_id") Optional<String> messagingServiceId,
            @JsonProperty("custom_mappings") JsonNullable<? extends Map<String, Object>> customMappings,
            @JsonProperty("updated_by") JsonNullable<String> updatedBy,
            @JsonProperty("created_by") JsonNullable<String> createdBy,
            @JsonProperty("updated_at") JsonNullable<OffsetDateTime> updatedAt,
            @JsonProperty("created_at") JsonNullable<OffsetDateTime> createdAt,
            @JsonProperty("pass_through") Optional<? extends List<PassThroughBody>> passThrough) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(from, "from");
        Utils.checkNotNull(to, "to");
        Utils.checkNotNull(subject, "subject");
        Utils.checkNotNull(body, "body");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(numberOfUnits, "numberOfUnits");
        Utils.checkNotNull(numberOfMediaFiles, "numberOfMediaFiles");
        Utils.checkNotNull(direction, "direction");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(scheduledAt, "scheduledAt");
        Utils.checkNotNull(sentAt, "sentAt");
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        Utils.checkNotNull(reference, "reference");
        Utils.checkNotNull(price, "price");
        Utils.checkNotNull(error, "error");
        Utils.checkNotNull(messagingServiceId, "messagingServiceId");
        Utils.checkNotNull(customMappings, "customMappings");
        Utils.checkNotNull(updatedBy, "updatedBy");
        Utils.checkNotNull(createdBy, "createdBy");
        Utils.checkNotNull(updatedAt, "updatedAt");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(passThrough, "passThrough");
        this.id = id;
        this.from = from;
        this.to = to;
        this.subject = subject;
        this.body = body;
        this.type = type;
        this.numberOfUnits = numberOfUnits;
        this.numberOfMediaFiles = numberOfMediaFiles;
        this.direction = direction;
        this.status = status;
        this.scheduledAt = scheduledAt;
        this.sentAt = sentAt;
        this.webhookUrl = webhookUrl;
        this.reference = reference;
        this.price = price;
        this.error = error;
        this.messagingServiceId = messagingServiceId;
        this.customMappings = customMappings;
        this.updatedBy = updatedBy;
        this.createdBy = createdBy;
        this.updatedAt = updatedAt;
        this.createdAt = createdAt;
        this.passThrough = passThrough;
    }
    
    public Message(
            String from,
            String to,
            String body) {
        this(Optional.empty(), from, to,
            Optional.empty(), body, Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), Optional.empty(),
            Optional.empty(), Optional.empty(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), Optional.empty());
    }

    /**
     * A unique identifier for an object.
     */
    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * The phone number that initiated the message.
     */
    @JsonIgnore
    public String from() {
        return from;
    }

    /**
     * The phone number that received the message.
     */
    @JsonIgnore
    public String to() {
        return to;
    }

    @JsonIgnore
    public Optional<String> subject() {
        return subject;
    }

    /**
     * The message text.
     */
    @JsonIgnore
    public String body() {
        return body;
    }

    /**
     * Set to sms for SMS messages and mms for MMS messages.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<MessageType> type() {
        return (Optional<MessageType>) type;
    }

    /**
     * The number of units that make up the complete message. Messages can be split up due to the constraints of the message size.
     */
    @JsonIgnore
    public Optional<Long> numberOfUnits() {
        return numberOfUnits;
    }

    /**
     * The number of media files associated with the message.
     */
    @JsonIgnore
    public Optional<Long> numberOfMediaFiles() {
        return numberOfMediaFiles;
    }

    /**
     * The direction of the message.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Direction> direction() {
        return (Optional<Direction>) direction;
    }

    /**
     * Status of the delivery of the message.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<MessageStatus> status() {
        return (Optional<MessageStatus>) status;
    }

    /**
     * The scheduled date and time of the message.
     */
    @JsonIgnore
    public Optional<OffsetDateTime> scheduledAt() {
        return scheduledAt;
    }

    /**
     * The date and time that the message was sent
     */
    @JsonIgnore
    public Optional<OffsetDateTime> sentAt() {
        return sentAt;
    }

    /**
     * Define a webhook to receive delivery notifications.
     */
    @JsonIgnore
    public Optional<String> webhookUrl() {
        return webhookUrl;
    }

    /**
     * A client reference.
     */
    @JsonIgnore
    public Optional<String> reference() {
        return reference;
    }

    /**
     * Price of the message.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Price> price() {
        return (Optional<Price>) price;
    }

    /**
     * The error returned if your message status is failed or undelivered.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Error> error() {
        return (Optional<Error>) error;
    }

    /**
     * The ID of the Messaging Service used with the message. In case of Plivo this links to the Powerpack ID.
     */
    @JsonIgnore
    public Optional<String> messagingServiceId() {
        return messagingServiceId;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Map<String, Object>> customMappings() {
        return (JsonNullable<Map<String, Object>>) customMappings;
    }

    /**
     * The user who last updated the object.
     */
    @JsonIgnore
    public JsonNullable<String> updatedBy() {
        return updatedBy;
    }

    /**
     * The user who created the object.
     */
    @JsonIgnore
    public JsonNullable<String> createdBy() {
        return createdBy;
    }

    /**
     * The date and time when the object was last updated.
     */
    @JsonIgnore
    public JsonNullable<OffsetDateTime> updatedAt() {
        return updatedAt;
    }

    /**
     * The date and time when the object was created.
     */
    @JsonIgnore
    public JsonNullable<OffsetDateTime> createdAt() {
        return createdAt;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PassThroughBody>> passThrough() {
        return (Optional<List<PassThroughBody>>) passThrough;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * A unique identifier for an object.
     */
    public Message withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }


    /**
     * A unique identifier for an object.
     */
    public Message withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * The phone number that initiated the message.
     */
    public Message withFrom(String from) {
        Utils.checkNotNull(from, "from");
        this.from = from;
        return this;
    }

    /**
     * The phone number that received the message.
     */
    public Message withTo(String to) {
        Utils.checkNotNull(to, "to");
        this.to = to;
        return this;
    }

    public Message withSubject(String subject) {
        Utils.checkNotNull(subject, "subject");
        this.subject = Optional.ofNullable(subject);
        return this;
    }


    public Message withSubject(Optional<String> subject) {
        Utils.checkNotNull(subject, "subject");
        this.subject = subject;
        return this;
    }

    /**
     * The message text.
     */
    public Message withBody(String body) {
        Utils.checkNotNull(body, "body");
        this.body = body;
        return this;
    }

    /**
     * Set to sms for SMS messages and mms for MMS messages.
     */
    public Message withType(MessageType type) {
        Utils.checkNotNull(type, "type");
        this.type = Optional.ofNullable(type);
        return this;
    }


    /**
     * Set to sms for SMS messages and mms for MMS messages.
     */
    public Message withType(Optional<? extends MessageType> type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * The number of units that make up the complete message. Messages can be split up due to the constraints of the message size.
     */
    public Message withNumberOfUnits(long numberOfUnits) {
        Utils.checkNotNull(numberOfUnits, "numberOfUnits");
        this.numberOfUnits = Optional.ofNullable(numberOfUnits);
        return this;
    }


    /**
     * The number of units that make up the complete message. Messages can be split up due to the constraints of the message size.
     */
    public Message withNumberOfUnits(Optional<Long> numberOfUnits) {
        Utils.checkNotNull(numberOfUnits, "numberOfUnits");
        this.numberOfUnits = numberOfUnits;
        return this;
    }

    /**
     * The number of media files associated with the message.
     */
    public Message withNumberOfMediaFiles(long numberOfMediaFiles) {
        Utils.checkNotNull(numberOfMediaFiles, "numberOfMediaFiles");
        this.numberOfMediaFiles = Optional.ofNullable(numberOfMediaFiles);
        return this;
    }


    /**
     * The number of media files associated with the message.
     */
    public Message withNumberOfMediaFiles(Optional<Long> numberOfMediaFiles) {
        Utils.checkNotNull(numberOfMediaFiles, "numberOfMediaFiles");
        this.numberOfMediaFiles = numberOfMediaFiles;
        return this;
    }

    /**
     * The direction of the message.
     */
    public Message withDirection(Direction direction) {
        Utils.checkNotNull(direction, "direction");
        this.direction = Optional.ofNullable(direction);
        return this;
    }


    /**
     * The direction of the message.
     */
    public Message withDirection(Optional<? extends Direction> direction) {
        Utils.checkNotNull(direction, "direction");
        this.direction = direction;
        return this;
    }

    /**
     * Status of the delivery of the message.
     */
    public Message withStatus(MessageStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = Optional.ofNullable(status);
        return this;
    }


    /**
     * Status of the delivery of the message.
     */
    public Message withStatus(Optional<? extends MessageStatus> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * The scheduled date and time of the message.
     */
    public Message withScheduledAt(OffsetDateTime scheduledAt) {
        Utils.checkNotNull(scheduledAt, "scheduledAt");
        this.scheduledAt = Optional.ofNullable(scheduledAt);
        return this;
    }


    /**
     * The scheduled date and time of the message.
     */
    public Message withScheduledAt(Optional<OffsetDateTime> scheduledAt) {
        Utils.checkNotNull(scheduledAt, "scheduledAt");
        this.scheduledAt = scheduledAt;
        return this;
    }

    /**
     * The date and time that the message was sent
     */
    public Message withSentAt(OffsetDateTime sentAt) {
        Utils.checkNotNull(sentAt, "sentAt");
        this.sentAt = Optional.ofNullable(sentAt);
        return this;
    }


    /**
     * The date and time that the message was sent
     */
    public Message withSentAt(Optional<OffsetDateTime> sentAt) {
        Utils.checkNotNull(sentAt, "sentAt");
        this.sentAt = sentAt;
        return this;
    }

    /**
     * Define a webhook to receive delivery notifications.
     */
    public Message withWebhookUrl(String webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = Optional.ofNullable(webhookUrl);
        return this;
    }


    /**
     * Define a webhook to receive delivery notifications.
     */
    public Message withWebhookUrl(Optional<String> webhookUrl) {
        Utils.checkNotNull(webhookUrl, "webhookUrl");
        this.webhookUrl = webhookUrl;
        return this;
    }

    /**
     * A client reference.
     */
    public Message withReference(String reference) {
        Utils.checkNotNull(reference, "reference");
        this.reference = Optional.ofNullable(reference);
        return this;
    }


    /**
     * A client reference.
     */
    public Message withReference(Optional<String> reference) {
        Utils.checkNotNull(reference, "reference");
        this.reference = reference;
        return this;
    }

    /**
     * Price of the message.
     */
    public Message withPrice(Price price) {
        Utils.checkNotNull(price, "price");
        this.price = Optional.ofNullable(price);
        return this;
    }


    /**
     * Price of the message.
     */
    public Message withPrice(Optional<? extends Price> price) {
        Utils.checkNotNull(price, "price");
        this.price = price;
        return this;
    }

    /**
     * The error returned if your message status is failed or undelivered.
     */
    public Message withError(Error error) {
        Utils.checkNotNull(error, "error");
        this.error = Optional.ofNullable(error);
        return this;
    }


    /**
     * The error returned if your message status is failed or undelivered.
     */
    public Message withError(Optional<? extends Error> error) {
        Utils.checkNotNull(error, "error");
        this.error = error;
        return this;
    }

    /**
     * The ID of the Messaging Service used with the message. In case of Plivo this links to the Powerpack ID.
     */
    public Message withMessagingServiceId(String messagingServiceId) {
        Utils.checkNotNull(messagingServiceId, "messagingServiceId");
        this.messagingServiceId = Optional.ofNullable(messagingServiceId);
        return this;
    }


    /**
     * The ID of the Messaging Service used with the message. In case of Plivo this links to the Powerpack ID.
     */
    public Message withMessagingServiceId(Optional<String> messagingServiceId) {
        Utils.checkNotNull(messagingServiceId, "messagingServiceId");
        this.messagingServiceId = messagingServiceId;
        return this;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public Message withCustomMappings(Map<String, Object> customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = JsonNullable.of(customMappings);
        return this;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public Message withCustomMappings(JsonNullable<? extends Map<String, Object>> customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = customMappings;
        return this;
    }

    /**
     * The user who last updated the object.
     */
    public Message withUpdatedBy(String updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = JsonNullable.of(updatedBy);
        return this;
    }

    /**
     * The user who last updated the object.
     */
    public Message withUpdatedBy(JsonNullable<String> updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = updatedBy;
        return this;
    }

    /**
     * The user who created the object.
     */
    public Message withCreatedBy(String createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = JsonNullable.of(createdBy);
        return this;
    }

    /**
     * The user who created the object.
     */
    public Message withCreatedBy(JsonNullable<String> createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = createdBy;
        return this;
    }

    /**
     * The date and time when the object was last updated.
     */
    public Message withUpdatedAt(OffsetDateTime updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = JsonNullable.of(updatedAt);
        return this;
    }

    /**
     * The date and time when the object was last updated.
     */
    public Message withUpdatedAt(JsonNullable<OffsetDateTime> updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = updatedAt;
        return this;
    }

    /**
     * The date and time when the object was created.
     */
    public Message withCreatedAt(OffsetDateTime createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = JsonNullable.of(createdAt);
        return this;
    }

    /**
     * The date and time when the object was created.
     */
    public Message withCreatedAt(JsonNullable<OffsetDateTime> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    public Message withPassThrough(List<PassThroughBody> passThrough) {
        Utils.checkNotNull(passThrough, "passThrough");
        this.passThrough = Optional.ofNullable(passThrough);
        return this;
    }


    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    public Message withPassThrough(Optional<? extends List<PassThroughBody>> passThrough) {
        Utils.checkNotNull(passThrough, "passThrough");
        this.passThrough = passThrough;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Message other = (Message) o;
        return 
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.from, other.from) &&
            Utils.enhancedDeepEquals(this.to, other.to) &&
            Utils.enhancedDeepEquals(this.subject, other.subject) &&
            Utils.enhancedDeepEquals(this.body, other.body) &&
            Utils.enhancedDeepEquals(this.type, other.type) &&
            Utils.enhancedDeepEquals(this.numberOfUnits, other.numberOfUnits) &&
            Utils.enhancedDeepEquals(this.numberOfMediaFiles, other.numberOfMediaFiles) &&
            Utils.enhancedDeepEquals(this.direction, other.direction) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.scheduledAt, other.scheduledAt) &&
            Utils.enhancedDeepEquals(this.sentAt, other.sentAt) &&
            Utils.enhancedDeepEquals(this.webhookUrl, other.webhookUrl) &&
            Utils.enhancedDeepEquals(this.reference, other.reference) &&
            Utils.enhancedDeepEquals(this.price, other.price) &&
            Utils.enhancedDeepEquals(this.error, other.error) &&
            Utils.enhancedDeepEquals(this.messagingServiceId, other.messagingServiceId) &&
            Utils.enhancedDeepEquals(this.customMappings, other.customMappings) &&
            Utils.enhancedDeepEquals(this.updatedBy, other.updatedBy) &&
            Utils.enhancedDeepEquals(this.createdBy, other.createdBy) &&
            Utils.enhancedDeepEquals(this.updatedAt, other.updatedAt) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.passThrough, other.passThrough);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            id, from, to,
            subject, body, type,
            numberOfUnits, numberOfMediaFiles, direction,
            status, scheduledAt, sentAt,
            webhookUrl, reference, price,
            error, messagingServiceId, customMappings,
            updatedBy, createdBy, updatedAt,
            createdAt, passThrough);
    }
    
    @Override
    public String toString() {
        return Utils.toString(Message.class,
                "id", id,
                "from", from,
                "to", to,
                "subject", subject,
                "body", body,
                "type", type,
                "numberOfUnits", numberOfUnits,
                "numberOfMediaFiles", numberOfMediaFiles,
                "direction", direction,
                "status", status,
                "scheduledAt", scheduledAt,
                "sentAt", sentAt,
                "webhookUrl", webhookUrl,
                "reference", reference,
                "price", price,
                "error", error,
                "messagingServiceId", messagingServiceId,
                "customMappings", customMappings,
                "updatedBy", updatedBy,
                "createdBy", createdBy,
                "updatedAt", updatedAt,
                "createdAt", createdAt,
                "passThrough", passThrough);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<String> id = Optional.empty();

        private String from;

        private String to;

        private Optional<String> subject = Optional.empty();

        private String body;

        private Optional<? extends MessageType> type = Optional.empty();

        private Optional<Long> numberOfUnits = Optional.empty();

        private Optional<Long> numberOfMediaFiles = Optional.empty();

        private Optional<? extends Direction> direction = Optional.empty();

        private Optional<? extends MessageStatus> status = Optional.empty();

        private Optional<OffsetDateTime> scheduledAt = Optional.empty();

        private Optional<OffsetDateTime> sentAt = Optional.empty();

        private Optional<String> webhookUrl = Optional.empty();

        private Optional<String> reference = Optional.empty();

        private Optional<? extends Price> price = Optional.empty();

        private Optional<? extends Error> error = Optional.empty();

        private Optional<String> messagingServiceId = Optional.empty();

        private JsonNullable<? extends Map<String, Object>> customMappings = JsonNullable.undefined();

        private JsonNullable<String> updatedBy = JsonNullable.undefined();

        private JsonNullable<String> createdBy = JsonNullable.undefined();

        private JsonNullable<OffsetDateTime> updatedAt = JsonNullable.undefined();

        private JsonNullable<OffsetDateTime> createdAt = JsonNullable.undefined();

        private Optional<? extends List<PassThroughBody>> passThrough = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * A unique identifier for an object.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * A unique identifier for an object.
         */
        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        /**
         * The phone number that initiated the message.
         */
        public Builder from(String from) {
            Utils.checkNotNull(from, "from");
            this.from = from;
            return this;
        }


        /**
         * The phone number that received the message.
         */
        public Builder to(String to) {
            Utils.checkNotNull(to, "to");
            this.to = to;
            return this;
        }


        public Builder subject(String subject) {
            Utils.checkNotNull(subject, "subject");
            this.subject = Optional.ofNullable(subject);
            return this;
        }

        public Builder subject(Optional<String> subject) {
            Utils.checkNotNull(subject, "subject");
            this.subject = subject;
            return this;
        }


        /**
         * The message text.
         */
        public Builder body(String body) {
            Utils.checkNotNull(body, "body");
            this.body = body;
            return this;
        }


        /**
         * Set to sms for SMS messages and mms for MMS messages.
         */
        public Builder type(MessageType type) {
            Utils.checkNotNull(type, "type");
            this.type = Optional.ofNullable(type);
            return this;
        }

        /**
         * Set to sms for SMS messages and mms for MMS messages.
         */
        public Builder type(Optional<? extends MessageType> type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }


        /**
         * The number of units that make up the complete message. Messages can be split up due to the constraints of the message size.
         */
        public Builder numberOfUnits(long numberOfUnits) {
            Utils.checkNotNull(numberOfUnits, "numberOfUnits");
            this.numberOfUnits = Optional.ofNullable(numberOfUnits);
            return this;
        }

        /**
         * The number of units that make up the complete message. Messages can be split up due to the constraints of the message size.
         */
        public Builder numberOfUnits(Optional<Long> numberOfUnits) {
            Utils.checkNotNull(numberOfUnits, "numberOfUnits");
            this.numberOfUnits = numberOfUnits;
            return this;
        }


        /**
         * The number of media files associated with the message.
         */
        public Builder numberOfMediaFiles(long numberOfMediaFiles) {
            Utils.checkNotNull(numberOfMediaFiles, "numberOfMediaFiles");
            this.numberOfMediaFiles = Optional.ofNullable(numberOfMediaFiles);
            return this;
        }

        /**
         * The number of media files associated with the message.
         */
        public Builder numberOfMediaFiles(Optional<Long> numberOfMediaFiles) {
            Utils.checkNotNull(numberOfMediaFiles, "numberOfMediaFiles");
            this.numberOfMediaFiles = numberOfMediaFiles;
            return this;
        }


        /**
         * The direction of the message.
         */
        public Builder direction(Direction direction) {
            Utils.checkNotNull(direction, "direction");
            this.direction = Optional.ofNullable(direction);
            return this;
        }

        /**
         * The direction of the message.
         */
        public Builder direction(Optional<? extends Direction> direction) {
            Utils.checkNotNull(direction, "direction");
            this.direction = direction;
            return this;
        }


        /**
         * Status of the delivery of the message.
         */
        public Builder status(MessageStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = Optional.ofNullable(status);
            return this;
        }

        /**
         * Status of the delivery of the message.
         */
        public Builder status(Optional<? extends MessageStatus> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }


        /**
         * The scheduled date and time of the message.
         */
        public Builder scheduledAt(OffsetDateTime scheduledAt) {
            Utils.checkNotNull(scheduledAt, "scheduledAt");
            this.scheduledAt = Optional.ofNullable(scheduledAt);
            return this;
        }

        /**
         * The scheduled date and time of the message.
         */
        public Builder scheduledAt(Optional<OffsetDateTime> scheduledAt) {
            Utils.checkNotNull(scheduledAt, "scheduledAt");
            this.scheduledAt = scheduledAt;
            return this;
        }


        /**
         * The date and time that the message was sent
         */
        public Builder sentAt(OffsetDateTime sentAt) {
            Utils.checkNotNull(sentAt, "sentAt");
            this.sentAt = Optional.ofNullable(sentAt);
            return this;
        }

        /**
         * The date and time that the message was sent
         */
        public Builder sentAt(Optional<OffsetDateTime> sentAt) {
            Utils.checkNotNull(sentAt, "sentAt");
            this.sentAt = sentAt;
            return this;
        }


        /**
         * Define a webhook to receive delivery notifications.
         */
        public Builder webhookUrl(String webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = Optional.ofNullable(webhookUrl);
            return this;
        }

        /**
         * Define a webhook to receive delivery notifications.
         */
        public Builder webhookUrl(Optional<String> webhookUrl) {
            Utils.checkNotNull(webhookUrl, "webhookUrl");
            this.webhookUrl = webhookUrl;
            return this;
        }


        /**
         * A client reference.
         */
        public Builder reference(String reference) {
            Utils.checkNotNull(reference, "reference");
            this.reference = Optional.ofNullable(reference);
            return this;
        }

        /**
         * A client reference.
         */
        public Builder reference(Optional<String> reference) {
            Utils.checkNotNull(reference, "reference");
            this.reference = reference;
            return this;
        }


        /**
         * Price of the message.
         */
        public Builder price(Price price) {
            Utils.checkNotNull(price, "price");
            this.price = Optional.ofNullable(price);
            return this;
        }

        /**
         * Price of the message.
         */
        public Builder price(Optional<? extends Price> price) {
            Utils.checkNotNull(price, "price");
            this.price = price;
            return this;
        }


        /**
         * The error returned if your message status is failed or undelivered.
         */
        public Builder error(Error error) {
            Utils.checkNotNull(error, "error");
            this.error = Optional.ofNullable(error);
            return this;
        }

        /**
         * The error returned if your message status is failed or undelivered.
         */
        public Builder error(Optional<? extends Error> error) {
            Utils.checkNotNull(error, "error");
            this.error = error;
            return this;
        }


        /**
         * The ID of the Messaging Service used with the message. In case of Plivo this links to the Powerpack ID.
         */
        public Builder messagingServiceId(String messagingServiceId) {
            Utils.checkNotNull(messagingServiceId, "messagingServiceId");
            this.messagingServiceId = Optional.ofNullable(messagingServiceId);
            return this;
        }

        /**
         * The ID of the Messaging Service used with the message. In case of Plivo this links to the Powerpack ID.
         */
        public Builder messagingServiceId(Optional<String> messagingServiceId) {
            Utils.checkNotNull(messagingServiceId, "messagingServiceId");
            this.messagingServiceId = messagingServiceId;
            return this;
        }


        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(Map<String, Object> customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = JsonNullable.of(customMappings);
            return this;
        }

        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(JsonNullable<? extends Map<String, Object>> customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = customMappings;
            return this;
        }


        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(String updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = JsonNullable.of(updatedBy);
            return this;
        }

        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(JsonNullable<String> updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = updatedBy;
            return this;
        }


        /**
         * The user who created the object.
         */
        public Builder createdBy(String createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = JsonNullable.of(createdBy);
            return this;
        }

        /**
         * The user who created the object.
         */
        public Builder createdBy(JsonNullable<String> createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = createdBy;
            return this;
        }


        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(OffsetDateTime updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = JsonNullable.of(updatedAt);
            return this;
        }

        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(JsonNullable<OffsetDateTime> updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = updatedAt;
            return this;
        }


        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(OffsetDateTime createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = JsonNullable.of(createdAt);
            return this;
        }

        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(JsonNullable<OffsetDateTime> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }


        /**
         * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
         */
        public Builder passThrough(List<PassThroughBody> passThrough) {
            Utils.checkNotNull(passThrough, "passThrough");
            this.passThrough = Optional.ofNullable(passThrough);
            return this;
        }

        /**
         * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
         */
        public Builder passThrough(Optional<? extends List<PassThroughBody>> passThrough) {
            Utils.checkNotNull(passThrough, "passThrough");
            this.passThrough = passThrough;
            return this;
        }

        public Message build() {

            return new Message(
                id, from, to,
                subject, body, type,
                numberOfUnits, numberOfMediaFiles, direction,
                status, scheduledAt, sentAt,
                webhookUrl, reference, price,
                error, messagingServiceId, customMappings,
                updatedBy, createdBy, updatedAt,
                createdAt, passThrough);
        }

    }
}
