/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.apideck.unify.models.components;

import com.apideck.unify.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class PurchaseOrder {
    /**
     * A unique identifier for an object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    private Optional<String> id;

    /**
     * The third-party API ID of original entity
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("downstream_id")
    private JsonNullable<String> downstreamId;

    /**
     * A PO Number uniquely identifies a purchase order and is generally defined by the buyer.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("po_number")
    private JsonNullable<String> poNumber;

    /**
     * Optional purchase order reference.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("reference")
    private JsonNullable<String> reference;

    /**
     * The supplier this entity is linked to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("supplier")
    private JsonNullable<? extends LinkedSupplier> supplier;

    /**
     * The ID of the subsidiary
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subsidiary_id")
    private JsonNullable<String> subsidiaryId;

    /**
     * The company or subsidiary id the transaction belongs to
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("company_id")
    private JsonNullable<String> companyId;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("status")
    private JsonNullable<? extends PurchaseOrderStatus> status;

    /**
     * Date purchase order was issued - YYYY-MM-DD.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("issued_date")
    private JsonNullable<LocalDate> issuedDate;

    /**
     * The date on which the purchase order is to be delivered - YYYY-MM-DD.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("delivery_date")
    private JsonNullable<LocalDate> deliveryDate;

    /**
     * The date on which the order is expected to arrive - YYYY-MM-DD.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("expected_arrival_date")
    private JsonNullable<LocalDate> expectedArrivalDate;

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency")
    private JsonNullable<? extends Currency> currency;

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("currency_rate")
    private JsonNullable<Double> currencyRate;

    /**
     * Sub-total amount, normally before tax.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sub_total")
    private JsonNullable<Double> subTotal;

    /**
     * Total tax amount applied to this invoice.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("total_tax")
    private JsonNullable<Double> totalTax;

    /**
     * Total amount of invoice, including tax.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("total")
    private JsonNullable<Double> total;

    /**
     * Amounts are including tax
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tax_inclusive")
    private JsonNullable<Boolean> taxInclusive;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("line_items")
    private Optional<? extends List<InvoiceLineItem>> lineItems;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("shipping_address")
    private Optional<? extends Address> shippingAddress;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ledger_account")
    private JsonNullable<? extends LinkedLedgerAccount> ledgerAccount;

    /**
     * Optional purchase order template
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("template_id")
    private JsonNullable<String> templateId;

    /**
     * Discount percentage applied to this transaction.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("discount_percentage")
    private JsonNullable<Double> discountPercentage;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bank_account")
    private Optional<? extends BankAccount> bankAccount;

    /**
     * Indicates if accounting by row is used (true) or not (false). Accounting by row means that a separate ledger transaction is created for each row.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("accounting_by_row")
    private JsonNullable<Boolean> accountingByRow;

    /**
     * The due date is the date on which a payment is scheduled to be received - YYYY-MM-DD.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("due_date")
    private JsonNullable<LocalDate> dueDate;

    /**
     * Payment method used for the transaction, such as cash, credit card, bank transfer, or check
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("payment_method")
    private JsonNullable<String> paymentMethod;

    /**
     * Type of amortization
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amortization_type")
    private JsonNullable<? extends AmortizationType> amortizationType;

    /**
     * Applicable tax id/code override if tax is not supplied on a line item basis.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tax_code")
    private JsonNullable<String> taxCode;

    /**
     * The channel through which the transaction is processed.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("channel")
    private JsonNullable<String> channel;

    /**
     * Message for the supplier. This text appears on the Purchase Order.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("memo")
    private JsonNullable<String> memo;

    /**
     * Internal notes for the purchase order.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("notes")
    private JsonNullable<String> notes;

    /**
     * A list of linked tracking categories.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tracking_categories")
    private JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories;

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_mappings")
    private JsonNullable<? extends Map<String, Object>> customMappings;


    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_fields")
    private Optional<? extends List<CustomField>> customFields;

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("row_version")
    private JsonNullable<String> rowVersion;

    /**
     * The user who last updated the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_by")
    private JsonNullable<String> updatedBy;

    /**
     * The user who created the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_by")
    private JsonNullable<String> createdBy;

    /**
     * The date and time when the object was last updated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_at")
    private JsonNullable<OffsetDateTime> updatedAt;

    /**
     * The date and time when the object was created.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_at")
    private JsonNullable<OffsetDateTime> createdAt;

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pass_through")
    private Optional<? extends List<PassThroughBody>> passThrough;

    @JsonCreator
    public PurchaseOrder(
            @JsonProperty("id") Optional<String> id,
            @JsonProperty("downstream_id") JsonNullable<String> downstreamId,
            @JsonProperty("po_number") JsonNullable<String> poNumber,
            @JsonProperty("reference") JsonNullable<String> reference,
            @JsonProperty("supplier") JsonNullable<? extends LinkedSupplier> supplier,
            @JsonProperty("subsidiary_id") JsonNullable<String> subsidiaryId,
            @JsonProperty("company_id") JsonNullable<String> companyId,
            @JsonProperty("status") JsonNullable<? extends PurchaseOrderStatus> status,
            @JsonProperty("issued_date") JsonNullable<LocalDate> issuedDate,
            @JsonProperty("delivery_date") JsonNullable<LocalDate> deliveryDate,
            @JsonProperty("expected_arrival_date") JsonNullable<LocalDate> expectedArrivalDate,
            @JsonProperty("currency") JsonNullable<? extends Currency> currency,
            @JsonProperty("currency_rate") JsonNullable<Double> currencyRate,
            @JsonProperty("sub_total") JsonNullable<Double> subTotal,
            @JsonProperty("total_tax") JsonNullable<Double> totalTax,
            @JsonProperty("total") JsonNullable<Double> total,
            @JsonProperty("tax_inclusive") JsonNullable<Boolean> taxInclusive,
            @JsonProperty("line_items") Optional<? extends List<InvoiceLineItem>> lineItems,
            @JsonProperty("shipping_address") Optional<? extends Address> shippingAddress,
            @JsonProperty("ledger_account") JsonNullable<? extends LinkedLedgerAccount> ledgerAccount,
            @JsonProperty("template_id") JsonNullable<String> templateId,
            @JsonProperty("discount_percentage") JsonNullable<Double> discountPercentage,
            @JsonProperty("bank_account") Optional<? extends BankAccount> bankAccount,
            @JsonProperty("accounting_by_row") JsonNullable<Boolean> accountingByRow,
            @JsonProperty("due_date") JsonNullable<LocalDate> dueDate,
            @JsonProperty("payment_method") JsonNullable<String> paymentMethod,
            @JsonProperty("amortization_type") JsonNullable<? extends AmortizationType> amortizationType,
            @JsonProperty("tax_code") JsonNullable<String> taxCode,
            @JsonProperty("channel") JsonNullable<String> channel,
            @JsonProperty("memo") JsonNullable<String> memo,
            @JsonProperty("notes") JsonNullable<String> notes,
            @JsonProperty("tracking_categories") JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories,
            @JsonProperty("custom_mappings") JsonNullable<? extends Map<String, Object>> customMappings,
            @JsonProperty("custom_fields") Optional<? extends List<CustomField>> customFields,
            @JsonProperty("row_version") JsonNullable<String> rowVersion,
            @JsonProperty("updated_by") JsonNullable<String> updatedBy,
            @JsonProperty("created_by") JsonNullable<String> createdBy,
            @JsonProperty("updated_at") JsonNullable<OffsetDateTime> updatedAt,
            @JsonProperty("created_at") JsonNullable<OffsetDateTime> createdAt,
            @JsonProperty("pass_through") Optional<? extends List<PassThroughBody>> passThrough) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(downstreamId, "downstreamId");
        Utils.checkNotNull(poNumber, "poNumber");
        Utils.checkNotNull(reference, "reference");
        Utils.checkNotNull(supplier, "supplier");
        Utils.checkNotNull(subsidiaryId, "subsidiaryId");
        Utils.checkNotNull(companyId, "companyId");
        Utils.checkNotNull(status, "status");
        Utils.checkNotNull(issuedDate, "issuedDate");
        Utils.checkNotNull(deliveryDate, "deliveryDate");
        Utils.checkNotNull(expectedArrivalDate, "expectedArrivalDate");
        Utils.checkNotNull(currency, "currency");
        Utils.checkNotNull(currencyRate, "currencyRate");
        Utils.checkNotNull(subTotal, "subTotal");
        Utils.checkNotNull(totalTax, "totalTax");
        Utils.checkNotNull(total, "total");
        Utils.checkNotNull(taxInclusive, "taxInclusive");
        Utils.checkNotNull(lineItems, "lineItems");
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        Utils.checkNotNull(ledgerAccount, "ledgerAccount");
        Utils.checkNotNull(templateId, "templateId");
        Utils.checkNotNull(discountPercentage, "discountPercentage");
        Utils.checkNotNull(bankAccount, "bankAccount");
        Utils.checkNotNull(accountingByRow, "accountingByRow");
        Utils.checkNotNull(dueDate, "dueDate");
        Utils.checkNotNull(paymentMethod, "paymentMethod");
        Utils.checkNotNull(amortizationType, "amortizationType");
        Utils.checkNotNull(taxCode, "taxCode");
        Utils.checkNotNull(channel, "channel");
        Utils.checkNotNull(memo, "memo");
        Utils.checkNotNull(notes, "notes");
        Utils.checkNotNull(trackingCategories, "trackingCategories");
        Utils.checkNotNull(customMappings, "customMappings");
        Utils.checkNotNull(customFields, "customFields");
        Utils.checkNotNull(rowVersion, "rowVersion");
        Utils.checkNotNull(updatedBy, "updatedBy");
        Utils.checkNotNull(createdBy, "createdBy");
        Utils.checkNotNull(updatedAt, "updatedAt");
        Utils.checkNotNull(createdAt, "createdAt");
        Utils.checkNotNull(passThrough, "passThrough");
        this.id = id;
        this.downstreamId = downstreamId;
        this.poNumber = poNumber;
        this.reference = reference;
        this.supplier = supplier;
        this.subsidiaryId = subsidiaryId;
        this.companyId = companyId;
        this.status = status;
        this.issuedDate = issuedDate;
        this.deliveryDate = deliveryDate;
        this.expectedArrivalDate = expectedArrivalDate;
        this.currency = currency;
        this.currencyRate = currencyRate;
        this.subTotal = subTotal;
        this.totalTax = totalTax;
        this.total = total;
        this.taxInclusive = taxInclusive;
        this.lineItems = lineItems;
        this.shippingAddress = shippingAddress;
        this.ledgerAccount = ledgerAccount;
        this.templateId = templateId;
        this.discountPercentage = discountPercentage;
        this.bankAccount = bankAccount;
        this.accountingByRow = accountingByRow;
        this.dueDate = dueDate;
        this.paymentMethod = paymentMethod;
        this.amortizationType = amortizationType;
        this.taxCode = taxCode;
        this.channel = channel;
        this.memo = memo;
        this.notes = notes;
        this.trackingCategories = trackingCategories;
        this.customMappings = customMappings;
        this.customFields = customFields;
        this.rowVersion = rowVersion;
        this.updatedBy = updatedBy;
        this.createdBy = createdBy;
        this.updatedAt = updatedAt;
        this.createdAt = createdAt;
        this.passThrough = passThrough;
    }
    
    public PurchaseOrder() {
        this(Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(),
            Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(),
            JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(),
            Optional.empty());
    }

    /**
     * A unique identifier for an object.
     */
    @JsonIgnore
    public Optional<String> id() {
        return id;
    }

    /**
     * The third-party API ID of original entity
     */
    @JsonIgnore
    public JsonNullable<String> downstreamId() {
        return downstreamId;
    }

    /**
     * A PO Number uniquely identifies a purchase order and is generally defined by the buyer.
     */
    @JsonIgnore
    public JsonNullable<String> poNumber() {
        return poNumber;
    }

    /**
     * Optional purchase order reference.
     */
    @JsonIgnore
    public JsonNullable<String> reference() {
        return reference;
    }

    /**
     * The supplier this entity is linked to.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<LinkedSupplier> supplier() {
        return (JsonNullable<LinkedSupplier>) supplier;
    }

    /**
     * The ID of the subsidiary
     */
    @JsonIgnore
    public JsonNullable<String> subsidiaryId() {
        return subsidiaryId;
    }

    /**
     * The company or subsidiary id the transaction belongs to
     */
    @JsonIgnore
    public JsonNullable<String> companyId() {
        return companyId;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<PurchaseOrderStatus> status() {
        return (JsonNullable<PurchaseOrderStatus>) status;
    }

    /**
     * Date purchase order was issued - YYYY-MM-DD.
     */
    @JsonIgnore
    public JsonNullable<LocalDate> issuedDate() {
        return issuedDate;
    }

    /**
     * The date on which the purchase order is to be delivered - YYYY-MM-DD.
     */
    @JsonIgnore
    public JsonNullable<LocalDate> deliveryDate() {
        return deliveryDate;
    }

    /**
     * The date on which the order is expected to arrive - YYYY-MM-DD.
     */
    @JsonIgnore
    public JsonNullable<LocalDate> expectedArrivalDate() {
        return expectedArrivalDate;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Currency> currency() {
        return (JsonNullable<Currency>) currency;
    }

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    @JsonIgnore
    public JsonNullable<Double> currencyRate() {
        return currencyRate;
    }

    /**
     * Sub-total amount, normally before tax.
     */
    @JsonIgnore
    public JsonNullable<Double> subTotal() {
        return subTotal;
    }

    /**
     * Total tax amount applied to this invoice.
     */
    @JsonIgnore
    public JsonNullable<Double> totalTax() {
        return totalTax;
    }

    /**
     * Total amount of invoice, including tax.
     */
    @JsonIgnore
    public JsonNullable<Double> total() {
        return total;
    }

    /**
     * Amounts are including tax
     */
    @JsonIgnore
    public JsonNullable<Boolean> taxInclusive() {
        return taxInclusive;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<InvoiceLineItem>> lineItems() {
        return (Optional<List<InvoiceLineItem>>) lineItems;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Address> shippingAddress() {
        return (Optional<Address>) shippingAddress;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<LinkedLedgerAccount> ledgerAccount() {
        return (JsonNullable<LinkedLedgerAccount>) ledgerAccount;
    }

    /**
     * Optional purchase order template
     */
    @JsonIgnore
    public JsonNullable<String> templateId() {
        return templateId;
    }

    /**
     * Discount percentage applied to this transaction.
     */
    @JsonIgnore
    public JsonNullable<Double> discountPercentage() {
        return discountPercentage;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BankAccount> bankAccount() {
        return (Optional<BankAccount>) bankAccount;
    }

    /**
     * Indicates if accounting by row is used (true) or not (false). Accounting by row means that a separate ledger transaction is created for each row.
     */
    @JsonIgnore
    public JsonNullable<Boolean> accountingByRow() {
        return accountingByRow;
    }

    /**
     * The due date is the date on which a payment is scheduled to be received - YYYY-MM-DD.
     */
    @JsonIgnore
    public JsonNullable<LocalDate> dueDate() {
        return dueDate;
    }

    /**
     * Payment method used for the transaction, such as cash, credit card, bank transfer, or check
     */
    @JsonIgnore
    public JsonNullable<String> paymentMethod() {
        return paymentMethod;
    }

    /**
     * Type of amortization
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<AmortizationType> amortizationType() {
        return (JsonNullable<AmortizationType>) amortizationType;
    }

    /**
     * Applicable tax id/code override if tax is not supplied on a line item basis.
     */
    @JsonIgnore
    public JsonNullable<String> taxCode() {
        return taxCode;
    }

    /**
     * The channel through which the transaction is processed.
     */
    @JsonIgnore
    public JsonNullable<String> channel() {
        return channel;
    }

    /**
     * Message for the supplier. This text appears on the Purchase Order.
     */
    @JsonIgnore
    public JsonNullable<String> memo() {
        return memo;
    }

    /**
     * Internal notes for the purchase order.
     */
    @JsonIgnore
    public JsonNullable<String> notes() {
        return notes;
    }

    /**
     * A list of linked tracking categories.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<LinkedTrackingCategory>> trackingCategories() {
        return (JsonNullable<List<LinkedTrackingCategory>>) trackingCategories;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<Map<String, Object>> customMappings() {
        return (JsonNullable<Map<String, Object>>) customMappings;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<CustomField>> customFields() {
        return (Optional<List<CustomField>>) customFields;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    @JsonIgnore
    public JsonNullable<String> rowVersion() {
        return rowVersion;
    }

    /**
     * The user who last updated the object.
     */
    @JsonIgnore
    public JsonNullable<String> updatedBy() {
        return updatedBy;
    }

    /**
     * The user who created the object.
     */
    @JsonIgnore
    public JsonNullable<String> createdBy() {
        return createdBy;
    }

    /**
     * The date and time when the object was last updated.
     */
    @JsonIgnore
    public JsonNullable<OffsetDateTime> updatedAt() {
        return updatedAt;
    }

    /**
     * The date and time when the object was created.
     */
    @JsonIgnore
    public JsonNullable<OffsetDateTime> createdAt() {
        return createdAt;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<PassThroughBody>> passThrough() {
        return (Optional<List<PassThroughBody>>) passThrough;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * A unique identifier for an object.
     */
    public PurchaseOrder withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = Optional.ofNullable(id);
        return this;
    }


    /**
     * A unique identifier for an object.
     */
    public PurchaseOrder withId(Optional<String> id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * The third-party API ID of original entity
     */
    public PurchaseOrder withDownstreamId(String downstreamId) {
        Utils.checkNotNull(downstreamId, "downstreamId");
        this.downstreamId = JsonNullable.of(downstreamId);
        return this;
    }

    /**
     * The third-party API ID of original entity
     */
    public PurchaseOrder withDownstreamId(JsonNullable<String> downstreamId) {
        Utils.checkNotNull(downstreamId, "downstreamId");
        this.downstreamId = downstreamId;
        return this;
    }

    /**
     * A PO Number uniquely identifies a purchase order and is generally defined by the buyer.
     */
    public PurchaseOrder withPoNumber(String poNumber) {
        Utils.checkNotNull(poNumber, "poNumber");
        this.poNumber = JsonNullable.of(poNumber);
        return this;
    }

    /**
     * A PO Number uniquely identifies a purchase order and is generally defined by the buyer.
     */
    public PurchaseOrder withPoNumber(JsonNullable<String> poNumber) {
        Utils.checkNotNull(poNumber, "poNumber");
        this.poNumber = poNumber;
        return this;
    }

    /**
     * Optional purchase order reference.
     */
    public PurchaseOrder withReference(String reference) {
        Utils.checkNotNull(reference, "reference");
        this.reference = JsonNullable.of(reference);
        return this;
    }

    /**
     * Optional purchase order reference.
     */
    public PurchaseOrder withReference(JsonNullable<String> reference) {
        Utils.checkNotNull(reference, "reference");
        this.reference = reference;
        return this;
    }

    /**
     * The supplier this entity is linked to.
     */
    public PurchaseOrder withSupplier(LinkedSupplier supplier) {
        Utils.checkNotNull(supplier, "supplier");
        this.supplier = JsonNullable.of(supplier);
        return this;
    }

    /**
     * The supplier this entity is linked to.
     */
    public PurchaseOrder withSupplier(JsonNullable<? extends LinkedSupplier> supplier) {
        Utils.checkNotNull(supplier, "supplier");
        this.supplier = supplier;
        return this;
    }

    /**
     * The ID of the subsidiary
     */
    public PurchaseOrder withSubsidiaryId(String subsidiaryId) {
        Utils.checkNotNull(subsidiaryId, "subsidiaryId");
        this.subsidiaryId = JsonNullable.of(subsidiaryId);
        return this;
    }

    /**
     * The ID of the subsidiary
     */
    public PurchaseOrder withSubsidiaryId(JsonNullable<String> subsidiaryId) {
        Utils.checkNotNull(subsidiaryId, "subsidiaryId");
        this.subsidiaryId = subsidiaryId;
        return this;
    }

    /**
     * The company or subsidiary id the transaction belongs to
     */
    public PurchaseOrder withCompanyId(String companyId) {
        Utils.checkNotNull(companyId, "companyId");
        this.companyId = JsonNullable.of(companyId);
        return this;
    }

    /**
     * The company or subsidiary id the transaction belongs to
     */
    public PurchaseOrder withCompanyId(JsonNullable<String> companyId) {
        Utils.checkNotNull(companyId, "companyId");
        this.companyId = companyId;
        return this;
    }

    public PurchaseOrder withStatus(PurchaseOrderStatus status) {
        Utils.checkNotNull(status, "status");
        this.status = JsonNullable.of(status);
        return this;
    }

    public PurchaseOrder withStatus(JsonNullable<? extends PurchaseOrderStatus> status) {
        Utils.checkNotNull(status, "status");
        this.status = status;
        return this;
    }

    /**
     * Date purchase order was issued - YYYY-MM-DD.
     */
    public PurchaseOrder withIssuedDate(LocalDate issuedDate) {
        Utils.checkNotNull(issuedDate, "issuedDate");
        this.issuedDate = JsonNullable.of(issuedDate);
        return this;
    }

    /**
     * Date purchase order was issued - YYYY-MM-DD.
     */
    public PurchaseOrder withIssuedDate(JsonNullable<LocalDate> issuedDate) {
        Utils.checkNotNull(issuedDate, "issuedDate");
        this.issuedDate = issuedDate;
        return this;
    }

    /**
     * The date on which the purchase order is to be delivered - YYYY-MM-DD.
     */
    public PurchaseOrder withDeliveryDate(LocalDate deliveryDate) {
        Utils.checkNotNull(deliveryDate, "deliveryDate");
        this.deliveryDate = JsonNullable.of(deliveryDate);
        return this;
    }

    /**
     * The date on which the purchase order is to be delivered - YYYY-MM-DD.
     */
    public PurchaseOrder withDeliveryDate(JsonNullable<LocalDate> deliveryDate) {
        Utils.checkNotNull(deliveryDate, "deliveryDate");
        this.deliveryDate = deliveryDate;
        return this;
    }

    /**
     * The date on which the order is expected to arrive - YYYY-MM-DD.
     */
    public PurchaseOrder withExpectedArrivalDate(LocalDate expectedArrivalDate) {
        Utils.checkNotNull(expectedArrivalDate, "expectedArrivalDate");
        this.expectedArrivalDate = JsonNullable.of(expectedArrivalDate);
        return this;
    }

    /**
     * The date on which the order is expected to arrive - YYYY-MM-DD.
     */
    public PurchaseOrder withExpectedArrivalDate(JsonNullable<LocalDate> expectedArrivalDate) {
        Utils.checkNotNull(expectedArrivalDate, "expectedArrivalDate");
        this.expectedArrivalDate = expectedArrivalDate;
        return this;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    public PurchaseOrder withCurrency(Currency currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = JsonNullable.of(currency);
        return this;
    }

    /**
     * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
     */
    public PurchaseOrder withCurrency(JsonNullable<? extends Currency> currency) {
        Utils.checkNotNull(currency, "currency");
        this.currency = currency;
        return this;
    }

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    public PurchaseOrder withCurrencyRate(double currencyRate) {
        Utils.checkNotNull(currencyRate, "currencyRate");
        this.currencyRate = JsonNullable.of(currencyRate);
        return this;
    }

    /**
     * Currency Exchange Rate at the time entity was recorded/generated.
     */
    public PurchaseOrder withCurrencyRate(JsonNullable<Double> currencyRate) {
        Utils.checkNotNull(currencyRate, "currencyRate");
        this.currencyRate = currencyRate;
        return this;
    }

    /**
     * Sub-total amount, normally before tax.
     */
    public PurchaseOrder withSubTotal(double subTotal) {
        Utils.checkNotNull(subTotal, "subTotal");
        this.subTotal = JsonNullable.of(subTotal);
        return this;
    }

    /**
     * Sub-total amount, normally before tax.
     */
    public PurchaseOrder withSubTotal(JsonNullable<Double> subTotal) {
        Utils.checkNotNull(subTotal, "subTotal");
        this.subTotal = subTotal;
        return this;
    }

    /**
     * Total tax amount applied to this invoice.
     */
    public PurchaseOrder withTotalTax(double totalTax) {
        Utils.checkNotNull(totalTax, "totalTax");
        this.totalTax = JsonNullable.of(totalTax);
        return this;
    }

    /**
     * Total tax amount applied to this invoice.
     */
    public PurchaseOrder withTotalTax(JsonNullable<Double> totalTax) {
        Utils.checkNotNull(totalTax, "totalTax");
        this.totalTax = totalTax;
        return this;
    }

    /**
     * Total amount of invoice, including tax.
     */
    public PurchaseOrder withTotal(double total) {
        Utils.checkNotNull(total, "total");
        this.total = JsonNullable.of(total);
        return this;
    }

    /**
     * Total amount of invoice, including tax.
     */
    public PurchaseOrder withTotal(JsonNullable<Double> total) {
        Utils.checkNotNull(total, "total");
        this.total = total;
        return this;
    }

    /**
     * Amounts are including tax
     */
    public PurchaseOrder withTaxInclusive(boolean taxInclusive) {
        Utils.checkNotNull(taxInclusive, "taxInclusive");
        this.taxInclusive = JsonNullable.of(taxInclusive);
        return this;
    }

    /**
     * Amounts are including tax
     */
    public PurchaseOrder withTaxInclusive(JsonNullable<Boolean> taxInclusive) {
        Utils.checkNotNull(taxInclusive, "taxInclusive");
        this.taxInclusive = taxInclusive;
        return this;
    }

    public PurchaseOrder withLineItems(List<InvoiceLineItem> lineItems) {
        Utils.checkNotNull(lineItems, "lineItems");
        this.lineItems = Optional.ofNullable(lineItems);
        return this;
    }


    public PurchaseOrder withLineItems(Optional<? extends List<InvoiceLineItem>> lineItems) {
        Utils.checkNotNull(lineItems, "lineItems");
        this.lineItems = lineItems;
        return this;
    }

    public PurchaseOrder withShippingAddress(Address shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = Optional.ofNullable(shippingAddress);
        return this;
    }


    public PurchaseOrder withShippingAddress(Optional<? extends Address> shippingAddress) {
        Utils.checkNotNull(shippingAddress, "shippingAddress");
        this.shippingAddress = shippingAddress;
        return this;
    }

    public PurchaseOrder withLedgerAccount(LinkedLedgerAccount ledgerAccount) {
        Utils.checkNotNull(ledgerAccount, "ledgerAccount");
        this.ledgerAccount = JsonNullable.of(ledgerAccount);
        return this;
    }

    public PurchaseOrder withLedgerAccount(JsonNullable<? extends LinkedLedgerAccount> ledgerAccount) {
        Utils.checkNotNull(ledgerAccount, "ledgerAccount");
        this.ledgerAccount = ledgerAccount;
        return this;
    }

    /**
     * Optional purchase order template
     */
    public PurchaseOrder withTemplateId(String templateId) {
        Utils.checkNotNull(templateId, "templateId");
        this.templateId = JsonNullable.of(templateId);
        return this;
    }

    /**
     * Optional purchase order template
     */
    public PurchaseOrder withTemplateId(JsonNullable<String> templateId) {
        Utils.checkNotNull(templateId, "templateId");
        this.templateId = templateId;
        return this;
    }

    /**
     * Discount percentage applied to this transaction.
     */
    public PurchaseOrder withDiscountPercentage(double discountPercentage) {
        Utils.checkNotNull(discountPercentage, "discountPercentage");
        this.discountPercentage = JsonNullable.of(discountPercentage);
        return this;
    }

    /**
     * Discount percentage applied to this transaction.
     */
    public PurchaseOrder withDiscountPercentage(JsonNullable<Double> discountPercentage) {
        Utils.checkNotNull(discountPercentage, "discountPercentage");
        this.discountPercentage = discountPercentage;
        return this;
    }

    public PurchaseOrder withBankAccount(BankAccount bankAccount) {
        Utils.checkNotNull(bankAccount, "bankAccount");
        this.bankAccount = Optional.ofNullable(bankAccount);
        return this;
    }


    public PurchaseOrder withBankAccount(Optional<? extends BankAccount> bankAccount) {
        Utils.checkNotNull(bankAccount, "bankAccount");
        this.bankAccount = bankAccount;
        return this;
    }

    /**
     * Indicates if accounting by row is used (true) or not (false). Accounting by row means that a separate ledger transaction is created for each row.
     */
    public PurchaseOrder withAccountingByRow(boolean accountingByRow) {
        Utils.checkNotNull(accountingByRow, "accountingByRow");
        this.accountingByRow = JsonNullable.of(accountingByRow);
        return this;
    }

    /**
     * Indicates if accounting by row is used (true) or not (false). Accounting by row means that a separate ledger transaction is created for each row.
     */
    public PurchaseOrder withAccountingByRow(JsonNullable<Boolean> accountingByRow) {
        Utils.checkNotNull(accountingByRow, "accountingByRow");
        this.accountingByRow = accountingByRow;
        return this;
    }

    /**
     * The due date is the date on which a payment is scheduled to be received - YYYY-MM-DD.
     */
    public PurchaseOrder withDueDate(LocalDate dueDate) {
        Utils.checkNotNull(dueDate, "dueDate");
        this.dueDate = JsonNullable.of(dueDate);
        return this;
    }

    /**
     * The due date is the date on which a payment is scheduled to be received - YYYY-MM-DD.
     */
    public PurchaseOrder withDueDate(JsonNullable<LocalDate> dueDate) {
        Utils.checkNotNull(dueDate, "dueDate");
        this.dueDate = dueDate;
        return this;
    }

    /**
     * Payment method used for the transaction, such as cash, credit card, bank transfer, or check
     */
    public PurchaseOrder withPaymentMethod(String paymentMethod) {
        Utils.checkNotNull(paymentMethod, "paymentMethod");
        this.paymentMethod = JsonNullable.of(paymentMethod);
        return this;
    }

    /**
     * Payment method used for the transaction, such as cash, credit card, bank transfer, or check
     */
    public PurchaseOrder withPaymentMethod(JsonNullable<String> paymentMethod) {
        Utils.checkNotNull(paymentMethod, "paymentMethod");
        this.paymentMethod = paymentMethod;
        return this;
    }

    /**
     * Type of amortization
     */
    public PurchaseOrder withAmortizationType(AmortizationType amortizationType) {
        Utils.checkNotNull(amortizationType, "amortizationType");
        this.amortizationType = JsonNullable.of(amortizationType);
        return this;
    }

    /**
     * Type of amortization
     */
    public PurchaseOrder withAmortizationType(JsonNullable<? extends AmortizationType> amortizationType) {
        Utils.checkNotNull(amortizationType, "amortizationType");
        this.amortizationType = amortizationType;
        return this;
    }

    /**
     * Applicable tax id/code override if tax is not supplied on a line item basis.
     */
    public PurchaseOrder withTaxCode(String taxCode) {
        Utils.checkNotNull(taxCode, "taxCode");
        this.taxCode = JsonNullable.of(taxCode);
        return this;
    }

    /**
     * Applicable tax id/code override if tax is not supplied on a line item basis.
     */
    public PurchaseOrder withTaxCode(JsonNullable<String> taxCode) {
        Utils.checkNotNull(taxCode, "taxCode");
        this.taxCode = taxCode;
        return this;
    }

    /**
     * The channel through which the transaction is processed.
     */
    public PurchaseOrder withChannel(String channel) {
        Utils.checkNotNull(channel, "channel");
        this.channel = JsonNullable.of(channel);
        return this;
    }

    /**
     * The channel through which the transaction is processed.
     */
    public PurchaseOrder withChannel(JsonNullable<String> channel) {
        Utils.checkNotNull(channel, "channel");
        this.channel = channel;
        return this;
    }

    /**
     * Message for the supplier. This text appears on the Purchase Order.
     */
    public PurchaseOrder withMemo(String memo) {
        Utils.checkNotNull(memo, "memo");
        this.memo = JsonNullable.of(memo);
        return this;
    }

    /**
     * Message for the supplier. This text appears on the Purchase Order.
     */
    public PurchaseOrder withMemo(JsonNullable<String> memo) {
        Utils.checkNotNull(memo, "memo");
        this.memo = memo;
        return this;
    }

    /**
     * Internal notes for the purchase order.
     */
    public PurchaseOrder withNotes(String notes) {
        Utils.checkNotNull(notes, "notes");
        this.notes = JsonNullable.of(notes);
        return this;
    }

    /**
     * Internal notes for the purchase order.
     */
    public PurchaseOrder withNotes(JsonNullable<String> notes) {
        Utils.checkNotNull(notes, "notes");
        this.notes = notes;
        return this;
    }

    /**
     * A list of linked tracking categories.
     */
    public PurchaseOrder withTrackingCategories(List<LinkedTrackingCategory> trackingCategories) {
        Utils.checkNotNull(trackingCategories, "trackingCategories");
        this.trackingCategories = JsonNullable.of(trackingCategories);
        return this;
    }

    /**
     * A list of linked tracking categories.
     */
    public PurchaseOrder withTrackingCategories(JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories) {
        Utils.checkNotNull(trackingCategories, "trackingCategories");
        this.trackingCategories = trackingCategories;
        return this;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public PurchaseOrder withCustomMappings(Map<String, Object> customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = JsonNullable.of(customMappings);
        return this;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public PurchaseOrder withCustomMappings(JsonNullable<? extends Map<String, Object>> customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = customMappings;
        return this;
    }

    public PurchaseOrder withCustomFields(List<CustomField> customFields) {
        Utils.checkNotNull(customFields, "customFields");
        this.customFields = Optional.ofNullable(customFields);
        return this;
    }


    public PurchaseOrder withCustomFields(Optional<? extends List<CustomField>> customFields) {
        Utils.checkNotNull(customFields, "customFields");
        this.customFields = customFields;
        return this;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    public PurchaseOrder withRowVersion(String rowVersion) {
        Utils.checkNotNull(rowVersion, "rowVersion");
        this.rowVersion = JsonNullable.of(rowVersion);
        return this;
    }

    /**
     * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
     */
    public PurchaseOrder withRowVersion(JsonNullable<String> rowVersion) {
        Utils.checkNotNull(rowVersion, "rowVersion");
        this.rowVersion = rowVersion;
        return this;
    }

    /**
     * The user who last updated the object.
     */
    public PurchaseOrder withUpdatedBy(String updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = JsonNullable.of(updatedBy);
        return this;
    }

    /**
     * The user who last updated the object.
     */
    public PurchaseOrder withUpdatedBy(JsonNullable<String> updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = updatedBy;
        return this;
    }

    /**
     * The user who created the object.
     */
    public PurchaseOrder withCreatedBy(String createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = JsonNullable.of(createdBy);
        return this;
    }

    /**
     * The user who created the object.
     */
    public PurchaseOrder withCreatedBy(JsonNullable<String> createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = createdBy;
        return this;
    }

    /**
     * The date and time when the object was last updated.
     */
    public PurchaseOrder withUpdatedAt(OffsetDateTime updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = JsonNullable.of(updatedAt);
        return this;
    }

    /**
     * The date and time when the object was last updated.
     */
    public PurchaseOrder withUpdatedAt(JsonNullable<OffsetDateTime> updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = updatedAt;
        return this;
    }

    /**
     * The date and time when the object was created.
     */
    public PurchaseOrder withCreatedAt(OffsetDateTime createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = JsonNullable.of(createdAt);
        return this;
    }

    /**
     * The date and time when the object was created.
     */
    public PurchaseOrder withCreatedAt(JsonNullable<OffsetDateTime> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    public PurchaseOrder withPassThrough(List<PassThroughBody> passThrough) {
        Utils.checkNotNull(passThrough, "passThrough");
        this.passThrough = Optional.ofNullable(passThrough);
        return this;
    }


    /**
     * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
     */
    public PurchaseOrder withPassThrough(Optional<? extends List<PassThroughBody>> passThrough) {
        Utils.checkNotNull(passThrough, "passThrough");
        this.passThrough = passThrough;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        PurchaseOrder other = (PurchaseOrder) o;
        return 
            Utils.enhancedDeepEquals(this.id, other.id) &&
            Utils.enhancedDeepEquals(this.downstreamId, other.downstreamId) &&
            Utils.enhancedDeepEquals(this.poNumber, other.poNumber) &&
            Utils.enhancedDeepEquals(this.reference, other.reference) &&
            Utils.enhancedDeepEquals(this.supplier, other.supplier) &&
            Utils.enhancedDeepEquals(this.subsidiaryId, other.subsidiaryId) &&
            Utils.enhancedDeepEquals(this.companyId, other.companyId) &&
            Utils.enhancedDeepEquals(this.status, other.status) &&
            Utils.enhancedDeepEquals(this.issuedDate, other.issuedDate) &&
            Utils.enhancedDeepEquals(this.deliveryDate, other.deliveryDate) &&
            Utils.enhancedDeepEquals(this.expectedArrivalDate, other.expectedArrivalDate) &&
            Utils.enhancedDeepEquals(this.currency, other.currency) &&
            Utils.enhancedDeepEquals(this.currencyRate, other.currencyRate) &&
            Utils.enhancedDeepEquals(this.subTotal, other.subTotal) &&
            Utils.enhancedDeepEquals(this.totalTax, other.totalTax) &&
            Utils.enhancedDeepEquals(this.total, other.total) &&
            Utils.enhancedDeepEquals(this.taxInclusive, other.taxInclusive) &&
            Utils.enhancedDeepEquals(this.lineItems, other.lineItems) &&
            Utils.enhancedDeepEquals(this.shippingAddress, other.shippingAddress) &&
            Utils.enhancedDeepEquals(this.ledgerAccount, other.ledgerAccount) &&
            Utils.enhancedDeepEquals(this.templateId, other.templateId) &&
            Utils.enhancedDeepEquals(this.discountPercentage, other.discountPercentage) &&
            Utils.enhancedDeepEquals(this.bankAccount, other.bankAccount) &&
            Utils.enhancedDeepEquals(this.accountingByRow, other.accountingByRow) &&
            Utils.enhancedDeepEquals(this.dueDate, other.dueDate) &&
            Utils.enhancedDeepEquals(this.paymentMethod, other.paymentMethod) &&
            Utils.enhancedDeepEquals(this.amortizationType, other.amortizationType) &&
            Utils.enhancedDeepEquals(this.taxCode, other.taxCode) &&
            Utils.enhancedDeepEquals(this.channel, other.channel) &&
            Utils.enhancedDeepEquals(this.memo, other.memo) &&
            Utils.enhancedDeepEquals(this.notes, other.notes) &&
            Utils.enhancedDeepEquals(this.trackingCategories, other.trackingCategories) &&
            Utils.enhancedDeepEquals(this.customMappings, other.customMappings) &&
            Utils.enhancedDeepEquals(this.customFields, other.customFields) &&
            Utils.enhancedDeepEquals(this.rowVersion, other.rowVersion) &&
            Utils.enhancedDeepEquals(this.updatedBy, other.updatedBy) &&
            Utils.enhancedDeepEquals(this.createdBy, other.createdBy) &&
            Utils.enhancedDeepEquals(this.updatedAt, other.updatedAt) &&
            Utils.enhancedDeepEquals(this.createdAt, other.createdAt) &&
            Utils.enhancedDeepEquals(this.passThrough, other.passThrough);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            id, downstreamId, poNumber,
            reference, supplier, subsidiaryId,
            companyId, status, issuedDate,
            deliveryDate, expectedArrivalDate, currency,
            currencyRate, subTotal, totalTax,
            total, taxInclusive, lineItems,
            shippingAddress, ledgerAccount, templateId,
            discountPercentage, bankAccount, accountingByRow,
            dueDate, paymentMethod, amortizationType,
            taxCode, channel, memo,
            notes, trackingCategories, customMappings,
            customFields, rowVersion, updatedBy,
            createdBy, updatedAt, createdAt,
            passThrough);
    }
    
    @Override
    public String toString() {
        return Utils.toString(PurchaseOrder.class,
                "id", id,
                "downstreamId", downstreamId,
                "poNumber", poNumber,
                "reference", reference,
                "supplier", supplier,
                "subsidiaryId", subsidiaryId,
                "companyId", companyId,
                "status", status,
                "issuedDate", issuedDate,
                "deliveryDate", deliveryDate,
                "expectedArrivalDate", expectedArrivalDate,
                "currency", currency,
                "currencyRate", currencyRate,
                "subTotal", subTotal,
                "totalTax", totalTax,
                "total", total,
                "taxInclusive", taxInclusive,
                "lineItems", lineItems,
                "shippingAddress", shippingAddress,
                "ledgerAccount", ledgerAccount,
                "templateId", templateId,
                "discountPercentage", discountPercentage,
                "bankAccount", bankAccount,
                "accountingByRow", accountingByRow,
                "dueDate", dueDate,
                "paymentMethod", paymentMethod,
                "amortizationType", amortizationType,
                "taxCode", taxCode,
                "channel", channel,
                "memo", memo,
                "notes", notes,
                "trackingCategories", trackingCategories,
                "customMappings", customMappings,
                "customFields", customFields,
                "rowVersion", rowVersion,
                "updatedBy", updatedBy,
                "createdBy", createdBy,
                "updatedAt", updatedAt,
                "createdAt", createdAt,
                "passThrough", passThrough);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<String> id = Optional.empty();

        private JsonNullable<String> downstreamId = JsonNullable.undefined();

        private JsonNullable<String> poNumber = JsonNullable.undefined();

        private JsonNullable<String> reference = JsonNullable.undefined();

        private JsonNullable<? extends LinkedSupplier> supplier = JsonNullable.undefined();

        private JsonNullable<String> subsidiaryId = JsonNullable.undefined();

        private JsonNullable<String> companyId = JsonNullable.undefined();

        private JsonNullable<? extends PurchaseOrderStatus> status = JsonNullable.undefined();

        private JsonNullable<LocalDate> issuedDate = JsonNullable.undefined();

        private JsonNullable<LocalDate> deliveryDate = JsonNullable.undefined();

        private JsonNullable<LocalDate> expectedArrivalDate = JsonNullable.undefined();

        private JsonNullable<? extends Currency> currency = JsonNullable.undefined();

        private JsonNullable<Double> currencyRate = JsonNullable.undefined();

        private JsonNullable<Double> subTotal = JsonNullable.undefined();

        private JsonNullable<Double> totalTax = JsonNullable.undefined();

        private JsonNullable<Double> total = JsonNullable.undefined();

        private JsonNullable<Boolean> taxInclusive = JsonNullable.undefined();

        private Optional<? extends List<InvoiceLineItem>> lineItems = Optional.empty();

        private Optional<? extends Address> shippingAddress = Optional.empty();

        private JsonNullable<? extends LinkedLedgerAccount> ledgerAccount = JsonNullable.undefined();

        private JsonNullable<String> templateId = JsonNullable.undefined();

        private JsonNullable<Double> discountPercentage = JsonNullable.undefined();

        private Optional<? extends BankAccount> bankAccount = Optional.empty();

        private JsonNullable<Boolean> accountingByRow = JsonNullable.undefined();

        private JsonNullable<LocalDate> dueDate = JsonNullable.undefined();

        private JsonNullable<String> paymentMethod = JsonNullable.undefined();

        private JsonNullable<? extends AmortizationType> amortizationType = JsonNullable.undefined();

        private JsonNullable<String> taxCode = JsonNullable.undefined();

        private JsonNullable<String> channel = JsonNullable.undefined();

        private JsonNullable<String> memo = JsonNullable.undefined();

        private JsonNullable<String> notes = JsonNullable.undefined();

        private JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories = JsonNullable.undefined();

        private JsonNullable<? extends Map<String, Object>> customMappings = JsonNullable.undefined();

        private Optional<? extends List<CustomField>> customFields = Optional.empty();

        private JsonNullable<String> rowVersion = JsonNullable.undefined();

        private JsonNullable<String> updatedBy = JsonNullable.undefined();

        private JsonNullable<String> createdBy = JsonNullable.undefined();

        private JsonNullable<OffsetDateTime> updatedAt = JsonNullable.undefined();

        private JsonNullable<OffsetDateTime> createdAt = JsonNullable.undefined();

        private Optional<? extends List<PassThroughBody>> passThrough = Optional.empty();

        private Builder() {
          // force use of static builder() method
        }


        /**
         * A unique identifier for an object.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = Optional.ofNullable(id);
            return this;
        }

        /**
         * A unique identifier for an object.
         */
        public Builder id(Optional<String> id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }


        /**
         * The third-party API ID of original entity
         */
        public Builder downstreamId(String downstreamId) {
            Utils.checkNotNull(downstreamId, "downstreamId");
            this.downstreamId = JsonNullable.of(downstreamId);
            return this;
        }

        /**
         * The third-party API ID of original entity
         */
        public Builder downstreamId(JsonNullable<String> downstreamId) {
            Utils.checkNotNull(downstreamId, "downstreamId");
            this.downstreamId = downstreamId;
            return this;
        }


        /**
         * A PO Number uniquely identifies a purchase order and is generally defined by the buyer.
         */
        public Builder poNumber(String poNumber) {
            Utils.checkNotNull(poNumber, "poNumber");
            this.poNumber = JsonNullable.of(poNumber);
            return this;
        }

        /**
         * A PO Number uniquely identifies a purchase order and is generally defined by the buyer.
         */
        public Builder poNumber(JsonNullable<String> poNumber) {
            Utils.checkNotNull(poNumber, "poNumber");
            this.poNumber = poNumber;
            return this;
        }


        /**
         * Optional purchase order reference.
         */
        public Builder reference(String reference) {
            Utils.checkNotNull(reference, "reference");
            this.reference = JsonNullable.of(reference);
            return this;
        }

        /**
         * Optional purchase order reference.
         */
        public Builder reference(JsonNullable<String> reference) {
            Utils.checkNotNull(reference, "reference");
            this.reference = reference;
            return this;
        }


        /**
         * The supplier this entity is linked to.
         */
        public Builder supplier(LinkedSupplier supplier) {
            Utils.checkNotNull(supplier, "supplier");
            this.supplier = JsonNullable.of(supplier);
            return this;
        }

        /**
         * The supplier this entity is linked to.
         */
        public Builder supplier(JsonNullable<? extends LinkedSupplier> supplier) {
            Utils.checkNotNull(supplier, "supplier");
            this.supplier = supplier;
            return this;
        }


        /**
         * The ID of the subsidiary
         */
        public Builder subsidiaryId(String subsidiaryId) {
            Utils.checkNotNull(subsidiaryId, "subsidiaryId");
            this.subsidiaryId = JsonNullable.of(subsidiaryId);
            return this;
        }

        /**
         * The ID of the subsidiary
         */
        public Builder subsidiaryId(JsonNullable<String> subsidiaryId) {
            Utils.checkNotNull(subsidiaryId, "subsidiaryId");
            this.subsidiaryId = subsidiaryId;
            return this;
        }


        /**
         * The company or subsidiary id the transaction belongs to
         */
        public Builder companyId(String companyId) {
            Utils.checkNotNull(companyId, "companyId");
            this.companyId = JsonNullable.of(companyId);
            return this;
        }

        /**
         * The company or subsidiary id the transaction belongs to
         */
        public Builder companyId(JsonNullable<String> companyId) {
            Utils.checkNotNull(companyId, "companyId");
            this.companyId = companyId;
            return this;
        }


        public Builder status(PurchaseOrderStatus status) {
            Utils.checkNotNull(status, "status");
            this.status = JsonNullable.of(status);
            return this;
        }

        public Builder status(JsonNullable<? extends PurchaseOrderStatus> status) {
            Utils.checkNotNull(status, "status");
            this.status = status;
            return this;
        }


        /**
         * Date purchase order was issued - YYYY-MM-DD.
         */
        public Builder issuedDate(LocalDate issuedDate) {
            Utils.checkNotNull(issuedDate, "issuedDate");
            this.issuedDate = JsonNullable.of(issuedDate);
            return this;
        }

        /**
         * Date purchase order was issued - YYYY-MM-DD.
         */
        public Builder issuedDate(JsonNullable<LocalDate> issuedDate) {
            Utils.checkNotNull(issuedDate, "issuedDate");
            this.issuedDate = issuedDate;
            return this;
        }


        /**
         * The date on which the purchase order is to be delivered - YYYY-MM-DD.
         */
        public Builder deliveryDate(LocalDate deliveryDate) {
            Utils.checkNotNull(deliveryDate, "deliveryDate");
            this.deliveryDate = JsonNullable.of(deliveryDate);
            return this;
        }

        /**
         * The date on which the purchase order is to be delivered - YYYY-MM-DD.
         */
        public Builder deliveryDate(JsonNullable<LocalDate> deliveryDate) {
            Utils.checkNotNull(deliveryDate, "deliveryDate");
            this.deliveryDate = deliveryDate;
            return this;
        }


        /**
         * The date on which the order is expected to arrive - YYYY-MM-DD.
         */
        public Builder expectedArrivalDate(LocalDate expectedArrivalDate) {
            Utils.checkNotNull(expectedArrivalDate, "expectedArrivalDate");
            this.expectedArrivalDate = JsonNullable.of(expectedArrivalDate);
            return this;
        }

        /**
         * The date on which the order is expected to arrive - YYYY-MM-DD.
         */
        public Builder expectedArrivalDate(JsonNullable<LocalDate> expectedArrivalDate) {
            Utils.checkNotNull(expectedArrivalDate, "expectedArrivalDate");
            this.expectedArrivalDate = expectedArrivalDate;
            return this;
        }


        /**
         * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
         */
        public Builder currency(Currency currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = JsonNullable.of(currency);
            return this;
        }

        /**
         * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
         */
        public Builder currency(JsonNullable<? extends Currency> currency) {
            Utils.checkNotNull(currency, "currency");
            this.currency = currency;
            return this;
        }


        /**
         * Currency Exchange Rate at the time entity was recorded/generated.
         */
        public Builder currencyRate(double currencyRate) {
            Utils.checkNotNull(currencyRate, "currencyRate");
            this.currencyRate = JsonNullable.of(currencyRate);
            return this;
        }

        /**
         * Currency Exchange Rate at the time entity was recorded/generated.
         */
        public Builder currencyRate(JsonNullable<Double> currencyRate) {
            Utils.checkNotNull(currencyRate, "currencyRate");
            this.currencyRate = currencyRate;
            return this;
        }


        /**
         * Sub-total amount, normally before tax.
         */
        public Builder subTotal(double subTotal) {
            Utils.checkNotNull(subTotal, "subTotal");
            this.subTotal = JsonNullable.of(subTotal);
            return this;
        }

        /**
         * Sub-total amount, normally before tax.
         */
        public Builder subTotal(JsonNullable<Double> subTotal) {
            Utils.checkNotNull(subTotal, "subTotal");
            this.subTotal = subTotal;
            return this;
        }


        /**
         * Total tax amount applied to this invoice.
         */
        public Builder totalTax(double totalTax) {
            Utils.checkNotNull(totalTax, "totalTax");
            this.totalTax = JsonNullable.of(totalTax);
            return this;
        }

        /**
         * Total tax amount applied to this invoice.
         */
        public Builder totalTax(JsonNullable<Double> totalTax) {
            Utils.checkNotNull(totalTax, "totalTax");
            this.totalTax = totalTax;
            return this;
        }


        /**
         * Total amount of invoice, including tax.
         */
        public Builder total(double total) {
            Utils.checkNotNull(total, "total");
            this.total = JsonNullable.of(total);
            return this;
        }

        /**
         * Total amount of invoice, including tax.
         */
        public Builder total(JsonNullable<Double> total) {
            Utils.checkNotNull(total, "total");
            this.total = total;
            return this;
        }


        /**
         * Amounts are including tax
         */
        public Builder taxInclusive(boolean taxInclusive) {
            Utils.checkNotNull(taxInclusive, "taxInclusive");
            this.taxInclusive = JsonNullable.of(taxInclusive);
            return this;
        }

        /**
         * Amounts are including tax
         */
        public Builder taxInclusive(JsonNullable<Boolean> taxInclusive) {
            Utils.checkNotNull(taxInclusive, "taxInclusive");
            this.taxInclusive = taxInclusive;
            return this;
        }


        public Builder lineItems(List<InvoiceLineItem> lineItems) {
            Utils.checkNotNull(lineItems, "lineItems");
            this.lineItems = Optional.ofNullable(lineItems);
            return this;
        }

        public Builder lineItems(Optional<? extends List<InvoiceLineItem>> lineItems) {
            Utils.checkNotNull(lineItems, "lineItems");
            this.lineItems = lineItems;
            return this;
        }


        public Builder shippingAddress(Address shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = Optional.ofNullable(shippingAddress);
            return this;
        }

        public Builder shippingAddress(Optional<? extends Address> shippingAddress) {
            Utils.checkNotNull(shippingAddress, "shippingAddress");
            this.shippingAddress = shippingAddress;
            return this;
        }


        public Builder ledgerAccount(LinkedLedgerAccount ledgerAccount) {
            Utils.checkNotNull(ledgerAccount, "ledgerAccount");
            this.ledgerAccount = JsonNullable.of(ledgerAccount);
            return this;
        }

        public Builder ledgerAccount(JsonNullable<? extends LinkedLedgerAccount> ledgerAccount) {
            Utils.checkNotNull(ledgerAccount, "ledgerAccount");
            this.ledgerAccount = ledgerAccount;
            return this;
        }


        /**
         * Optional purchase order template
         */
        public Builder templateId(String templateId) {
            Utils.checkNotNull(templateId, "templateId");
            this.templateId = JsonNullable.of(templateId);
            return this;
        }

        /**
         * Optional purchase order template
         */
        public Builder templateId(JsonNullable<String> templateId) {
            Utils.checkNotNull(templateId, "templateId");
            this.templateId = templateId;
            return this;
        }


        /**
         * Discount percentage applied to this transaction.
         */
        public Builder discountPercentage(double discountPercentage) {
            Utils.checkNotNull(discountPercentage, "discountPercentage");
            this.discountPercentage = JsonNullable.of(discountPercentage);
            return this;
        }

        /**
         * Discount percentage applied to this transaction.
         */
        public Builder discountPercentage(JsonNullable<Double> discountPercentage) {
            Utils.checkNotNull(discountPercentage, "discountPercentage");
            this.discountPercentage = discountPercentage;
            return this;
        }


        public Builder bankAccount(BankAccount bankAccount) {
            Utils.checkNotNull(bankAccount, "bankAccount");
            this.bankAccount = Optional.ofNullable(bankAccount);
            return this;
        }

        public Builder bankAccount(Optional<? extends BankAccount> bankAccount) {
            Utils.checkNotNull(bankAccount, "bankAccount");
            this.bankAccount = bankAccount;
            return this;
        }


        /**
         * Indicates if accounting by row is used (true) or not (false). Accounting by row means that a separate ledger transaction is created for each row.
         */
        public Builder accountingByRow(boolean accountingByRow) {
            Utils.checkNotNull(accountingByRow, "accountingByRow");
            this.accountingByRow = JsonNullable.of(accountingByRow);
            return this;
        }

        /**
         * Indicates if accounting by row is used (true) or not (false). Accounting by row means that a separate ledger transaction is created for each row.
         */
        public Builder accountingByRow(JsonNullable<Boolean> accountingByRow) {
            Utils.checkNotNull(accountingByRow, "accountingByRow");
            this.accountingByRow = accountingByRow;
            return this;
        }


        /**
         * The due date is the date on which a payment is scheduled to be received - YYYY-MM-DD.
         */
        public Builder dueDate(LocalDate dueDate) {
            Utils.checkNotNull(dueDate, "dueDate");
            this.dueDate = JsonNullable.of(dueDate);
            return this;
        }

        /**
         * The due date is the date on which a payment is scheduled to be received - YYYY-MM-DD.
         */
        public Builder dueDate(JsonNullable<LocalDate> dueDate) {
            Utils.checkNotNull(dueDate, "dueDate");
            this.dueDate = dueDate;
            return this;
        }


        /**
         * Payment method used for the transaction, such as cash, credit card, bank transfer, or check
         */
        public Builder paymentMethod(String paymentMethod) {
            Utils.checkNotNull(paymentMethod, "paymentMethod");
            this.paymentMethod = JsonNullable.of(paymentMethod);
            return this;
        }

        /**
         * Payment method used for the transaction, such as cash, credit card, bank transfer, or check
         */
        public Builder paymentMethod(JsonNullable<String> paymentMethod) {
            Utils.checkNotNull(paymentMethod, "paymentMethod");
            this.paymentMethod = paymentMethod;
            return this;
        }


        /**
         * Type of amortization
         */
        public Builder amortizationType(AmortizationType amortizationType) {
            Utils.checkNotNull(amortizationType, "amortizationType");
            this.amortizationType = JsonNullable.of(amortizationType);
            return this;
        }

        /**
         * Type of amortization
         */
        public Builder amortizationType(JsonNullable<? extends AmortizationType> amortizationType) {
            Utils.checkNotNull(amortizationType, "amortizationType");
            this.amortizationType = amortizationType;
            return this;
        }


        /**
         * Applicable tax id/code override if tax is not supplied on a line item basis.
         */
        public Builder taxCode(String taxCode) {
            Utils.checkNotNull(taxCode, "taxCode");
            this.taxCode = JsonNullable.of(taxCode);
            return this;
        }

        /**
         * Applicable tax id/code override if tax is not supplied on a line item basis.
         */
        public Builder taxCode(JsonNullable<String> taxCode) {
            Utils.checkNotNull(taxCode, "taxCode");
            this.taxCode = taxCode;
            return this;
        }


        /**
         * The channel through which the transaction is processed.
         */
        public Builder channel(String channel) {
            Utils.checkNotNull(channel, "channel");
            this.channel = JsonNullable.of(channel);
            return this;
        }

        /**
         * The channel through which the transaction is processed.
         */
        public Builder channel(JsonNullable<String> channel) {
            Utils.checkNotNull(channel, "channel");
            this.channel = channel;
            return this;
        }


        /**
         * Message for the supplier. This text appears on the Purchase Order.
         */
        public Builder memo(String memo) {
            Utils.checkNotNull(memo, "memo");
            this.memo = JsonNullable.of(memo);
            return this;
        }

        /**
         * Message for the supplier. This text appears on the Purchase Order.
         */
        public Builder memo(JsonNullable<String> memo) {
            Utils.checkNotNull(memo, "memo");
            this.memo = memo;
            return this;
        }


        /**
         * Internal notes for the purchase order.
         */
        public Builder notes(String notes) {
            Utils.checkNotNull(notes, "notes");
            this.notes = JsonNullable.of(notes);
            return this;
        }

        /**
         * Internal notes for the purchase order.
         */
        public Builder notes(JsonNullable<String> notes) {
            Utils.checkNotNull(notes, "notes");
            this.notes = notes;
            return this;
        }


        /**
         * A list of linked tracking categories.
         */
        public Builder trackingCategories(List<LinkedTrackingCategory> trackingCategories) {
            Utils.checkNotNull(trackingCategories, "trackingCategories");
            this.trackingCategories = JsonNullable.of(trackingCategories);
            return this;
        }

        /**
         * A list of linked tracking categories.
         */
        public Builder trackingCategories(JsonNullable<? extends List<LinkedTrackingCategory>> trackingCategories) {
            Utils.checkNotNull(trackingCategories, "trackingCategories");
            this.trackingCategories = trackingCategories;
            return this;
        }


        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(Map<String, Object> customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = JsonNullable.of(customMappings);
            return this;
        }

        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(JsonNullable<? extends Map<String, Object>> customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = customMappings;
            return this;
        }


        public Builder customFields(List<CustomField> customFields) {
            Utils.checkNotNull(customFields, "customFields");
            this.customFields = Optional.ofNullable(customFields);
            return this;
        }

        public Builder customFields(Optional<? extends List<CustomField>> customFields) {
            Utils.checkNotNull(customFields, "customFields");
            this.customFields = customFields;
            return this;
        }


        /**
         * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
         */
        public Builder rowVersion(String rowVersion) {
            Utils.checkNotNull(rowVersion, "rowVersion");
            this.rowVersion = JsonNullable.of(rowVersion);
            return this;
        }

        /**
         * A binary value used to detect updates to a object and prevent data conflicts. It is incremented each time an update is made to the object.
         */
        public Builder rowVersion(JsonNullable<String> rowVersion) {
            Utils.checkNotNull(rowVersion, "rowVersion");
            this.rowVersion = rowVersion;
            return this;
        }


        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(String updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = JsonNullable.of(updatedBy);
            return this;
        }

        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(JsonNullable<String> updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = updatedBy;
            return this;
        }


        /**
         * The user who created the object.
         */
        public Builder createdBy(String createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = JsonNullable.of(createdBy);
            return this;
        }

        /**
         * The user who created the object.
         */
        public Builder createdBy(JsonNullable<String> createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = createdBy;
            return this;
        }


        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(OffsetDateTime updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = JsonNullable.of(updatedAt);
            return this;
        }

        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(JsonNullable<OffsetDateTime> updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = updatedAt;
            return this;
        }


        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(OffsetDateTime createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = JsonNullable.of(createdAt);
            return this;
        }

        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(JsonNullable<OffsetDateTime> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }


        /**
         * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
         */
        public Builder passThrough(List<PassThroughBody> passThrough) {
            Utils.checkNotNull(passThrough, "passThrough");
            this.passThrough = Optional.ofNullable(passThrough);
            return this;
        }

        /**
         * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
         */
        public Builder passThrough(Optional<? extends List<PassThroughBody>> passThrough) {
            Utils.checkNotNull(passThrough, "passThrough");
            this.passThrough = passThrough;
            return this;
        }

        public PurchaseOrder build() {

            return new PurchaseOrder(
                id, downstreamId, poNumber,
                reference, supplier, subsidiaryId,
                companyId, status, issuedDate,
                deliveryDate, expectedArrivalDate, currency,
                currencyRate, subTotal, totalTax,
                total, taxInclusive, lineItems,
                shippingAddress, ledgerAccount, templateId,
                discountPercentage, bankAccount, accountingByRow,
                dueDate, paymentMethod, amortizationType,
                taxCode, channel, memo,
                notes, trackingCategories, customMappings,
                customFields, rowVersion, updatedBy,
                createdBy, updatedAt, createdAt,
                passThrough);
        }

    }
}
