/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.apideck.unify.models.components;

import com.apideck.unify.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;

public class UnifiedFile {

    /**
     * A unique identifier for an object.
     */
    @JsonProperty("id")
    private String id;

    /**
     * The third-party API ID of original entity
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("downstream_id")
    private JsonNullable<String> downstreamId;

    /**
     * The name of the file
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("name")
    private Optional<String> name;

    /**
     * Optional description of the file
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("description")
    private JsonNullable<String> description;

    /**
     * The type of resource. Could be file, folder or url
     */
    @JsonInclude(Include.ALWAYS)
    @JsonProperty("type")
    private Optional<? extends FileType> type;

    /**
     * The full path of the file or folder (includes the file name)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("path")
    private JsonNullable<String> path;

    /**
     * The MIME type of the file.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("mime_type")
    private JsonNullable<String> mimeType;

    /**
     * Whether the current user can download this file
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("downloadable")
    private Optional<Boolean> downloadable;

    /**
     * The size of the file in bytes
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("size")
    private JsonNullable<Long> size;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("owner")
    private Optional<? extends Owner> owner;

    /**
     * The parent folders of the file, starting from the root
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parent_folders")
    private Optional<? extends List<LinkedFolder>> parentFolders;

    /**
     * Whether the list of parent folders is complete. Some connectors only return the direct parent of a file
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parent_folders_complete")
    private Optional<Boolean> parentFoldersComplete;

    /**
     * Permissions the current user has on this file.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("permissions")
    private Optional<? extends Permissions> permissions;

    /**
     * Whether the current file is exportable to other file formats. This property is relevant for proprietary file formats such as Google Docs or Dropbox Paper.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("exportable")
    private Optional<Boolean> exportable;

    /**
     * The available file formats when exporting this file.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("export_formats")
    private JsonNullable<? extends List<String>> exportFormats;

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("custom_mappings")
    private JsonNullable<? extends CustomMappings> customMappings;

    /**
     * The user who last updated the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_by")
    private JsonNullable<String> updatedBy;

    /**
     * The user who created the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_by")
    private JsonNullable<String> createdBy;

    /**
     * The date and time when the object was last updated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updated_at")
    private JsonNullable<OffsetDateTime> updatedAt;

    /**
     * The date and time when the object was created.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("created_at")
    private JsonNullable<OffsetDateTime> createdAt;

    @JsonCreator
    public UnifiedFile(
            @JsonProperty("id") String id,
            @JsonProperty("downstream_id") JsonNullable<String> downstreamId,
            @JsonProperty("name") Optional<String> name,
            @JsonProperty("description") JsonNullable<String> description,
            @JsonProperty("type") Optional<? extends FileType> type,
            @JsonProperty("path") JsonNullable<String> path,
            @JsonProperty("mime_type") JsonNullable<String> mimeType,
            @JsonProperty("downloadable") Optional<Boolean> downloadable,
            @JsonProperty("size") JsonNullable<Long> size,
            @JsonProperty("owner") Optional<? extends Owner> owner,
            @JsonProperty("parent_folders") Optional<? extends List<LinkedFolder>> parentFolders,
            @JsonProperty("parent_folders_complete") Optional<Boolean> parentFoldersComplete,
            @JsonProperty("permissions") Optional<? extends Permissions> permissions,
            @JsonProperty("exportable") Optional<Boolean> exportable,
            @JsonProperty("export_formats") JsonNullable<? extends List<String>> exportFormats,
            @JsonProperty("custom_mappings") JsonNullable<? extends CustomMappings> customMappings,
            @JsonProperty("updated_by") JsonNullable<String> updatedBy,
            @JsonProperty("created_by") JsonNullable<String> createdBy,
            @JsonProperty("updated_at") JsonNullable<OffsetDateTime> updatedAt,
            @JsonProperty("created_at") JsonNullable<OffsetDateTime> createdAt) {
        Utils.checkNotNull(id, "id");
        Utils.checkNotNull(downstreamId, "downstreamId");
        Utils.checkNotNull(name, "name");
        Utils.checkNotNull(description, "description");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(path, "path");
        Utils.checkNotNull(mimeType, "mimeType");
        Utils.checkNotNull(downloadable, "downloadable");
        Utils.checkNotNull(size, "size");
        Utils.checkNotNull(owner, "owner");
        Utils.checkNotNull(parentFolders, "parentFolders");
        Utils.checkNotNull(parentFoldersComplete, "parentFoldersComplete");
        Utils.checkNotNull(permissions, "permissions");
        Utils.checkNotNull(exportable, "exportable");
        Utils.checkNotNull(exportFormats, "exportFormats");
        Utils.checkNotNull(customMappings, "customMappings");
        Utils.checkNotNull(updatedBy, "updatedBy");
        Utils.checkNotNull(createdBy, "createdBy");
        Utils.checkNotNull(updatedAt, "updatedAt");
        Utils.checkNotNull(createdAt, "createdAt");
        this.id = id;
        this.downstreamId = downstreamId;
        this.name = name;
        this.description = description;
        this.type = type;
        this.path = path;
        this.mimeType = mimeType;
        this.downloadable = downloadable;
        this.size = size;
        this.owner = owner;
        this.parentFolders = parentFolders;
        this.parentFoldersComplete = parentFoldersComplete;
        this.permissions = permissions;
        this.exportable = exportable;
        this.exportFormats = exportFormats;
        this.customMappings = customMappings;
        this.updatedBy = updatedBy;
        this.createdBy = createdBy;
        this.updatedAt = updatedAt;
        this.createdAt = createdAt;
    }
    
    public UnifiedFile(
            String id) {
        this(id, JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), Optional.empty(), JsonNullable.undefined(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined(), JsonNullable.undefined());
    }

    /**
     * A unique identifier for an object.
     */
    @JsonIgnore
    public String id() {
        return id;
    }

    /**
     * The third-party API ID of original entity
     */
    @JsonIgnore
    public JsonNullable<String> downstreamId() {
        return downstreamId;
    }

    /**
     * The name of the file
     */
    @JsonIgnore
    public Optional<String> name() {
        return name;
    }

    /**
     * Optional description of the file
     */
    @JsonIgnore
    public JsonNullable<String> description() {
        return description;
    }

    /**
     * The type of resource. Could be file, folder or url
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<FileType> type() {
        return (Optional<FileType>) type;
    }

    /**
     * The full path of the file or folder (includes the file name)
     */
    @JsonIgnore
    public JsonNullable<String> path() {
        return path;
    }

    /**
     * The MIME type of the file.
     */
    @JsonIgnore
    public JsonNullable<String> mimeType() {
        return mimeType;
    }

    /**
     * Whether the current user can download this file
     */
    @JsonIgnore
    public Optional<Boolean> downloadable() {
        return downloadable;
    }

    /**
     * The size of the file in bytes
     */
    @JsonIgnore
    public JsonNullable<Long> size() {
        return size;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Owner> owner() {
        return (Optional<Owner>) owner;
    }

    /**
     * The parent folders of the file, starting from the root
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<List<LinkedFolder>> parentFolders() {
        return (Optional<List<LinkedFolder>>) parentFolders;
    }

    /**
     * Whether the list of parent folders is complete. Some connectors only return the direct parent of a file
     */
    @JsonIgnore
    public Optional<Boolean> parentFoldersComplete() {
        return parentFoldersComplete;
    }

    /**
     * Permissions the current user has on this file.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Permissions> permissions() {
        return (Optional<Permissions>) permissions;
    }

    /**
     * Whether the current file is exportable to other file formats. This property is relevant for proprietary file formats such as Google Docs or Dropbox Paper.
     */
    @JsonIgnore
    public Optional<Boolean> exportable() {
        return exportable;
    }

    /**
     * The available file formats when exporting this file.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<List<String>> exportFormats() {
        return (JsonNullable<List<String>>) exportFormats;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public JsonNullable<CustomMappings> customMappings() {
        return (JsonNullable<CustomMappings>) customMappings;
    }

    /**
     * The user who last updated the object.
     */
    @JsonIgnore
    public JsonNullable<String> updatedBy() {
        return updatedBy;
    }

    /**
     * The user who created the object.
     */
    @JsonIgnore
    public JsonNullable<String> createdBy() {
        return createdBy;
    }

    /**
     * The date and time when the object was last updated.
     */
    @JsonIgnore
    public JsonNullable<OffsetDateTime> updatedAt() {
        return updatedAt;
    }

    /**
     * The date and time when the object was created.
     */
    @JsonIgnore
    public JsonNullable<OffsetDateTime> createdAt() {
        return createdAt;
    }

    public final static Builder builder() {
        return new Builder();
    }    

    /**
     * A unique identifier for an object.
     */
    public UnifiedFile withId(String id) {
        Utils.checkNotNull(id, "id");
        this.id = id;
        return this;
    }

    /**
     * The third-party API ID of original entity
     */
    public UnifiedFile withDownstreamId(String downstreamId) {
        Utils.checkNotNull(downstreamId, "downstreamId");
        this.downstreamId = JsonNullable.of(downstreamId);
        return this;
    }

    /**
     * The third-party API ID of original entity
     */
    public UnifiedFile withDownstreamId(JsonNullable<String> downstreamId) {
        Utils.checkNotNull(downstreamId, "downstreamId");
        this.downstreamId = downstreamId;
        return this;
    }

    /**
     * The name of the file
     */
    public UnifiedFile withName(String name) {
        Utils.checkNotNull(name, "name");
        this.name = Optional.ofNullable(name);
        return this;
    }

    /**
     * The name of the file
     */
    public UnifiedFile withName(Optional<String> name) {
        Utils.checkNotNull(name, "name");
        this.name = name;
        return this;
    }

    /**
     * Optional description of the file
     */
    public UnifiedFile withDescription(String description) {
        Utils.checkNotNull(description, "description");
        this.description = JsonNullable.of(description);
        return this;
    }

    /**
     * Optional description of the file
     */
    public UnifiedFile withDescription(JsonNullable<String> description) {
        Utils.checkNotNull(description, "description");
        this.description = description;
        return this;
    }

    /**
     * The type of resource. Could be file, folder or url
     */
    public UnifiedFile withType(FileType type) {
        Utils.checkNotNull(type, "type");
        this.type = Optional.ofNullable(type);
        return this;
    }

    /**
     * The type of resource. Could be file, folder or url
     */
    public UnifiedFile withType(Optional<? extends FileType> type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    /**
     * The full path of the file or folder (includes the file name)
     */
    public UnifiedFile withPath(String path) {
        Utils.checkNotNull(path, "path");
        this.path = JsonNullable.of(path);
        return this;
    }

    /**
     * The full path of the file or folder (includes the file name)
     */
    public UnifiedFile withPath(JsonNullable<String> path) {
        Utils.checkNotNull(path, "path");
        this.path = path;
        return this;
    }

    /**
     * The MIME type of the file.
     */
    public UnifiedFile withMimeType(String mimeType) {
        Utils.checkNotNull(mimeType, "mimeType");
        this.mimeType = JsonNullable.of(mimeType);
        return this;
    }

    /**
     * The MIME type of the file.
     */
    public UnifiedFile withMimeType(JsonNullable<String> mimeType) {
        Utils.checkNotNull(mimeType, "mimeType");
        this.mimeType = mimeType;
        return this;
    }

    /**
     * Whether the current user can download this file
     */
    public UnifiedFile withDownloadable(boolean downloadable) {
        Utils.checkNotNull(downloadable, "downloadable");
        this.downloadable = Optional.ofNullable(downloadable);
        return this;
    }

    /**
     * Whether the current user can download this file
     */
    public UnifiedFile withDownloadable(Optional<Boolean> downloadable) {
        Utils.checkNotNull(downloadable, "downloadable");
        this.downloadable = downloadable;
        return this;
    }

    /**
     * The size of the file in bytes
     */
    public UnifiedFile withSize(long size) {
        Utils.checkNotNull(size, "size");
        this.size = JsonNullable.of(size);
        return this;
    }

    /**
     * The size of the file in bytes
     */
    public UnifiedFile withSize(JsonNullable<Long> size) {
        Utils.checkNotNull(size, "size");
        this.size = size;
        return this;
    }

    public UnifiedFile withOwner(Owner owner) {
        Utils.checkNotNull(owner, "owner");
        this.owner = Optional.ofNullable(owner);
        return this;
    }

    public UnifiedFile withOwner(Optional<? extends Owner> owner) {
        Utils.checkNotNull(owner, "owner");
        this.owner = owner;
        return this;
    }

    /**
     * The parent folders of the file, starting from the root
     */
    public UnifiedFile withParentFolders(List<LinkedFolder> parentFolders) {
        Utils.checkNotNull(parentFolders, "parentFolders");
        this.parentFolders = Optional.ofNullable(parentFolders);
        return this;
    }

    /**
     * The parent folders of the file, starting from the root
     */
    public UnifiedFile withParentFolders(Optional<? extends List<LinkedFolder>> parentFolders) {
        Utils.checkNotNull(parentFolders, "parentFolders");
        this.parentFolders = parentFolders;
        return this;
    }

    /**
     * Whether the list of parent folders is complete. Some connectors only return the direct parent of a file
     */
    public UnifiedFile withParentFoldersComplete(boolean parentFoldersComplete) {
        Utils.checkNotNull(parentFoldersComplete, "parentFoldersComplete");
        this.parentFoldersComplete = Optional.ofNullable(parentFoldersComplete);
        return this;
    }

    /**
     * Whether the list of parent folders is complete. Some connectors only return the direct parent of a file
     */
    public UnifiedFile withParentFoldersComplete(Optional<Boolean> parentFoldersComplete) {
        Utils.checkNotNull(parentFoldersComplete, "parentFoldersComplete");
        this.parentFoldersComplete = parentFoldersComplete;
        return this;
    }

    /**
     * Permissions the current user has on this file.
     */
    public UnifiedFile withPermissions(Permissions permissions) {
        Utils.checkNotNull(permissions, "permissions");
        this.permissions = Optional.ofNullable(permissions);
        return this;
    }

    /**
     * Permissions the current user has on this file.
     */
    public UnifiedFile withPermissions(Optional<? extends Permissions> permissions) {
        Utils.checkNotNull(permissions, "permissions");
        this.permissions = permissions;
        return this;
    }

    /**
     * Whether the current file is exportable to other file formats. This property is relevant for proprietary file formats such as Google Docs or Dropbox Paper.
     */
    public UnifiedFile withExportable(boolean exportable) {
        Utils.checkNotNull(exportable, "exportable");
        this.exportable = Optional.ofNullable(exportable);
        return this;
    }

    /**
     * Whether the current file is exportable to other file formats. This property is relevant for proprietary file formats such as Google Docs or Dropbox Paper.
     */
    public UnifiedFile withExportable(Optional<Boolean> exportable) {
        Utils.checkNotNull(exportable, "exportable");
        this.exportable = exportable;
        return this;
    }

    /**
     * The available file formats when exporting this file.
     */
    public UnifiedFile withExportFormats(List<String> exportFormats) {
        Utils.checkNotNull(exportFormats, "exportFormats");
        this.exportFormats = JsonNullable.of(exportFormats);
        return this;
    }

    /**
     * The available file formats when exporting this file.
     */
    public UnifiedFile withExportFormats(JsonNullable<? extends List<String>> exportFormats) {
        Utils.checkNotNull(exportFormats, "exportFormats");
        this.exportFormats = exportFormats;
        return this;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public UnifiedFile withCustomMappings(CustomMappings customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = JsonNullable.of(customMappings);
        return this;
    }

    /**
     * When custom mappings are configured on the resource, the result is included here.
     */
    public UnifiedFile withCustomMappings(JsonNullable<? extends CustomMappings> customMappings) {
        Utils.checkNotNull(customMappings, "customMappings");
        this.customMappings = customMappings;
        return this;
    }

    /**
     * The user who last updated the object.
     */
    public UnifiedFile withUpdatedBy(String updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = JsonNullable.of(updatedBy);
        return this;
    }

    /**
     * The user who last updated the object.
     */
    public UnifiedFile withUpdatedBy(JsonNullable<String> updatedBy) {
        Utils.checkNotNull(updatedBy, "updatedBy");
        this.updatedBy = updatedBy;
        return this;
    }

    /**
     * The user who created the object.
     */
    public UnifiedFile withCreatedBy(String createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = JsonNullable.of(createdBy);
        return this;
    }

    /**
     * The user who created the object.
     */
    public UnifiedFile withCreatedBy(JsonNullable<String> createdBy) {
        Utils.checkNotNull(createdBy, "createdBy");
        this.createdBy = createdBy;
        return this;
    }

    /**
     * The date and time when the object was last updated.
     */
    public UnifiedFile withUpdatedAt(OffsetDateTime updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = JsonNullable.of(updatedAt);
        return this;
    }

    /**
     * The date and time when the object was last updated.
     */
    public UnifiedFile withUpdatedAt(JsonNullable<OffsetDateTime> updatedAt) {
        Utils.checkNotNull(updatedAt, "updatedAt");
        this.updatedAt = updatedAt;
        return this;
    }

    /**
     * The date and time when the object was created.
     */
    public UnifiedFile withCreatedAt(OffsetDateTime createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = JsonNullable.of(createdAt);
        return this;
    }

    /**
     * The date and time when the object was created.
     */
    public UnifiedFile withCreatedAt(JsonNullable<OffsetDateTime> createdAt) {
        Utils.checkNotNull(createdAt, "createdAt");
        this.createdAt = createdAt;
        return this;
    }

    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        UnifiedFile other = (UnifiedFile) o;
        return 
            Objects.deepEquals(this.id, other.id) &&
            Objects.deepEquals(this.downstreamId, other.downstreamId) &&
            Objects.deepEquals(this.name, other.name) &&
            Objects.deepEquals(this.description, other.description) &&
            Objects.deepEquals(this.type, other.type) &&
            Objects.deepEquals(this.path, other.path) &&
            Objects.deepEquals(this.mimeType, other.mimeType) &&
            Objects.deepEquals(this.downloadable, other.downloadable) &&
            Objects.deepEquals(this.size, other.size) &&
            Objects.deepEquals(this.owner, other.owner) &&
            Objects.deepEquals(this.parentFolders, other.parentFolders) &&
            Objects.deepEquals(this.parentFoldersComplete, other.parentFoldersComplete) &&
            Objects.deepEquals(this.permissions, other.permissions) &&
            Objects.deepEquals(this.exportable, other.exportable) &&
            Objects.deepEquals(this.exportFormats, other.exportFormats) &&
            Objects.deepEquals(this.customMappings, other.customMappings) &&
            Objects.deepEquals(this.updatedBy, other.updatedBy) &&
            Objects.deepEquals(this.createdBy, other.createdBy) &&
            Objects.deepEquals(this.updatedAt, other.updatedAt) &&
            Objects.deepEquals(this.createdAt, other.createdAt);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(
            id,
            downstreamId,
            name,
            description,
            type,
            path,
            mimeType,
            downloadable,
            size,
            owner,
            parentFolders,
            parentFoldersComplete,
            permissions,
            exportable,
            exportFormats,
            customMappings,
            updatedBy,
            createdBy,
            updatedAt,
            createdAt);
    }
    
    @Override
    public String toString() {
        return Utils.toString(UnifiedFile.class,
                "id", id,
                "downstreamId", downstreamId,
                "name", name,
                "description", description,
                "type", type,
                "path", path,
                "mimeType", mimeType,
                "downloadable", downloadable,
                "size", size,
                "owner", owner,
                "parentFolders", parentFolders,
                "parentFoldersComplete", parentFoldersComplete,
                "permissions", permissions,
                "exportable", exportable,
                "exportFormats", exportFormats,
                "customMappings", customMappings,
                "updatedBy", updatedBy,
                "createdBy", createdBy,
                "updatedAt", updatedAt,
                "createdAt", createdAt);
    }
    
    public final static class Builder {
 
        private String id;
 
        private JsonNullable<String> downstreamId = JsonNullable.undefined();
 
        private Optional<String> name = Optional.empty();
 
        private JsonNullable<String> description = JsonNullable.undefined();
 
        private Optional<? extends FileType> type = Optional.empty();
 
        private JsonNullable<String> path = JsonNullable.undefined();
 
        private JsonNullable<String> mimeType = JsonNullable.undefined();
 
        private Optional<Boolean> downloadable = Optional.empty();
 
        private JsonNullable<Long> size = JsonNullable.undefined();
 
        private Optional<? extends Owner> owner = Optional.empty();
 
        private Optional<? extends List<LinkedFolder>> parentFolders = Optional.empty();
 
        private Optional<Boolean> parentFoldersComplete = Optional.empty();
 
        private Optional<? extends Permissions> permissions = Optional.empty();
 
        private Optional<Boolean> exportable = Optional.empty();
 
        private JsonNullable<? extends List<String>> exportFormats = JsonNullable.undefined();
 
        private JsonNullable<? extends CustomMappings> customMappings = JsonNullable.undefined();
 
        private JsonNullable<String> updatedBy = JsonNullable.undefined();
 
        private JsonNullable<String> createdBy = JsonNullable.undefined();
 
        private JsonNullable<OffsetDateTime> updatedAt = JsonNullable.undefined();
 
        private JsonNullable<OffsetDateTime> createdAt = JsonNullable.undefined();
        
        private Builder() {
          // force use of static builder() method
        }

        /**
         * A unique identifier for an object.
         */
        public Builder id(String id) {
            Utils.checkNotNull(id, "id");
            this.id = id;
            return this;
        }

        /**
         * The third-party API ID of original entity
         */
        public Builder downstreamId(String downstreamId) {
            Utils.checkNotNull(downstreamId, "downstreamId");
            this.downstreamId = JsonNullable.of(downstreamId);
            return this;
        }

        /**
         * The third-party API ID of original entity
         */
        public Builder downstreamId(JsonNullable<String> downstreamId) {
            Utils.checkNotNull(downstreamId, "downstreamId");
            this.downstreamId = downstreamId;
            return this;
        }

        /**
         * The name of the file
         */
        public Builder name(String name) {
            Utils.checkNotNull(name, "name");
            this.name = Optional.ofNullable(name);
            return this;
        }

        /**
         * The name of the file
         */
        public Builder name(Optional<String> name) {
            Utils.checkNotNull(name, "name");
            this.name = name;
            return this;
        }

        /**
         * Optional description of the file
         */
        public Builder description(String description) {
            Utils.checkNotNull(description, "description");
            this.description = JsonNullable.of(description);
            return this;
        }

        /**
         * Optional description of the file
         */
        public Builder description(JsonNullable<String> description) {
            Utils.checkNotNull(description, "description");
            this.description = description;
            return this;
        }

        /**
         * The type of resource. Could be file, folder or url
         */
        public Builder type(FileType type) {
            Utils.checkNotNull(type, "type");
            this.type = Optional.ofNullable(type);
            return this;
        }

        /**
         * The type of resource. Could be file, folder or url
         */
        public Builder type(Optional<? extends FileType> type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }

        /**
         * The full path of the file or folder (includes the file name)
         */
        public Builder path(String path) {
            Utils.checkNotNull(path, "path");
            this.path = JsonNullable.of(path);
            return this;
        }

        /**
         * The full path of the file or folder (includes the file name)
         */
        public Builder path(JsonNullable<String> path) {
            Utils.checkNotNull(path, "path");
            this.path = path;
            return this;
        }

        /**
         * The MIME type of the file.
         */
        public Builder mimeType(String mimeType) {
            Utils.checkNotNull(mimeType, "mimeType");
            this.mimeType = JsonNullable.of(mimeType);
            return this;
        }

        /**
         * The MIME type of the file.
         */
        public Builder mimeType(JsonNullable<String> mimeType) {
            Utils.checkNotNull(mimeType, "mimeType");
            this.mimeType = mimeType;
            return this;
        }

        /**
         * Whether the current user can download this file
         */
        public Builder downloadable(boolean downloadable) {
            Utils.checkNotNull(downloadable, "downloadable");
            this.downloadable = Optional.ofNullable(downloadable);
            return this;
        }

        /**
         * Whether the current user can download this file
         */
        public Builder downloadable(Optional<Boolean> downloadable) {
            Utils.checkNotNull(downloadable, "downloadable");
            this.downloadable = downloadable;
            return this;
        }

        /**
         * The size of the file in bytes
         */
        public Builder size(long size) {
            Utils.checkNotNull(size, "size");
            this.size = JsonNullable.of(size);
            return this;
        }

        /**
         * The size of the file in bytes
         */
        public Builder size(JsonNullable<Long> size) {
            Utils.checkNotNull(size, "size");
            this.size = size;
            return this;
        }

        public Builder owner(Owner owner) {
            Utils.checkNotNull(owner, "owner");
            this.owner = Optional.ofNullable(owner);
            return this;
        }

        public Builder owner(Optional<? extends Owner> owner) {
            Utils.checkNotNull(owner, "owner");
            this.owner = owner;
            return this;
        }

        /**
         * The parent folders of the file, starting from the root
         */
        public Builder parentFolders(List<LinkedFolder> parentFolders) {
            Utils.checkNotNull(parentFolders, "parentFolders");
            this.parentFolders = Optional.ofNullable(parentFolders);
            return this;
        }

        /**
         * The parent folders of the file, starting from the root
         */
        public Builder parentFolders(Optional<? extends List<LinkedFolder>> parentFolders) {
            Utils.checkNotNull(parentFolders, "parentFolders");
            this.parentFolders = parentFolders;
            return this;
        }

        /**
         * Whether the list of parent folders is complete. Some connectors only return the direct parent of a file
         */
        public Builder parentFoldersComplete(boolean parentFoldersComplete) {
            Utils.checkNotNull(parentFoldersComplete, "parentFoldersComplete");
            this.parentFoldersComplete = Optional.ofNullable(parentFoldersComplete);
            return this;
        }

        /**
         * Whether the list of parent folders is complete. Some connectors only return the direct parent of a file
         */
        public Builder parentFoldersComplete(Optional<Boolean> parentFoldersComplete) {
            Utils.checkNotNull(parentFoldersComplete, "parentFoldersComplete");
            this.parentFoldersComplete = parentFoldersComplete;
            return this;
        }

        /**
         * Permissions the current user has on this file.
         */
        public Builder permissions(Permissions permissions) {
            Utils.checkNotNull(permissions, "permissions");
            this.permissions = Optional.ofNullable(permissions);
            return this;
        }

        /**
         * Permissions the current user has on this file.
         */
        public Builder permissions(Optional<? extends Permissions> permissions) {
            Utils.checkNotNull(permissions, "permissions");
            this.permissions = permissions;
            return this;
        }

        /**
         * Whether the current file is exportable to other file formats. This property is relevant for proprietary file formats such as Google Docs or Dropbox Paper.
         */
        public Builder exportable(boolean exportable) {
            Utils.checkNotNull(exportable, "exportable");
            this.exportable = Optional.ofNullable(exportable);
            return this;
        }

        /**
         * Whether the current file is exportable to other file formats. This property is relevant for proprietary file formats such as Google Docs or Dropbox Paper.
         */
        public Builder exportable(Optional<Boolean> exportable) {
            Utils.checkNotNull(exportable, "exportable");
            this.exportable = exportable;
            return this;
        }

        /**
         * The available file formats when exporting this file.
         */
        public Builder exportFormats(List<String> exportFormats) {
            Utils.checkNotNull(exportFormats, "exportFormats");
            this.exportFormats = JsonNullable.of(exportFormats);
            return this;
        }

        /**
         * The available file formats when exporting this file.
         */
        public Builder exportFormats(JsonNullable<? extends List<String>> exportFormats) {
            Utils.checkNotNull(exportFormats, "exportFormats");
            this.exportFormats = exportFormats;
            return this;
        }

        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(CustomMappings customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = JsonNullable.of(customMappings);
            return this;
        }

        /**
         * When custom mappings are configured on the resource, the result is included here.
         */
        public Builder customMappings(JsonNullable<? extends CustomMappings> customMappings) {
            Utils.checkNotNull(customMappings, "customMappings");
            this.customMappings = customMappings;
            return this;
        }

        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(String updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = JsonNullable.of(updatedBy);
            return this;
        }

        /**
         * The user who last updated the object.
         */
        public Builder updatedBy(JsonNullable<String> updatedBy) {
            Utils.checkNotNull(updatedBy, "updatedBy");
            this.updatedBy = updatedBy;
            return this;
        }

        /**
         * The user who created the object.
         */
        public Builder createdBy(String createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = JsonNullable.of(createdBy);
            return this;
        }

        /**
         * The user who created the object.
         */
        public Builder createdBy(JsonNullable<String> createdBy) {
            Utils.checkNotNull(createdBy, "createdBy");
            this.createdBy = createdBy;
            return this;
        }

        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(OffsetDateTime updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = JsonNullable.of(updatedAt);
            return this;
        }

        /**
         * The date and time when the object was last updated.
         */
        public Builder updatedAt(JsonNullable<OffsetDateTime> updatedAt) {
            Utils.checkNotNull(updatedAt, "updatedAt");
            this.updatedAt = updatedAt;
            return this;
        }

        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(OffsetDateTime createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = JsonNullable.of(createdAt);
            return this;
        }

        /**
         * The date and time when the object was created.
         */
        public Builder createdAt(JsonNullable<OffsetDateTime> createdAt) {
            Utils.checkNotNull(createdAt, "createdAt");
            this.createdAt = createdAt;
            return this;
        }
        
        public UnifiedFile build() {
            return new UnifiedFile(
                id,
                downstreamId,
                name,
                description,
                type,
                path,
                mimeType,
                downloadable,
                size,
                owner,
                parentFolders,
                parentFoldersComplete,
                permissions,
                exportable,
                exportFormats,
                customMappings,
                updatedBy,
                createdBy,
                updatedAt,
                createdAt);
        }
    }
}
