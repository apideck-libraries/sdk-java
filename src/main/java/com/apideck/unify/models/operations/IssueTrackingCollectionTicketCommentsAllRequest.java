/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package com.apideck.unify.models.operations;

import com.apideck.unify.models.components.CommentsSort;
import com.apideck.unify.utils.LazySingletonValue;
import com.apideck.unify.utils.SpeakeasyMetadata;
import com.apideck.unify.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.core.type.TypeReference;
import jakarta.annotation.Nonnull;
import jakarta.annotation.Nullable;
import java.lang.Boolean;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.util.Map;
import java.util.Optional;
import org.openapitools.jackson.nullable.JsonNullable;


public class IssueTrackingCollectionTicketCommentsAllRequest {
    /**
     * Include raw response. Mostly used for debugging purposes
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=raw")
    private Boolean raw;

    /**
     * ID of the consumer which you want to get or push data from
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=x-apideck-consumer-id")
    private String consumerId;

    /**
     * The ID of your Unify application
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=x-apideck-app-id")
    private String appId;

    /**
     * Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API.
     */
    @SpeakeasyMetadata("header:style=simple,explode=false,name=x-apideck-service-id")
    private String serviceId;

    /**
     * Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=cursor")
    private JsonNullable<String> cursor;

    /**
     * Number of results to return. Minimum 1, Maximum 200, Default 20
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=limit")
    private Long limit;

    /**
     * The collection ID
     */
    @SpeakeasyMetadata("pathParam:style=simple,explode=false,name=collection_id")
    private String collectionId;

    /**
     * ID of the ticket you are acting upon.
     */
    @SpeakeasyMetadata("pathParam:style=simple,explode=false,name=ticket_id")
    private String ticketId;

    /**
     * Apply sorting
     */
    @SpeakeasyMetadata("queryParam:style=deepObject,explode=true,name=sort")
    private CommentsSort sort;

    /**
     * Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]=leads becomes ?search=leads
     */
    @SpeakeasyMetadata("queryParam:style=deepObject,explode=true,name=pass_through")
    private Map<String, Object> passThrough;

    /**
     * The 'fields' parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: `fields=name,email,addresses.city`&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields "name", "email" and "addresses.city". If any other fields are available, they will be excluded.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=fields")
    private JsonNullable<String> fields;

    @JsonCreator
    public IssueTrackingCollectionTicketCommentsAllRequest(
            @Nullable Boolean raw,
            @Nullable String consumerId,
            @Nullable String appId,
            @Nullable String serviceId,
            @Nullable JsonNullable<String> cursor,
            @Nullable Long limit,
            @Nonnull String collectionId,
            @Nonnull String ticketId,
            @Nullable CommentsSort sort,
            @Nullable Map<String, Object> passThrough,
            @Nullable JsonNullable<String> fields) {
        this.raw = Optional.ofNullable(raw)
            .orElse(Builder._SINGLETON_VALUE_Raw.value());
        this.consumerId = consumerId;
        this.appId = appId;
        this.serviceId = serviceId;
        this.cursor = Optional.ofNullable(cursor)
            .orElse(JsonNullable.undefined());
        this.limit = Optional.ofNullable(limit)
            .orElse(Builder._SINGLETON_VALUE_Limit.value());
        this.collectionId = Optional.ofNullable(collectionId)
            .orElseThrow(() -> new IllegalArgumentException("collectionId cannot be null"));
        this.ticketId = Optional.ofNullable(ticketId)
            .orElseThrow(() -> new IllegalArgumentException("ticketId cannot be null"));
        this.sort = sort;
        this.passThrough = passThrough;
        this.fields = Optional.ofNullable(fields)
            .orElse(JsonNullable.undefined());
    }
    
    public IssueTrackingCollectionTicketCommentsAllRequest(
            @Nonnull String collectionId,
            @Nonnull String ticketId) {
        this(null, null, null,
            null, null, null,
            collectionId, ticketId, null,
            null, null);
    }

    /**
     * Include raw response. Mostly used for debugging purposes
     */
    public Optional<Boolean> raw() {
        return Optional.ofNullable(this.raw);
    }

    /**
     * ID of the consumer which you want to get or push data from
     */
    public Optional<String> consumerId() {
        return Optional.ofNullable(this.consumerId);
    }

    /**
     * The ID of your Unify application
     */
    public Optional<String> appId() {
        return Optional.ofNullable(this.appId);
    }

    /**
     * Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API.
     */
    public Optional<String> serviceId() {
        return Optional.ofNullable(this.serviceId);
    }

    /**
     * Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response.
     */
    public JsonNullable<String> cursor() {
        return this.cursor;
    }

    /**
     * Number of results to return. Minimum 1, Maximum 200, Default 20
     */
    public Optional<Long> limit() {
        return Optional.ofNullable(this.limit);
    }

    /**
     * The collection ID
     */
    public String collectionId() {
        return this.collectionId;
    }

    /**
     * ID of the ticket you are acting upon.
     */
    public String ticketId() {
        return this.ticketId;
    }

    /**
     * Apply sorting
     */
    public Optional<CommentsSort> sort() {
        return Optional.ofNullable(this.sort);
    }

    /**
     * Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]=leads becomes ?search=leads
     */
    public Optional<Map<String, Object>> passThrough() {
        return Optional.ofNullable(this.passThrough);
    }

    /**
     * The 'fields' parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: `fields=name,email,addresses.city`&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields "name", "email" and "addresses.city". If any other fields are available, they will be excluded.
     */
    public JsonNullable<String> fields() {
        return this.fields;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * Include raw response. Mostly used for debugging purposes
     */
    public IssueTrackingCollectionTicketCommentsAllRequest withRaw(@Nullable Boolean raw) {
        this.raw = raw;
        return this;
    }


    /**
     * ID of the consumer which you want to get or push data from
     */
    public IssueTrackingCollectionTicketCommentsAllRequest withConsumerId(@Nullable String consumerId) {
        this.consumerId = consumerId;
        return this;
    }


    /**
     * The ID of your Unify application
     */
    public IssueTrackingCollectionTicketCommentsAllRequest withAppId(@Nullable String appId) {
        this.appId = appId;
        return this;
    }


    /**
     * Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API.
     */
    public IssueTrackingCollectionTicketCommentsAllRequest withServiceId(@Nullable String serviceId) {
        this.serviceId = serviceId;
        return this;
    }


    /**
     * Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response.
     */
    public IssueTrackingCollectionTicketCommentsAllRequest withCursor(@Nullable String cursor) {
        this.cursor = JsonNullable.of(cursor);
        return this;
    }


    /**
     * Number of results to return. Minimum 1, Maximum 200, Default 20
     */
    public IssueTrackingCollectionTicketCommentsAllRequest withLimit(@Nullable Long limit) {
        this.limit = limit;
        return this;
    }


    /**
     * The collection ID
     */
    public IssueTrackingCollectionTicketCommentsAllRequest withCollectionId(@Nonnull String collectionId) {
        this.collectionId = Utils.checkNotNull(collectionId, "collectionId");
        return this;
    }


    /**
     * ID of the ticket you are acting upon.
     */
    public IssueTrackingCollectionTicketCommentsAllRequest withTicketId(@Nonnull String ticketId) {
        this.ticketId = Utils.checkNotNull(ticketId, "ticketId");
        return this;
    }


    /**
     * Apply sorting
     */
    public IssueTrackingCollectionTicketCommentsAllRequest withSort(@Nullable CommentsSort sort) {
        this.sort = sort;
        return this;
    }


    /**
     * Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]=leads becomes ?search=leads
     */
    public IssueTrackingCollectionTicketCommentsAllRequest withPassThrough(@Nullable Map<String, Object> passThrough) {
        this.passThrough = passThrough;
        return this;
    }


    /**
     * The 'fields' parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: `fields=name,email,addresses.city`&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields "name", "email" and "addresses.city". If any other fields are available, they will be excluded.
     */
    public IssueTrackingCollectionTicketCommentsAllRequest withFields(@Nullable String fields) {
        this.fields = JsonNullable.of(fields);
        return this;
    }


    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        IssueTrackingCollectionTicketCommentsAllRequest other = (IssueTrackingCollectionTicketCommentsAllRequest) o;
        return 
            Utils.enhancedDeepEquals(this.raw, other.raw) &&
            Utils.enhancedDeepEquals(this.consumerId, other.consumerId) &&
            Utils.enhancedDeepEquals(this.appId, other.appId) &&
            Utils.enhancedDeepEquals(this.serviceId, other.serviceId) &&
            Utils.enhancedDeepEquals(this.cursor, other.cursor) &&
            Utils.enhancedDeepEquals(this.limit, other.limit) &&
            Utils.enhancedDeepEquals(this.collectionId, other.collectionId) &&
            Utils.enhancedDeepEquals(this.ticketId, other.ticketId) &&
            Utils.enhancedDeepEquals(this.sort, other.sort) &&
            Utils.enhancedDeepEquals(this.passThrough, other.passThrough) &&
            Utils.enhancedDeepEquals(this.fields, other.fields);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            raw, consumerId, appId,
            serviceId, cursor, limit,
            collectionId, ticketId, sort,
            passThrough, fields);
    }
    
    @Override
    public String toString() {
        return Utils.toString(IssueTrackingCollectionTicketCommentsAllRequest.class,
                "raw", raw,
                "consumerId", consumerId,
                "appId", appId,
                "serviceId", serviceId,
                "cursor", cursor,
                "limit", limit,
                "collectionId", collectionId,
                "ticketId", ticketId,
                "sort", sort,
                "passThrough", passThrough,
                "fields", fields);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Boolean raw;

        private String consumerId;

        private String appId;

        private String serviceId;

        private JsonNullable<String> cursor;

        private Long limit;

        private String collectionId;

        private String ticketId;

        private CommentsSort sort;

        private Map<String, Object> passThrough;

        private JsonNullable<String> fields;

        private Builder() {
          // force use of static builder() method
        }

        /**
         * Include raw response. Mostly used for debugging purposes
         */
        public Builder raw(@Nullable Boolean raw) {
            this.raw = raw;
            return this;
        }

        /**
         * ID of the consumer which you want to get or push data from
         */
        public Builder consumerId(@Nullable String consumerId) {
            this.consumerId = consumerId;
            return this;
        }

        /**
         * The ID of your Unify application
         */
        public Builder appId(@Nullable String appId) {
            this.appId = appId;
            return this;
        }

        /**
         * Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API.
         */
        public Builder serviceId(@Nullable String serviceId) {
            this.serviceId = serviceId;
            return this;
        }

        /**
         * Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response.
         */
        public Builder cursor(@Nullable String cursor) {
            this.cursor = JsonNullable.of(cursor);
            return this;
        }

        /**
         * Number of results to return. Minimum 1, Maximum 200, Default 20
         */
        public Builder limit(@Nullable Long limit) {
            this.limit = limit;
            return this;
        }

        /**
         * The collection ID
         */
        public Builder collectionId(@Nonnull String collectionId) {
            this.collectionId = Utils.checkNotNull(collectionId, "collectionId");
            return this;
        }

        /**
         * ID of the ticket you are acting upon.
         */
        public Builder ticketId(@Nonnull String ticketId) {
            this.ticketId = Utils.checkNotNull(ticketId, "ticketId");
            return this;
        }

        /**
         * Apply sorting
         */
        public Builder sort(@Nullable CommentsSort sort) {
            this.sort = sort;
            return this;
        }

        /**
         * Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]=leads becomes ?search=leads
         */
        public Builder passThrough(@Nullable Map<String, Object> passThrough) {
            this.passThrough = passThrough;
            return this;
        }

        /**
         * The 'fields' parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: `fields=name,email,addresses.city`&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields "name", "email" and "addresses.city". If any other fields are available, they will be excluded.
         */
        public Builder fields(@Nullable String fields) {
            this.fields = JsonNullable.of(fields);
            return this;
        }

        public IssueTrackingCollectionTicketCommentsAllRequest build() {
            return new IssueTrackingCollectionTicketCommentsAllRequest(
                raw, consumerId, appId,
                serviceId, cursor, limit,
                collectionId, ticketId, sort,
                passThrough, fields);
        }


        private static final LazySingletonValue<Boolean> _SINGLETON_VALUE_Raw =
                new LazySingletonValue<>(
                        "raw",
                        "false",
                        new TypeReference<Boolean>() {});

        private static final LazySingletonValue<Long> _SINGLETON_VALUE_Limit =
                new LazySingletonValue<>(
                        "limit",
                        "20",
                        new TypeReference<Long>() {});
    }
}
